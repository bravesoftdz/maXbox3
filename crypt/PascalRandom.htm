<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<title>Random Numbers</title>
</head>

<body background="Wht_bkg.gif" bgcolor="#FFFFFF">

<p align="center"><font color="#0000FF" size="4"><b>
The Mystery of Random Numbers -- a Pascal Exercise</b></font> </p>                            

<b>
<P>Have you ever wondered how random numbers are generated by a computer?&nbsp;  Computers are generally very precise, and mathematical operations are generally very predictable, so it seems strange that computers can do something randomly, on purpose.&nbsp; So I'll try to explain the 'magic' of random numbers without getting too mathematical.</P>

<P>A common method of generating a random sequnce of numbers on a computer is to start with any number except zero, then generate the next random number by multiplying it by some 'special' number.&nbsp;  Of course, if we keep doing this, the number will soon get too big for the computer to hancle.&nbsp;  So the higher digits of the number are chopped off to prevent an 'arithmetic overflow' error.&nbsp;  The 'Random' function of Turbo Pascal and Borland Pascal use this kind of method with 16-bit integers.&nbsp;  But we will try doing it with 8-bit integers (bytes), because it will be easier to see how it works.</P>

<P>Try compiling and running this program:</P>

<PRE>program Rand1;

var
    R: byte;
    I: integer;

begin
    writeln;
    R:= 71;
    for I:= 1 to 80 do begin
        R:= Lo(R * 157);
        write(R:4);
        if (I mod 16) = 0 then writeln;
    end;
    readln;
end.</PRE>

<P>The purpose of the writeln statement is to put a blank line between the output of each experiment that we do.&nbsp;   The readln statement makes the program pause, waiting for us to press the Enter key after we look at the output.&nbsp;   The 'for' loop is to generate 80 numbers for each experiment.&nbsp;   The "<TT>if (I mod 16) = 0 then writeln</TT>" statement starts a new line after every 16 numbers.&nbsp;   The "<TT>write(R:4)</TT>" statement writes each 'random' value of R.&nbsp;   Since byte values range from 0 to 255, no more than 3 digits are needed, and the "<TT>:4</TT>" allows for at least one space to separate the random numbers.&nbsp; </P>

<P>We initially set R equal to 71.&nbsp;  Why 71?&nbsp;  It doesn't really matter, except that odd values work better (Try other values).&nbsp;  We just picked a number 'at random'.&nbsp; The 'special' number 157 is called the 'multiplier'.&nbsp; (Why 157?&nbsp; We'll explain later.)&nbsp; The "<TT>R:= Lo(R * 157)</TT>" statement inside the loop generates the next 'random' value of R, which depends of the previous value of R.&nbsp; So the number sequence isn't really random, because the next number is <I>determined</I> by the previous number and an exact rule.&nbsp;  (The sequence is called '<I>deterministic</I>'.)&nbsp; In a really random process, like tossing coins or dice, the process is too complex and imprecise for us to determine the outcome.</P>

<P>The result of the multiplication "<TT>R * 157</TT>" is generally larger than a byte -- a 2-byte integer, and the Lo function takes the low byte of the result.&nbsp; </P>

<P>The output of the program is:</P>

<PRE> 139  63 163 247 123 111  19 167 107 159 131  87  91 207 243   7
  75 255  99 183  59  47 211 103  43  95  67  23  27 143 179 199
  11 191  35 119 251 239 147  39 235  31   3 215 219  79 115 135
 203 127 227  55 187 175  83 231 171 223 195 151 155  15  51  71
 139  63 163 247 123 111  19 167 107 159 131  87  91 207 243   7</PRE>

<P>The output <I>looks</I> random (except that they are all odd values), but since it is really deterministic, it's called '<I>pseudorandom</I>' (false random).&nbsp; If you look at the output carefully, you will notice that the output repeats after 64 values; and that's another indication that the sequence isn't really random.&nbsp; </P>

<P>We can't avoid repetition, because since we limited the output to byte values, and since there are 256 byte values, we will need to repeat some values after at most the first 256 values.&nbsp; Also, since each value depends on the previous value, every time that 139 occurs, the next number will be 63; and every time that 63 occurs, the next number will be 163, etc.&nbsp;  So the best we can do is a byte sequence that repeats every 256 values.&nbsp;  But this program generates a byte sequence that repeats every 64 values.&nbsp; </P>

<P>You have probably been wondering why we chose a multiplier value of 157.&nbsp; Now is a good time for you to try other values, to see what happens.&nbsp; You will find that even numbers work very badly, and that some odd numbers provide longer sequences than others.&nbsp;  (The length of the sequence is how many numbers are generated before it starts to repeat.)&nbsp;  The longest length you will find is 64, so the multiplier value of 157 is one of the best.&nbsp; </P>  

<P>I did some experimenting, trying to get the maximum length (for 8-bit bytes) of 256.&nbsp;  I could get a length of 256 with the multiplier value of 157 if I chopped the product  "<TT>R * 157</TT>" down to 10 bits rather than 8 bits.&nbsp; The 10-bit values are too big.&nbsp;  But I found that the right-most 2 bits of the 10 bits are always 01, so they are not random. &nbsp; This gave me an idea:&nbsp;  The other 8 bits are random, so use them.&nbsp; So this is how we can start with one 'random' value R, and compute the next 'random' R:</P>  

<P>(1) Multiply R by 4 and add one.&nbsp;  <I>(This changes the 8-bit R into a 10-bit number that, in binary, ends with 01.)</I></P>

<P>(2) Multiply by 157.&nbsp;  <I>(This makes an 18-bit value.)</I></P>

<P>(3) Chop off the left-most 8 bits and the right-most 2 bits.&nbsp;  <I>(This leaves 8 bits.)</I></P>

<P>The first two steps compute <TT>(4*R + 1) * 157</TT>, which can be simplified as <TT>628*R + 157</TT>, because <TT>4*157 = 628</TT> and <TT>1*157 = 157</TT>.&nbsp;  But how do we do step 3?</P>

<P>To chop off the left-most 8 bits of an 18-bit value (leaving 10 bits), we can use Pascal's 'and' operator on integers.&nbsp;  When the 'and' operator is used on integers, each bit of each integer is treated as a boolean value -- 1 is true and 0 is false.&nbsp;  The 'and' operator is applied to corresponding bits like this:</P>

<PRE>    A =       100011100110111101  (145853 in decimal)
    B =       000000001111111111  (1023 in decimal)
    A and B = 000000000110111101  (445 in decimal)
    which is =        0110111101  (10 bits)</PRE>
    
<P>Notice that on the left side where B is zeros, "<TT>A and B</TT>" is made zeros, no matter the value of A.&nbsp;  But on the right side where B is ones, "<TT>A and B</TT>" is just a copy of A.&nbsp;  Since zeros on the left of an integer do not contribute to its value, they can be removed -- 'chopped off'.&nbsp; </P>

<P>To chop off the right-most 2 bits of an integer, we can use Pascal's 'shr' (shift right) operator.&nbsp;  For example, "445 shr 2" shifts the binary representation of 445 to the right two bit positions, like this:</P>

<PRE>    445       = 0110111101
    445 shr 2 =   01101111  (111 in decimal)</PRE>

<P>So, putting all these steps together, a Pascal statement for changing one value of R to the next value is:</P>

<PRE>        R:= ((628 * R + 157) and 1023) shr 2;</PRE>

<P>But we will get an "arithmetic overflow" error when this statement runs.&nbsp;  This happens because we have declared R to be a byte (8 bits), but the multiplication generates an 18-bit value.&nbsp;  That is, we need longint precision.&nbsp;  To tell this to the compiler, we can write:</P>

<PRE>        R:= ((longint(628) * R + 157) and 1023) shr 2;</PRE>

<P>This statement is now correct; but we can make the method clearer if we write the constant 1023 in hexadecimal notation.&nbsp;  In Pascal, hexadecimal notation is indicated by a '$' prefix, so we change the "<TT>1023</TT>" to "<TT>$3FF</TT>".&nbsp;  We can easily translate the hexadecimal to binary, because each hexadecimal digit is equivalent to four bits like this:</P>

<PRE>    $0 = 0000
    $1 = 0001
    $2 = 0010
    $3 = 0011
    $4 = 0100
    $5 = 0101
    $6 = 0110
    $7 = 0111
    $8 = 1000
    $9 = 1001
    $A = 1010
    $B = 1011
    $C = 1100
    $D = 1101
    $E = 1110
    $F = 1111</PRE>

<P>So 3FF in hexadecimal translates to 0011 1111 1111 in binary (1023 in decimal).&nbsp;  The $3FF makes it clearer that the number is 10 ones in a row.&nbsp;  Here is the modified program:</P>

<PRE>program Rand2;

var
    R: byte;
    I: integer;

begin
    writeln;
    R:= 71;
    for I:= 1 to 272 do begin
        R:= ((longint(628) * R + 157) and $3FF) shr 2;
        write(R:4);
        if (I mod 16) = 0 then writeln;
    end;
    readln;
end.</PRE>

<P>The program output is:</P>

<PRE> 178  81 212  43 134  85  72  79 154 153 252 179 238  29 240  87
 130 225  36  59  86 229 152  95 106  41  76 195 190 173  64 103
  82 113 116  75  38 117 232 111  58 185 156 211 142  61 144 119
  34   1 196  91 246   5  56 127  10  73 236 227  94 205 224 135
 242 145  20 107 198 149 136 143 218 217  60 243  46  93  48 151
 194  33 100 123 150  37 216 159 170 105 140   3 254 237 128 167
 146 177 180 139 102 181  40 175 122 249 220  19 206 125 208 183
  98  65   4 155  54  69 120 191  74 137  44  35 158  13  32 199
  50 209  84 171   6 213 200 207  26  25 124  51 110 157 112 215
   2  97 164 187 214 101  24 223 234 169 204  67  62  45 192 231
 210 241 244 203 166 245 104 239 186  57  28  83  14 189  16 247
 162 129  68 219 118 133 184 255 138 201 108  99 222  77  96   7
 114  17 148 235  70  21   8  15  90  89 188 115 174 221 176  23
  66 161 228 251  22 165  88  31  42 233  12 131 126 109   0  39
  18  49  52  11 230  53 168  47 250 121  92 147  78 253  80  55
 226 193 132  27 182 197 248  63 202   9 172 163  30 141 160  71
 178  81 212  43 134  85  72  79 154 153 252 179 238  29 240  87
</PRE>

<P>The last row is a repeat of the first row.&nbsp;  Before the repeating starts, each of the values from 0 to 255 appears exactly once.&nbsp; </P>

<P>As we said before, the number sequence appears to be random, but unlike really random numbers like those generated by a cage full of numbered balls for the lottery, this sequence is predictable and repeatable.&nbsp;   Every time we start with 71, we get the same sequence, which is actually a cycle that returns to 71 and starts over again.&nbsp;   If we start with a different number, we get the same sequence except that we start at a different part of the same cycle.&nbsp;   If we have a random number generator with a VERY long cycle, however, it is likely that the program that uses these random numbers will finish before the random number cycle is finished.&nbsp;   In this case, the random sequence is not repeated.&nbsp;   It is even likely, or almost certain, that by changing the starting number, we will get a completely different sequence.&nbsp; </P>

<P>What if we could get just one truely random, unpredictable number?&nbsp;  If we start the random number generator with this 'seed' number when the program starts, the whole sequence would be (in some sense) unpredictable.&nbsp;  What is usually done is that the program looks at the computer's clock, including the fractions of the second, to get a 'seed' number.&nbsp;  For example, when a Solitaire game program does this, the deck of cards are 'shuffled' differently every time.&nbsp;  But if you were using a program to do a scientific experiment with random numbers, and you wanted to repeat the experiment to check for errors, then you might want to start the random number generator with a fixed number, so that you could repeat some trouble that you were investigating.&nbsp; </P>

<P>Most random number generators are similar to this small one that we experimented with, but are larger, making sequences that don't repeat until after several billion numbers.&nbsp;  For example, Borland Pascal's "Random" function uses the rule <TT>R:= 134775813 * R + 1</TT>, which generates a sequence of 4,294,967,296 values before it repeats.&nbsp; But the sequence is not quite as random as it should be.&nbsp;  The values are alternately odd and even, and don't change from positive to negative (and back to positive) as often as they should.&nbsp; If we had a better random number generator, with a long period, and initialized by the computer's clock, it might be very hard to tell the difference between the pseudorandom sequence and a truly random sequence.</P>

<HR>

<P>Many years ago, I noticed an article in a technical magazine about how to generate random numbers.&nbsp;  The authors (Park and Miller) had tested many different random number generators, using some very sophisticated mathematics, and had concluded that the random number generators provided with most programming languages were not very good.&nbsp;  They provided an algorithm for generating random numbers that they claimed was much better.&nbsp;  (An <I>algorithm</I> is an exact procedure, whether written in English, Pascal, or some other programming language.)&nbsp; I wrote the Park/Miller algorithm in Pascal, as follows:</P>

<PRE>var
	S: longint; 	{seed, random state}

const
	M = 2147483647; {MaxLongint}
	A = 16807;
	Q = 127773;
	R = 2836;

function PMrandom: longint; {returns 1 &lt;= X &lt;= MaxLongint}
var
	Lo, Hi, T: longint;
begin
	Hi:= S div Q;
	Lo:= S mod Q;
	T:= A*Lo - R*Hi;
	if T &gt; 0
	then S:= T
	else S:= T+M;
	PMrandom:= S;
end; {PMrandom}</PRE>

<P>This one is obviously more complex; and I won't try to explain how it works or why it is better.&nbsp;  We will just accept that the experts think that it is better.&nbsp; The PMrandom function generates random positive longint (31-bit) values, and has a period of 2,147,483,646.&nbsp; The positive longint values range from 1 to 2147483647, and all values in this range are equally probable. </P>

<P>(Years later, I found another random number generator that was MUCH bigger, called the "Mersenne Twister".&nbsp;  The length of its period is a 6000-digit number!)&nbsp; </P>

<P>Many programs have use for a random number generator, so I put the PMrandom function in a unit.&nbsp; But such programs generally need different kinds of random values.&nbsp; For example, if we are simulating the toss of a coin, we need a result that has two values that are equally likely.&nbsp;  If we are simulating the toss of a die, we need a result that has six values that are equally likely.&nbsp; Or we might need to pick a card randomly.&nbsp;  These all have one thing in common: the ability to choose one of N values randomly, with all N values equally likely. &nbsp; Another kind of randomness is to have something true with a certain probability.&nbsp;  For example, when a target is hit, it randomly falls 80% of the time.&nbsp; Another kind of randomness is a value in some range that isn't necessarily an integer, such as a length between 3.5 and 6.75 feet.</P>

<P>So I started writing functions to generate various kinds of random values.&nbsp;  Each of these functions used the PMrandom function, and all of these functions were put into the new unit.&nbsp; </P>

<P>To get random lengths between 3.5 and 6.75 feet, or random amounts of fuel between 2.5 and 10 gallons, and other such, we could use a random function that returns a real value in the range 0.0 to 1.0.&nbsp;  We name this function Rrand (R for Real).&nbsp;  To get random lengths between 3.5 and 6.75 feet, we compute "<TT>3.5 + (6.75 - 3.5) * Rrand</TT>".&nbsp;  To get random amounts of fuel between 2.5 and 10 gallons, we compute "<TT>2.5 + (10 - 2.5) * Rrand</TT>".&nbsp; </P>

<P>How do we implement the Rrand function?&nbsp; To get a random real value in the range 0.0 to 1.0, we compute "<TT>Rrand:= PMrandom / 2147483647.0</TT>".&nbsp;  Notice that we need to do a real division '<TT>/</TT>' rather than integer division '<TT>div</TT>', to get a real result.&nbsp;  For a real division, Pascal requires that at least one of the operands must be real.&nbsp;  So we include "<TT>.0</TT>" after the "<TT>2147483647</TT>" to make it a real value.&nbsp; So, the Rrand function is simply this:</P>

<PRE>function Rrand: extended;       {returns 0.0 &lt; X &lt; 1.0}
begin
    Rrand:= PMrandom / 2147483647.0;
end; {Rrand}</PRE>

<P>To choose one of N values randomly, with all N values equally likely, we can compute "<TT>PMrandom mod N</TT>".&nbsp; This will produce random values in the range 0 .. N-1, and the values in this range will be equally likely provided that N is much smaller than the largest longint (MaxLongint = 2147483647).&nbsp;  We can satisfy this condition if N is a 'word' (a 16-bit unsigned integer).&nbsp;  So, the Irand function (I for Integer) is:</P>

<PRE>function Irand(N: word): word;      {returns 0 &lt;= X &lt; N}
var L: longint;
begin
    L:= PMrandom mod N;
    Irand:= L;
end; {Irand}</PRE>

<P>We couldn't write "<TT>Irand:= PMrandom mod N</TT>" because PMrandom returns a longint, but Irand should return a word.&nbsp;  So we pass the value through the longint variable L.&nbsp; </P>

<P>As an example, "<TT>Irand(6)</TT>" will return random values in the range 0 .. 5.&nbsp;  If we want random values in the range 1 .. 6 (for a die), we write "<TT>Irand(6) + 1</TT>". </P>

<P>Next, how can we produce a random boolean value that is true with a certain probability P?&nbsp; If we generate a random real value R in the range 0.0 .. 1.0 by using the Rrand function, then the probability that R is less than P is P.&nbsp;  That is, the condition "<TT>R &lt; P</TT>" is true with probability P.&nbsp; A few examples will make this more understandable: </P>

<P><UL>
<LI>Half of the time, R will be between 0.0 and 0.5, and the other half of the time, R will be between 0.5 and 1.0.&nbsp; So, R is less than 0.5 half of the time, that is, with probability 0.5.</LI>
<LI>R is less than 0.1 one-tenth of the time, that is, with probability 0.1; and R is greater than 0.1 nine-tenths of the time.</LI>
<LI>R is less than 0.9 nine-tenths of the time, that is, with probability 0.9; and R is greater than 0.9 one-tenth of the time.</LI>
</UL></P>

<P>So, the Brand function for random booleans is:</P>

<PRE>function Brand(P: extended): boolean;   {returns true with probability P}
begin
    Brand:= (PMrandom / 2147483647.0 &lt; P);
end; {Brand}</PRE>

<P>We could have written "<TT>Brand:= (Rrand &lt; P)</TT>", but since the Rrand function is so simple, the program can run faster with "<TT>Brand:= (PMrandom / 2147483647.0 &lt; P)</TT>".</P>

<P>The Rrand, Irand, and Brand functions for random Reals, Integers, and Booleans are all '<I>uniform distributions</I>', which means that all values are equally possible within the range of values for each of these types.&nbsp;  Think of the probability being distributed uniformly (evenly) over the range of values.&nbsp;  There is a <U>non-uniform</U> distribution that typically occurs when we are dealing with a large sum of random events -- mathematicians call it the '<I>normal distribution</I>'.&nbsp; I included a Nrand function for this kind of random variable.&nbsp;  For example, if you dumped a container of 1000 coins on the floor, the number of heads would be a random number that could range from 0 to 1000.&nbsp;  But it would be far more probable for the number of heads to be between 490 and 510 than between 0 and 20 or than between 980 and 1000.&nbsp;  In this example, the '<I>mean</I>' (average) number of heads is 500.&nbsp;  There is also a measure of how widely (or narrowly) the random values are distributed around the '<I>mean</I>' value, called the '<I>standard deviation</I>'.&nbsp;  Nrand produces a normally-distributed random value with a mean of zero and a standard deviation of one.&nbsp;  To get a normally-distributed random value with a mean of M and a standard deviation of S, compute <TT>M + S * Nrand</TT>.&nbsp; </P>

<P>I also wrote a procedure to start the random number generator with a 'seed' value.&nbsp; If the argument I is non-zero, then I is used as the seed value.&nbsp; If the argument I is zero, then the Randomize procedure of the System unit is used to get a seed value from the computer's clock.&nbsp; If the seed value is not in the range 1 .. 2147483647, then it is modified to put it in this range.&nbsp; </P>

<PRE>procedure PMrandomize(I: word); {initializes the randomizer}
begin
    if I &lt;&gt; 0 then S:= I
    else begin
        System.Randomize;
        S:= System.RandSeed;
    end;
    S:= S and M;
    if S = 0 then inc(S);
end; {PMrandomize}</PRE>

<P>All of these random functions, and the seeding procedure, are provided in the following unit. (You can also <A href="PMrand.pas">download the PMrand.pas file.</A>)  </P>

<PRE>unit PMrand;    {Park / Miller random number generator}
                {see Comm. ACM Oct. 88 Vol. 31 No. 10.}

{*******************************************************}
{                                                       }
{       2-16-95 Added Nrand function, changed real      }
{               type to extended.                       }
{                                                       }
{       3-9-99  Made PMRandom far.                      }
{                                                       }
{       9-11-06 Fixed minor bugs.                       }
{                                                       }
{*******************************************************}

interface

{deterministic for I&gt;0, non-deterministic for I=0:}
procedure PMrandomize(I: word);  {initializes the randomizer}

{for functions PMrandom, Rrand, and Irand,}
{all returned values in the range given are equally probable}

{the basic routine:}
function PMrandom: longint;  {returns 1 &lt;= X &lt;= MaxLongint} far;

{for real values:}
function Rrand: extended;       {returns 0.0 &lt; X &lt; 1.0}

{for subrange integers:}
function Irand(N: word): word;      {returns 0 &lt;= X &lt; N}

{for random booleans:}
function Brand(P: extended): boolean;       {returns true with probability P}

{ approximately normal distribution }
{ with mean = 0 and standard deviation = 1: }
function Nrand: extended;       {actual range is -6 .. 6}

{*******************************************************}

implementation

var
    S: longint;     {seed, random state}

const
    M = 2147483647; {MaxLongint}
    A = 16807;
    Q = 127773;
    R = 2836;

{*******************************************************}

procedure PMrandomize(I: word); {initializes the randomizer}
begin
    if I &lt;&gt; 0 then S:= I
    else begin
        System.Randomize;
        S:= System.RandSeed;
    end;
    S:= S and M;
    if S = 0 then inc(S);
end; {PMrandomize}

{*******************************************************}

function PMrandom: longint; {returns 1 &lt;= X &lt;= MaxLongint}
var
    Lo, Hi, T: longint;
begin
    Hi:= S div Q;
    lo:= S mod Q;
    T:= A*Lo - R*Hi;
    if T &gt; 0
    then S:= T
    else S:= T+M;
    PMrandom:= S;
end; {PMrandom}

{*******************************************************}

function Rrand: extended;       {returns 0.0 &lt; X &lt; 1.0}
begin
    Rrand:= PMrandom / 2147483647.0;
end; {Rrand}

{*******************************************************}

function Irand(N: word): word;      {returns 0 &lt;= X &lt; N}
var L: longint;
begin
    L:= PMrandom mod N;
    Irand:= L;
end; {Irand}

{*******************************************************}

function Brand(P: extended): boolean;   {returns true with probability P}
begin
    Brand:= (PMrandom / 2147483647.0 &lt; P);
end; {Brand}

{*******************************************************}

{-------------------------------------------------------}
{   Here, we use the fact that the sum of N Rrand       }
{   values has a mean value of N/2 and a variance       }
{   of N/12, and is normally distributed for 'large'    }
{   N.  It is convenient to choose N = 12.              }
{-------------------------------------------------------}

{ approximately normal distribution }
{ with mean = 0 and standard deviation = 1: }
function Nrand: extended;
var
    I: integer;
    S: extended;
begin
    S:= -6.0;
    for I:= 1 to 12 do begin
        S:= S + (PMrandom / 2147483647.0);  { + Rrand}
    end;
    Nrand:= S;
end; {Nrand}

{*******************************************************}

begin
    PMrandomize(0);
end.
</PRE>

<P>In the initialization section of the unit, "<TT>PMrandomize(0)</TT>" is called to seed the random number generator from the computer's clock.&nbsp;  If you don't want it started this way, your program can call PMrandomize with some non-zero value.&nbsp; </P>

<P>Here is a program that demonstrates how to use the PMrand unit:</P>

<PRE>program Rand3;
uses PMrand;

type
    TCoin = array[boolean] of string[4];

const
    Coin: TCoin = ('head', 'tail');
    NCoins = 10;
    NDice = 8;

var
    Seed: longint;
    C: boolean;
    I, Tails, D1, D2: integer;

begin
    write('Seed value = ');  Readln(Seed);
    PMrandomize(Seed);

    writeln;
    writeln('Tossing ', NCoins, ' coins:');
    Tails:= 0;
    for I:= 1 to NCoins do begin
        C:= Brand(0.5);
        write(Coin[C]:5);
        if C then inc(Tails);
    end;
    writeln;
    writeln(Tails, ' tails and ', NCoins-Tails, ' heads');

    writeln;
    writeln('Tossing ', NDice, ' pairs of dice:');
    for I:= 1 to NDice do begin
        D1:= Irand(6)+1;
        D2:= Irand(6)+1;
        write(' ', D1, '+', D2, '=', D1+D2);
    end;
    writeln;

    writeln;
    writeln('Six random angles between 180 and 270 degrees:');
    for I:= 1 to 6 do begin
        write(180 + 90*Rrand :8:3);
    end;
    writeln;
    
    readln;
end.
</PRE>

<P>Notice how the structured constant named 'Coin' is used to translate the boolean values false and true to the string values 'head' and 'tail'.&nbsp;  Notice also how we can use an expression to modify the range of a random variable by 'rescaling' the random function.&nbsp;  For example, the expression "<TT>180 + 90*Rrand</TT>" obtains a range of 180 to 270; but Rrand by itself has a range of 0 to 1.&nbsp; To determine the new range from the old range, substitute the old range limits 0 and 1 into the expression, like this:</P>

<PRE>    180 + 90*0 = 180
    180 + 90*1 = 270</PRE>

<P>(Since Rrand returns a real value, <TT>90*Rrand</TT> becomes a real value, even though 90 is an integer; and likewise the addition is real, even though 180 is an integer.)&nbsp; </P>

<P>A typical output of this demo program is:</P>

<PRE>Seed value = 45

Tossing 10 coins:
 tail head tail head head head tail head head tail
4 tails and 6 heads

Tossing 8 pairs of dice:
 2+5=7 6+6=12 2+5=7 4+4=8 2+4=6 4+4=8 2+5=7 5+5=10

Six random angles between 180 and 270 degrees:
 192.458 218.372 244.797 229.822 266.799 206.902
</PRE>

<P>If you enter a seed value of 45, you will always get this output; and if you enter a seed value of 91, you will always get some other output.&nbsp;  But if you enter a seed value of 0, the output will always be different, because the program will actually use a seed taken from the computer's clock time.</P>

<P>Most programs that use the PMrand unit will not call the PMrandomize procedure, because the initialization section of PMrand calls PMrandomize to start the random sequence from the computer's clock -- and this is what most programs need.&nbsp; </P>

<HR>

</b>
</body>
</html>

