PROGRAM Synapse_Tutor_1;

///////////////////////////////////////////////////////////////////////////
//  #sign:Administrator: PC08: 08/03/2014 09:38:08 AM 
//  Purpose: how to call synapse function, still on progress with lots of experiments 
//  #path>ples\E:\maxbox3\mXGit39988\maxbox3\examples\                    
//  Lines of Code #locs:542
///////////////////////////////////////////////////////////////////////////

Const TEXTOUT = 'hi world of dll SYNAPSE func in opcode ';

{$DEFINE MSWINDOWS}

//############################################################################
// Archimedes SYNAPSE Architect Tutor Tour
//############################################################################
//TODO: Button with stop event, change color and save bitmap as png
  //TODO: transfer the App to a dll stub function!
  //{ TODO : the following line looks like a bug... }
  //#net: DNS: ; local IPs: fe80::39cb:cc4a:b4e7:9e03%20,fe80::25d2:cdb2:b4d2:1291%21,192.168.25.1,192.168.18.1; local IP: 192.168.25.1

{type  
  PROCESS_MEMORY_COUNTERS = record
    cb : DWORD;
    PageFaultCount : DWORD;
    PeakWorkingSetSize : DWORD;
    WorkingSetSize : DWORD; //Task managers MemUsage number
    QuotaPeakPagedPoolUsage : DWORD;
    QuotaPagedPoolUsage : DWORD;
    QuotaPeakNonPagedPoolUsage : DWORD;
    QuotaNonPagedPoolUsage : DWORD;
    PagefileUsage : DWORD; //TaskMan's VM Size number
    PeakPagefileUsage : DWORD;
  end;
  TProcessMemoryCounters = PROCESS_MEMORY_COUNTERS;}
  { _OSVERSIONINFOA = record
    dwOSVersionInfoSize: DWORD;
    dwMajorVersion: DWORD;
    dwMinorVersion: DWORD;
    dwBuildNumber: DWORD;
    dwPlatformId: DWORD;
    szCSDVersion: array[0..127] of AnsiChar; { Maintenance AnsiString for PSS usage }
  {end;
 //TIntegerList
 //var aos: TOSVersionInfo;

//  function  {**************************************************}
 Function GetProcessMemoryInfo(Process: THandle; var MemoryCounters: TProcessMemoryCounters;
                                    cb: DWORD): BOOL; //stdcall;; 
     External 'GetProcessMemoryInfo@psapi.dll stdcall';
     
 Function OpenProcess2(dwDesiredAccess:DWORD; bInheritHandle:BOOL; dwProcessId:DWORD):THandle;
     External  'OpenProcess@kernel32.dll stdcall';

 procedure GetVersionEx3(out verinfo: TOSVersionInfo);    //var verinfo: TOSVersionInfo
     External  'GetVersionExA@kernel32.dll stdcall';

{TYPE <Type declarations>} 
  var FWait, switch: Boolean;
      FValueA, FValueB: Float;
      //asd: TDoubleArray;
     
//<FUNCTION>
//<PROCEDURE> 
{*****************************************************}
//function GetProcessMemoryInfo; external 'psapi.dll';
{*****************************************************}

function ProcessMemoryUsage(ProcessID : DWORD): DWORD;
var ProcessHandle : THandle;
    MemCounters   : TProcessMemoryCounters;
begin
  Result:= 0;
  //PROCESS_QUERY_INFORMATION Required to retrieve certain information about process, such as its token, exit code, and priority class   - 0x0400
  //PROCESS_VM_READ Required to read memory in a process using ReadProcessMemory.
  ProcessHandle:= OpenProcess2(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ,
                               false, ProcessID);
  writeln('Process Handle inside: '+inttostr(ProcessHandle));
  try
    if GetProcessMemoryInfo(ProcessHandle,
                            MemCounters, sizeof(MemCounters))
    then Result:= MemCounters.WorkingSetSize;
  finally
    CloseHandle(ProcessHandle);
  end;
end;

function ProcessPageUsage(ProcessID: DWORD): DWORD;
var ProcessHandle : THandle;
    MemCounters   : TProcessMemoryCounters;
begin
  Result:= 0;
  ProcessHandle:= OpenProcess2(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ,
                                false, ProcessID);
  try
    if GetProcessMemoryInfo(ProcessHandle, 
                              MemCounters, sizeof(MemCounters))
    then Result:= MemCounters.PagefileUsage;
  finally
    CloseHandle(ProcessHandle);
  end;
end;

function ProcessAllRec(ProcessID : DWORD): TProcessMemoryCounters;
var ProcessHandle : THandle;
    MemCounters   : TProcessMemoryCounters;
begin
  //Result:= NULL;
  ProcessHandle:= OpenProcess2(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ,
                               false, ProcessID);
  try
    if GetProcessMemoryInfo(ProcessHandle,
                            MemCounters, sizeof(MemCounters))
    then Result:= MemCounters;
  finally
    CloseHandle(ProcessHandle);
  end;
end;



function SplitToken(const Text: string; SplitChar: Char;
                          var First, Last: string): Boolean;
var  SplitPos: Integer;
begin
  Result:= False;
  SplitPos:= Pos(SplitChar, Text);
  if SplitPos = 0 then Exit;
  First:= Trim(Copy(Text, 1, SplitPos -1));
  Last:= Trim(Copy(Text, SplitPos +1, Length(Text) -SplitPos));
  Result:= (First <>'') and (Last <>'');
end;


function TForm1_scrollAllNode(aNode: TalXmlNode): Integer;
Var aStack: Tstack;
    i: integer;
begin
  Result := 0;
  aStack := Tstack.Create;
  try
     For i := 0 to aNode.ChildNodes.Count - 1 do
        aStack.Push((ANode.ChildNodes[i]));
         While astack.Count > 0 do begin
        inc(result);
        aNode := TalxmlNode(astack.Pop);
        If assigned(ANode.ChildNodes) then
          For i := 0 to ANode.ChildNodes.Count - 1 do
            aStack.Push((ANode.ChildNodes[i]));
           If assigned(ANode.AttributeNodes) then
          For i := 0 to ANode.attributeNodes.Count - 1 do
            aStack.Push((ANode.AttributeNodes[i]));
      end;
  finally
    aStack.Free;
  end;
end;


function CheckPSAPILoaded: Boolean;
var hPSAPI: THandle;
begin
  if hPSAPI = 0 then begin
{$IFDEF MSWINDOWS}
    hPSAPI:= LoadLibrary('PSAPI.dll');
    //writeln('debug DLL handle '+inttostr(hPSAPI));
    if hPSAPI > 32 then result:= true;
    if hPSAPI < 32 then begin
      hPSAPI:= 0;
      Result:= False;
      Exit;
    end;
 {$ENDIF}   
  end; 
end;

function IntToStrZeroPad(Value, Count: Integer): AnsiString;
begin
  Result := IntToStr(Value);
  if Length(Result) < Count then
    Result := StrFillChar('0', Count - Length(Result)) + Result;
end;

function JclGUIDToString(const GUID: TGUID): string;
begin
  {$IFDEf CLR}
  Result := GUID.ToString();
  {$ELSE}
  Result := Format('{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}',
    [GUID.D1, GUID.D2, GUID.D3, GUID.D4[0], GUID.D4[1], GUID.D4[2],
     GUID.D4[3], GUID.D4[4], GUID.D4[5], GUID.D4[6], GUID.D4[7]]);
  {$ENDIF CLR}
end;

{BOOL GetVersionEx( 
  LPOSVERSIONINFO lpVersionInformation );}

function GetOsVersionInfo2: TOSVersionInfo; 
var
  verInfo: TOSVersionInfo;
begin
  verinfo.dwOSVersionInfoSize:= sizeof(verinfo);
  GetVersionEx(Verinfo);
  result:= Verinfo;
end;  

function GetOsVersionInfo3: TOSVersionInfo; 
var
  verInfo: TOSVersionInfo;
begin
  verinfo.dwOSVersionInfoSize:= sizeof(verinfo);
  GetVersionEx3(Verinfo);
  result:= Verinfo;
end; 

function IsWindowsVista: boolean;
var
  verInfo: TOSVersionInfo;
begin
  verinfo.dwOSVersionInfoSize:= Sizeof(verinfo);
  GetVersionEx(Verinfo);
  result:= Verinfo.dwMajorVersion >=6;
end;

const
  NTdyn = 'System\CurrentControlSet\Services\Tcpip\Parameters\Temporary';
  NTfix = 'System\CurrentControlSet\Services\Tcpip\Parameters';
  W9xfix = 'System\CurrentControlSet\Services\MSTCP';


function GetLocalIPs2: string;
var
  TcpSock: TBlockSocket;
  TcpSock1: TTCPBlockSocket;
  TcpSock2: TBlockSocket2;

  ipList: TStringList;
begin
  Result := '';
  ipList := TStringList.Create;
  try
    TcpSock2:= TBlockSocket2.create(4);
    TcpSock1:= TTCPBlockSocket.create;
    TcpSock:= TBlockSocket.create;
   try
      TcpSock.ResolveNameToIP(TcpSock.LocalName, ipList);
      Result := ipList.CommaText;
    finally
      TcpSock.Free;
      TcpSock1.Free;
      TcpSock2.Free;
    end;
  finally
    ipList.Free;
  end;
end;


function ReadRegEx(SubKey, Vn: PChar): string;
var
 OpenKey: HKEY;
 DataType, DataSize: integer;
 Temp: array [0..2048] of char;
begin
  Result := '';
  if RegOpenKeyEx(HKEY_LOCAL_MACHINE, SubKey, REG_OPTION_NON_VOLATILE,
    KEY_READ2, OpenKey) = ERROR_SUCCESS then begin
    DataType := REG_SZ;
    DataSize := SizeOf(Temp);
    //if RegQueryValueEx(OpenKey,Vn,nil,@DataType,@Temp,@DataSize) = ERROR_SUCCESS then
      //SetString(Result, Temp, DataSize div SizeOf(Char) - 1);
    RegCloseKey(OpenKey);
   end;
end;


function GetDNS2: string;
{$IFDEF UNIX}
var
  l: TStringList;
  n: integer;
begin
  Result := '';
  l := TStringList.Create;
  try
    l.LoadFromFile('/etc/resolv.conf');
    for n := 0 to l.Count - 1 do 
      if Pos('NAMESERVER', uppercase(l[n])) = 1 then begin
        if Result <> '' then
          Result := Result + ',';
        Result := Result + SeparateRight(l[n], ' ');
      end;
  finally
    l.Free;
  end;
end;
{$ELSE}
begin
  //Result := GetDNSbyIpHlp;
  if Result = '...' then begin
    if Win32Platform = VER_PLATFORM_WIN32_NT then
    begin
      Result := ReadReg(HKEY_LOCAL_MACHINE, NTdyn, 'NameServer');
      if result = '' then
        Result := ReadReg(HKEY_LOCAL_MACHINE, NTfix, 'NameServer');
      if result = '' then
        Result := ReadReg(HKEY_LOCAL_MACHINE, NTfix, 'DhcpNameServer');
    end
    else
      Result := ReadReg(HKEY_LOCAL_MACHINE, W9xfix, 'NameServer');
    Result := ReplaceString(trim(Result), ' ', ',');
  end;
end;
{$ENDIF}


procedure AppendToLog(logfile: string; const value: Ansistring);
var
  st: TFileStream;
  s: string;
  h, m, ss, ms: word;
  dt: Tdatetime;
//var LogFile: string;
begin
  if fileexists(LogFile) then
    st:= TFileStream.Create(LogFile, fmOpenReadWrite or fmShareDenyWrite)
  else
    st:= TFileStream.Create(LogFile, fmCreate or fmShareDenyWrite);
  try
    st.Position:= st.Size;
    dt:= Now;
    decodetime(dt, h, m, ss, ms);
    s:= formatDateTime('yyyymmdd-hhnnss', dt)+format('.%.3d', [ms]) + ' '+value;
    WriteStrToStream(st, s);
  finally
    st.free;
  end;
end;


function SearchEndInline(const Value: string; be: Integer): Integer;
  var
    n, q: Integer;
  begin
    q := 0;
    Result := 0;
    for n := be + 2 to Length(Value) - 1 do
      if Value[n] = '?' then begin
        Inc(q);
        if (q > 2) and (Value[n + 1] = '=') then begin
          Result := n;
          Break;
        end;
      end;
  end;



function InlineDecodetest(const Value: string; CP: TMimeChar): string;
var
  s, su, v: string;
  x, y, z, n: Integer;
  ichar: TMimeChar;
  c: Char;
begin
  Result := '';
  v := Value;
  x := Pos('=?', v);
  y := SearchEndInline(v, x);
  //fix for broken coding with begin, but not with end
  if (x > 0) and (y <= 0) then
    y := Length(Result);
  while (y > x) and (x > 0) do
  begin
    s := Copy(v, 1, x - 1);
    if Trim(s) <> '' then
      Result := Result + s;
    s := Copy(v, x, y - x + 2);
    Delete(v, 1, y + 1);
    su := Copy(s, 3, Length(s) - 4);
    z := Pos('?', su);
    if (Length(su) >= (z + 2)) and (su[z + 2] = '?') then begin
      ichar := GetCPFromID(SeparateLeft(Copy(su, 1, z - 1), '*'));
      c := UpperCase(su)[z + 1];
      su := Copy(su, z + 3, Length(su) - z - 2);
      if c = 'B' then
      begin
        s := synDecodeBase64(su);
        s := CharsetConversion(s, ichar, CP);
      end;
      if c = 'Q' then begin
        s := '';
        for n := 1 to Length(su) do
          if su[n] = '_' then
            s := s + ' '
          else
            s := s + su[n];
        s := DecodeQuotedPrintable(s);
        s := CharsetConversion(s, ichar, CP);
      end;
    end;
    Result := Result + s;
    x := Pos('=?', v);
    y := SearchEndInline(v, x);
  end;
  Result := Result + v;
end;


var  verInfo: TOSVersionInfo;
     aProcessHandle : THandle;
     filestr: string;

Begin  //Main
//<Executable statements> //TOutlookExport_Spy;
  Writeln('');
  //Writeln('Start Command of DLL: '+CheckIEStartCommand);  
//<Definitions>  
   //ares:= TResolver.create;
 { with TResolver.create do begin
   //writeln(inttostr(GetHostByName(gethostname)));
    Free;   end;  }
    {repeat 
     TApplication_PaintView(aform.canvas);
     switch:= NOT switch;
     Sleep(20);
   until isKeyPressed or FWait;}
    {with TledForm.create(self) do begin
    showmodal; free; end;} 
 // function GetMacAddresses(const Machine: string; const Addresses: TStrings):Integer;
   
 //GetProcessMemoryInfo(Process 
     writeln('workset mem from dll '+inttostr(ProcessMemoryUsage(GetCurrentProcessID)));
     writeln('workset page from dll '+inttostr(ProcessPageUsage(GetCurrentProcessID)));
     writeln('workset memproc test in bytes '
                 +inttostr(ProcessAllRec(GetCurrentProcessID).workingsetsize));
     writeln('proc peak max. workingset in K '
              +inttostr(ProcessAllRec(GetCurrentProcessID).PeakWorkingSetSize div 1024));
     writeln('proc peak max. paged use in K '
              +inttostr(ProcessAllRec(GetCurrentProcessID).QuotaPeakPagedPoolUsage));
     writeln('proc page peak file usage K '
              +inttostr(getProcMemInfo(GetCurrentProcessID).PeakPagefileUsage div 1024));
     if CheckPSAPILoaded then
        writeln('!workset! mem from dll in K '
              +inttostr(getProcMemInfo(GetCurrentProcessID).Workingsetsize div 1024));
 
    // SplitImages(self);
     //deletefiles(PICPATH,'*.bmp');
      //GetCurrentHwProfile( var lpHwProfileInfo : THWProfileInfo) : BOOL');
        //SetPriorityClass  //GetPriorityClass
     //OpenClipboard(   //booleantostr(false);
     //JclGUIDToString  //TJclNumericFormat 
          //function IsClass(Address: Pointer): Boolean;
          //function IsObject(Address: Pointer): Boolean;
           //IsClass(Address: Pointer): Boolean;
           //IsObject(Address: Pointer): Boolean;
           //ReadKey  //IntToStrZeroPad //  StrFillChar //EndDialog( 
         //GetDlgItem(  //SetDlgItemInt( //dialogbox
         //TQuaternionList(CL: TPSPascalCompiler);
   //TByteList(CL: TPSPascalCompiler);
   //TSingleList(CL: TPSPascalCompiler);
   //TIntegerList(CL: TPSPascalCompiler);
   //TTexPointList(CL: TPSPascalCompiler);
   //TVectorList(CL: TPSPascalCompiler);
   //TAffineVectorList(CL: TPSPascalCompiler);
   //TBaseVectorList(CL: TPSPascalCompiler);
   //TBaseList(CL: TPSPascalCompiler);
   //VectorLists(CL: TPSPascalCompiler); 
   //TXIntegerList
   //TJclSimpleLog  //jExecute 
  
   writeln('get current dir '+GetCurrentDir);
   //GetCurrentModule  
   //GetModuleFileName(hmod, szPath, MAX_PATH);
//HMODULE hmod = GetCurrentModule();
//TCHAR szPath[MAX_PATH + 1] = 0;          
//DWORD dwLen = GetModuleFileHName(hmod, szPath, MAX_PATH);    
  //GetModuleHandle               
   writeln(booleantostr(samepath(exepath, exepath)))
       
  verinfo:= GetOsVersionInfo2; //script dll
  writeln('OS Verinfo Major: '+inttostr(Verinfo.dwMajorVersion))
  writeln('OS Verinfo Minor: '+inttostr(Verinfo.dwMinorVersion))
  writeln('OS VerSizeinfo '+inttostr(Verinfo.dwOSVersionInfoSize))
  
  verinfo:= GetOsVersionInfo; //internal dll
  writeln('OS Verinfo Major: '+inttostr(Verinfo.dwMajorVersion))
  writeln('OS Verinfo Minor: '+inttostr(Verinfo.dwMinorVersion))
  writeln('OS VerSizeinfo '+inttostr(Verinfo.dwOSVersionInfoSize))
  
  verinfo:= GetOsVersionInfo3; //dll external
  writeln('OS Verinfo Major: '+inttostr(Verinfo.dwMajorVersion))
  writeln('OS Verinfo Minor: '+inttostr(Verinfo.dwMinorVersion))
  writeln('OS VerSizeinfo '+inttostr(Verinfo.dwOSVersionInfoSize))
  
  //Function IsDelphiProject( const FileName : string) : Boolean');
  writeln(booleantoStr(IsDelphiProject(exepath+'maxbox3.exe')));
  //FileBackup(const 
  aProcessHandle:= OpenProcess2(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ,
                               false, GetCurrentProcessID);
  writeln('Process Handle direct: '+inttostr(aProcessHandle));
  aProcessHandle:= OpenProcess2($0400 or $0010, false, GetCurrentProcessID);
  writeln('Process Handle direct: '+inttostr(aProcessHandle));
  
  writeln(sha1(exepath+'maxbox3_9.exe'));
  writeln(IdSHA1Hash(exepath+'maxbox3_9.exe'));
  
  filestr:= loadfileasstring(exepath+'maxbox3_9.exe');
  writeln(synsha1(filestr));
  
  
  writeln('GetSerialPortNames: '+GetSerialPortNames);
  
  //REG_OPTION_NON_VOLATILE
   //'Function TraceRouteHost( const Host : string) : string');
  //192.168.1.40
   // writeln('TraceRouteHost: '+TraceRouteHost('192.168.25.1'));
    writeln('TraceRouteHost: '+TraceRouteHost(gethostIP));
    
  writeln('Function GetDNS : '+GetDNS);
 //CL.AddDelphiFunction('Function GetIEProxy( protocol : string) : TProxySetting');
 writeln('Function GetLocalIPs  : '+GetLocalIPs);
 writeln('Function GetLocalIPs2 : '+GetLocalIPs2);
 // CL.AddDelphiFunction('Function ToSysLog( const SyslogServer : string; Facil : Byte; Sever : TSyslogSeverity; const Content : string) : Boolean');
  //ToSysLog( const SyslogServer : string; Facil : Byte; Sever : TSyslogSeverity; const Content : string) : Boolean');
  
//   CL.AddConstantN('MaxMimeType','LongInt').SetInt( 25);
// CL.AddDelphiFunction('Function GenerateBoundary : string');

   //087636B7_361422CC_Synapse_boundary

   writeln(GenerateBoundary); 
   //wincheck32
   win32check(hinstance <> 0);
   // getwindow
   //hhook
    //SetWindowsHook
    //DefHookProc
    
    
    
End. 

087636B7_361422CC_Synapse_boundary


//DOC
Small set for arduino and android unit testing 

http://glscene.sourceforge.net/wikka/HomePage

unit Unit1;

interface

pascal delphi 

uses Windows,
     Messages,
     SysUtils,
     Variants,
     Classes,
     Graphics,
     Controls,
     Forms,
     Dialogs,
     Contnrs,
     StdCtrls,
     xmldom,
     XMLIntf,
     msxmldom,
     XMLDoc,
     AlFcnString,
     AlXmlDoc,
     ExtCtrls,
     OleCtrls,
     SHDocVw,
     ComObj,
     ALFcnFile,
     ALStringList;

{------------------------------------}
Const WM_XmlFullyLoaded = WM_user + 1;

type

  PPROCESS_MEMORY_COUNTERS = ^PROCESS_MEMORY_COUNTERS;
  PROCESS_MEMORY_COUNTERS = record
    cb : DWORD;
    PageFaultCount : DWORD;
    PeakWorkingSetSize : DWORD;
    WorkingSetSize : DWORD; //Task managers MemUsage number
    QuotaPeakPagedPoolUsage : DWORD;
    QuotaPagedPoolUsage : DWORD;
    QuotaPeakNonPagedPoolUsage : DWORD;
    QuotaNonPagedPoolUsage : DWORD;
    PagefileUsage : DWORD; //TaskMan's VM Size number
    PeakPagefileUsage : DWORD;
  end;
  TProcessMemoryCounters = PROCESS_MEMORY_COUNTERS;

  TForm1 = class(TForm)
    ButtonLoadXmlWithALXmlDocument: TButton;
    ButtonLoadXmlWithXmlDocument: TButton;
    MemoLoadXmlWithALXmlDocument: TMemo;
    MemoLoadXmlWithXmlDocument: TMemo;
    MainOpenDialog: TOpenDialog;
    ButtonGenerate100000NodeWithALXmlDocument: TButton;
    MemoGenerate100000NodeWithALXmlDocument: TMemo;
    MemoGenerate100000NodeWithXmlDocument: TMemo;
    ButtonGenerate100000NodeWithXmlDocument: TButton;
    ButtonParseXMLWithALXmlDocumentInSaxMode: TButton;
    MemoParseXmlWithALXmlDocumentInSaxMode: TMemo;
    Panel1: TPanel;
    Label8: TLabel;
    Label12: TLabel;
    Panel2: TPanel;
    PanelWebBrowser: TPanel;
    procedure ButtonLoadXmlWithALXmlDocumentClick(Sender: TObject);
    procedure ButtonLoadXmlWithXmlDocumentClick(Sender: TObject);
    procedure ButtonGenerate100000NodeWithALXmlDocumentClick(Sender: TObject);
    procedure ButtonGenerate100000NodeWithXmlDocumentClick(Sender: TObject);
    procedure ButtonParseXMLWithALXmlDocumentInSaxModeClick(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure FormCreate(Sender: TObject);
  private
    FnodeCount: Integer;
    Function scrollAllNode(aNode: iXmlNode): Integer; overload;
    Function scrollAllNode(aNode: TalXmlNode): Integer; overload;
  public
    { Public declarations }
  end;

function GetProcessMemoryInfo(Process : THandle; var MemoryCounters : TProcessMemoryCounters; cb : DWORD) : BOOL; stdcall;
function ProcessMemoryUsage(ProcessID : DWORD): DWORD;

var
  Form1: TForm1;

implementation

//{$R *.dfm}

{**************************************************}
function GetProcessMemoryInfo; external 'psapi.dll';

{****************************************************}
function ProcessMemoryUsage(ProcessID : DWORD): DWORD;
var ProcessHandle : THandle;
    MemCounters   : TProcessMemoryCounters;
begin
  Result := 0;
  ProcessHandle := OpenProcess(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ,
                               false,
                               ProcessID);
  try
    if GetProcessMemoryInfo(ProcessHandle,
                            MemCounters,
                            sizeof(MemCounters))
    then Result := MemCounters.WorkingSetSize;
  finally
    CloseHandle(ProcessHandle);
  end;
end;

{****************************************************************}
Function CreateEmptyXMLDocument(Rootname:AnsiString):IXMLDocument;
Var aXmlDoc: TXMLDocument;
begin
  aXmlDoc := TXMLDocument.Create(nil);
  Result := aXmlDoc;
  with result do begin
    Options := [];
    ParseOptions := [];
    FileName := '';
  end;
End;

{******************************************************}
function TForm1.scrollAllNode(aNode: iXmlNode): Integer;
Var aStack: Tstack;
    i: integer;
begin
  Result := 0;
  aStack := Tstack.Create;
  try
      For i := 0 to aNode.ChildNodes.Count - 1 do
        aStack.Push(pointer(ANode.ChildNodes[i]));
      While astack.Count > 0 do begin
        inc(result);
        aNode := ixmlNode(astack.Pop);
        If assigned(ANode.ChildNodes) then
          For i := 0 to ANode.ChildNodes.Count - 1 do
            aStack.Push(pointer(ANode.ChildNodes[i]));

        If assigned(ANode.AttributeNodes) then
          For i := 0 to ANode.AttributeNodes.Count - 1 do
            aStack.Push(pointer(ANode.AttributeNodes[i]));
      end;
  finally
    aStack.Free;
  end;

end;

//############################################################################
// Archimedes Spiral App
//############################################################################

procedure SIRegister_TOvcIntlSup(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TObject', 'TOvcIntlSup') do
  with CL.AddClassN(CL.FindClass('TObject'),'TOvcIntlSup') do begin
    RegisterMethod('Constructor Create');
    Procedure Free');
    Function CurrentDateString( const Picture : string; Pack : Boolean) : string');
    Function CurrentDatePChar( Dest : PChar; Picture : PChar; Pack : Boolean) : PChar');
    Function CurrentTimeString( const Picture : string; Pack : Boolean) : string');
    Function CurrentTimePChar( Dest : PChar; Picture : PChar; Pack : Boolean) : PChar');
    Function DateToDateString(const Picture:string; Julian:TStDate;Pack : Boolean) : string');
    Function DateToDatePChar(Dest:PChar;Picture:PChar;Julian:TStDate;Pack:Boolean):PChar');
    Function DateTimeToDatePChar(Dest:PChar;Picture:PChar;DT:TDateTime;Pack:Bool): PChar');
    Function DateStringToDMY( const Picture, S : string; var Day, Month, Year : Integer; Epoch : Integer) : Boolean');
    Function DatePCharToDMY(Picture,S:PChar;var Day,Month,Year:Integer;Epoch:Integer):Bool');
    Function DateStringIsBlank( const Picture, S : string) : Boolean');
    Function DatePCharIsBlank( Picture, S : PChar) : Boolean');
    Function DateStringToDate( const Picture, S : string; Epoch : Integer) : TStDate');
    Function DatePCharToDate( Picture, S : PChar; Epoch : Integer) : TStDate');
    Function DayOfWeekToString( WeekDay : TDayType) : string');
    Function DayOfWeekToPChar( Dest : PChar; WeekDay : TDayType) : PChar');
    Function DMYtoDateString( const Picture : string; Day, Month, Year : Integer; Pack : Boolean; Epoch : Integer) : string');
    Function DMYtoDatePChar( Dest : PChar; Picture : PChar; Day, Month, Year : Integer; Pack : Boolean; Epoch : Integer) : PChar');
    Function InternationalCurrency( FormChar : Char; MaxDigits : Byte; Float, AddCommas, IsNumeric : Boolean) : string');
    Function InternationalCurrencyPChar( Dest : PChar; FormChar : Char; MaxDigits : Byte; Float, AddCommas, IsNumeric : Boolean) : PChar');
    Function InternationalDate( ForceCentury : Boolean) : string');
    Function InternationalDatePChar( Dest : PChar; ForceCentury : Boolean) : PChar');
    Function InternationalLongDate( ShortNames : Boolean; ExcludeDOW : Boolean) : string');
    Function InternationalLongDatePChar(Dest:PChar;ShortNames:Boolean; ExcludeDOW:Boolean):PChar');
    Function InternationalTime( ShowSeconds : Boolean) : string');
    Function InternationalTimePChar( Dest : PChar; ShowSeconds : Boolean) : PChar');
    Function MonthStringToMonth( const S : string; Width : Byte) : Byte');
    Function MonthPCharToMonth( S : PChar; Width : Byte) : Byte');
    Function MonthToString( Month : Integer) : string');
    Function MonthToPChar( Dest : PChar; Month : Integer) : PChar');
    Procedure ResetInternationalInfo');
    Function TimeStringToHMS(const Picture,S:string;var Hour,Minute,Second: Integer):Boolean');
    Function TimePCharToHMS( Picture, S : PChar; var Hour, Minute, Second : Integer):Boolean');
    Function TimeStringToTime( const Picture, S : string) : TStTime');
    Function TimePCharToTime( Picture, S : PChar) : TStTime');
    Function TimeToTimeString( const Picture : string; T : TStTime; Pack : Boolean) : string');
    Function TimeToTimePChar(Dest:PChar;Picture: PChar; T : TStTime; Pack : Boolean) : PChar');
    Function TimeToAmPmString( const Picture : string; T : TStTime; Pack : Boolean) : string');
    Function TimeToAmPmPChar(Dest: PChar; Picture:PChar; T: TStTime; Pack : Boolean) : PChar');
    RegisterProperty('AutoUpdate', 'Boolean', iptrw);
    RegisterProperty('CurrencyLtStr', 'string', iptrw);
    RegisterProperty('CurrencyRtStr', 'string', iptrw);
    RegisterProperty('DecimalChar', 'Char', iptrw);
    RegisterProperty('CommaChar', 'Char', iptrw);
    RegisterProperty('Country', 'string', iptr);
    RegisterProperty('CurrencyDigits', 'Byte', iptrw);
    RegisterProperty('ListChar', 'Char', iptrw);
    RegisterProperty('SlashChar', 'Char', iptrw);
    RegisterProperty('TrueChar', 'Char', iptrw);
    RegisterProperty('FalseChar', 'Char', iptrw);
    RegisterProperty('YesChar', 'Char', iptrw);
    RegisterProperty('NoChar', 'Char', iptrw);
    RegisterProperty('OnWinIniChange', 'TNotifyEvent', iptrw);
  end;
end;

initialization 
  MyIntObject:= TMyObject.Create; 
finalization 
  MyIntObject.Free; 

But how about the DLL is written in C++?

At the very end we call a C++ DLL from maXbox:
First of all, you have to translate the header-file (should be delivered with the DLL), which is like an interface-section in OP. Headers in c usually contain all sorts of definitions which are relevant outside the module. In our c++ example it looks like: 

/*FILE: income.h */ 
class CIncome 
{ 
  public: 
    virtual double __stdcall GetIncome( double aNetto ) = 0 ; 
    virtual void   __stdcall SetRate( int aPercent, int  aYear ) = 0 ; 
    virtual void   __stdcall FreeObject() = 0 ; 
} ;

Then you translate it to an Abstract Class in a unit of her own: 

//FILE: income.pas 
interface 
type 
CIncome = class 
   public 
   function GetIncome(const aNetto: double): double; 
                               virtual; stdcall; abstract; 
   procedure SetRate(const aPercent: Integer; aYear: integer); 
                               virtual; stdcall; abstract; 
   procedure FreeObject; virtual; stdcall; abstract; 
end;




----app_template_loaded_code----

10 vor 10 kannst Du entweder live am PC schauen
http://www.srf.ch/livestream/player/srf-1

oder anschliessend an die Sendung:
http://www.srf.ch/sendungen/10vor10


Short for Dynamic Link Library, a library of executable functions or data that can be used by a Windows application. Typically, a DLL provides one or more particular functions and a program accesses the functions by creating either a static or dynamic link to the DLL. A static link remains constant during program execution while a dynamic link is created by the program as needed. DLLs can also contain just data. DLL files usually end with the extension .dll,.exe., drv, or .fon.

A DLL can be used by several applications at the same time. Some DLLs are provided with the Windows operating system and available for any Windows application. Other DLLs are written for a particular application and are loaded with the application.


Disclaimer: The foregoing release may contain forward-looking statements that
can be identified by terminology such as 'seek', 'not pursue', 'not approvable',
'continue', 'believes', 'believe', 'will', 'remained open to exploring',
'would', 'could', or similar expressions, or by express or implied discussions
regarding Addex Therapeutics, formerly known as, Addex Pharmaceuticals, its
business, the potential approval of its products by regulatory authorities, or
regarding potential future revenues from such products. Such forward-looking
statements reflect the current views of Addex Therapeutics regarding future

events, future economic performance or prospects, and, by their very nature. 

----Simple Browser started----
----Simple Browser started----