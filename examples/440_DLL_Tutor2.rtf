{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue128;\red0\green0\blue128;\red0\green128\blue128;\red255\green0\blue0;\red255\green0\blue255;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Untitled}}
\deflang1033\pard\plain\f0\fs20 \cf0\b PROGRAM\b0  DLL_Tutor_2\cf1 ;
\par 
\par \cf2\i ///////////////////////////////////////////////////////////////////////////
\par //  #sign:Administrator: PC08: 08/02/2014 06:00:25 PM 
\par //  Purpose: how to call a dll function, still on progress with lots of experiments 
\par //  #path>ples\\E:\\maxbox3\\mXGit39988\\maxbox3\\examples\\                    
\par //  Lines of Code #locs:362
\par ///////////////////////////////////////////////////////////////////////////
\par 
\par \i0\cf0\b Const\b0  TEXTOUT \cf1 =\cf0  \cf3 'hi world of dll func in opcode '\cf1 ;
\par 
\par \cf0\i \{$DEFINE MSWINDOWS\}
\par 
\par \cf2 //############################################################################
\par // Archimedes DLL Architect Tutor Tour
\par //############################################################################
\par //TODO: Button with stop event, change color and save bitmap as png
\par \i0\cf0   \cf2\i //TODO: transfer the App to a dll stub function!
\par \i0\cf0   \cf2\i //\{ TODO : the following line looks like a bug... \}
\par 
\par \{type  
\par   PROCESS_MEMORY_COUNTERS = record
\par     cb : DWORD;
\par     PageFaultCount : DWORD;
\par     PeakWorkingSetSize : DWORD;
\par     WorkingSetSize : DWORD; //Task managers MemUsage number
\par     QuotaPeakPagedPoolUsage : DWORD;
\par     QuotaPagedPoolUsage : DWORD;
\par     QuotaPeakNonPagedPoolUsage : DWORD;
\par     QuotaNonPagedPoolUsage : DWORD;
\par     PagefileUsage : DWORD; //TaskMan's VM Size number
\par     PeakPagefileUsage : DWORD;
\par   end;
\par   TProcessMemoryCounters = PROCESS_MEMORY_COUNTERS;\}
\par \i0\cf0   \cf2\i \{ _OSVERSIONINFOA = record
\par     dwOSVersionInfoSize: DWORD;
\par     dwMajorVersion: DWORD;
\par     dwMinorVersion: DWORD;
\par     dwBuildNumber: DWORD;
\par     dwPlatformId: DWORD;
\par     szCSDVersion: array[0..127] of AnsiChar; \{ Maintenance AnsiString for PSS usage \}
\par \i0\cf0   \cf2\i \{end;
\par  //TIntegerList
\par  //var aos: TOSVersionInfo;
\par 
\par //  function  \{**************************************************\}
\par \i0\cf0  \b Function\b0  GetProcessMemoryInfo\cf1 (\cf0 Process\cf1 :\cf0  THandle\cf1 ;\cf0  \b var\b0  MemoryCounters\cf1 :\cf0  TProcessMemoryCounters\cf1 ;
\par \cf0                                     cb\cf1 :\cf0  DWORD\cf1 ):\cf0  BOOL\cf1 ;\cf0  \cf2\i //stdcall;; 
\par \i0\cf0      \b External\b0  \cf3 'GetProcessMemoryInfo@psapi.dll stdcall'\cf1 ;
\par \cf0      
\par  \b Function\b0  OpenProcess2\cf1 (\cf0 dwDesiredAccess\cf1 :\cf0 DWORD\cf1 ;\cf0  bInheritHandle\cf1 :\cf0 BOOL\cf1 ;\cf0  dwProcessId\cf1 :\cf0 DWORD\cf1 ):\cf0 THandle\cf1 ;
\par \cf0      \b External\b0   \cf3 'OpenProcess@kernel32.dll stdcall'\cf1 ;
\par 
\par \cf0  \b procedure\b0  GetVersionEx3\cf1 (\cf0\b out\b0  verinfo\cf1 :\cf0  TOSVersionInfo\cf1 );\cf0     \cf2\i //var verinfo: TOSVersionInfo
\par \i0\cf0      \b External\b0   \cf3 'GetVersionExA@kernel32.dll stdcall'\cf1 ;
\par 
\par \cf2\i \{TYPE <Type declarations>\}\i0\cf0  
\par   \b var\b0  FWait\cf1 ,\cf0  switch\cf1 :\cf0  Boolean\cf1 ;
\par \cf0       FValueA\cf1 ,\cf0  FValueB\cf1 :\cf0  Float\cf1 ;
\par \cf0       \cf2\i //asd: TDoubleArray;
\par \i0\cf0      
\par \cf2\i //<FUNCTION>
\par //<PROCEDURE> 
\par \{****************************************************\}
\par //function GetProcessMemoryInfo; external 'psapi.dll';
\par \{****************************************************\}
\par 
\par \i0\cf0\b function\b0  ProcessMemoryUsage\cf1 (\cf0 ProcessID \cf1 :\cf0  DWORD\cf1 ):\cf0  DWORD\cf1 ;
\par \cf0\b var\b0  ProcessHandle \cf1 :\cf0  THandle\cf1 ;
\par \cf0     MemCounters   \cf1 :\cf0  TProcessMemoryCounters\cf1 ;
\par \cf0\b begin
\par \b0   Result\cf1 :=\cf0  \cf4 0\cf1 ;
\par \cf0   \cf2\i //PROCESS_QUERY_INFORMATION Required to retrieve certain information about process, such as its token, exit code, and priority class   - 0x0400
\par \i0\cf0   \cf2\i //PROCESS_VM_READ Required to read memory in a process using ReadProcessMemory.
\par \i0\cf0   ProcessHandle\cf1 :=\cf0  OpenProcess2\cf1 (\cf0 PROCESS_QUERY_INFORMATION \b or\b0  PROCESS_VM_READ\cf1 ,
\par \cf0                                false\cf1 ,\cf0  ProcessID\cf1 );
\par \cf0   writeln\cf1 (\cf3 'Process Handle inside: '\cf1 +\cf0 inttostr\cf1 (\cf0 ProcessHandle\cf1 ));
\par \cf0   \b try
\par \b0     \b if\b0  GetProcessMemoryInfo\cf1 (\cf0 ProcessHandle\cf1 ,
\par \cf0                             MemCounters\cf1 ,\cf0  sizeof\cf1 (\cf0 MemCounters\cf1 ))
\par \cf0     \b then\b0  Result\cf1 :=\cf0  MemCounters\cf1 .\cf0 WorkingSetSize\cf1 ;
\par \cf0   \b finally
\par \b0     CloseHandle\cf1 (\cf0 ProcessHandle\cf1 );
\par \cf0   \b end\b0\cf1 ;
\par \cf0\b end\b0\cf1 ;
\par 
\par \cf0\b function\b0  ProcessPageUsage\cf1 (\cf0 ProcessID\cf1 :\cf0  DWORD\cf1 ):\cf0  DWORD\cf1 ;
\par \cf0\b var\b0  ProcessHandle \cf1 :\cf0  THandle\cf1 ;
\par \cf0     MemCounters   \cf1 :\cf0  TProcessMemoryCounters\cf1 ;
\par \cf0\b begin
\par \b0   Result\cf1 :=\cf0  \cf4 0\cf1 ;
\par \cf0   ProcessHandle\cf1 :=\cf0  OpenProcess2\cf1 (\cf0 PROCESS_QUERY_INFORMATION \b or\b0  PROCESS_VM_READ\cf1 ,
\par \cf0                                 false\cf1 ,\cf0  ProcessID\cf1 );
\par \cf0   \b try
\par \b0     \b if\b0  GetProcessMemoryInfo\cf1 (\cf0 ProcessHandle\cf1 ,\cf0  
\par                               MemCounters\cf1 ,\cf0  sizeof\cf1 (\cf0 MemCounters\cf1 ))
\par \cf0     \b then\b0  Result\cf1 :=\cf0  MemCounters\cf1 .\cf0 PagefileUsage\cf1 ;
\par \cf0   \b finally
\par \b0     CloseHandle\cf1 (\cf0 ProcessHandle\cf1 );
\par \cf0   \b end\b0\cf1 ;
\par \cf0\b end\b0\cf1 ;
\par 
\par \cf0\b function\b0  ProcessAllRec\cf1 (\cf0 ProcessID \cf1 :\cf0  DWORD\cf1 ):\cf0  TProcessMemoryCounters\cf1 ;
\par \cf0\b var\b0  ProcessHandle \cf1 :\cf0  THandle\cf1 ;
\par \cf0     MemCounters   \cf1 :\cf0  TProcessMemoryCounters\cf1 ;
\par \cf0\b begin
\par \b0   \cf2\i //Result:= NULL;
\par \i0\cf0   ProcessHandle\cf1 :=\cf0  OpenProcess2\cf1 (\cf0 PROCESS_QUERY_INFORMATION \b or\b0  PROCESS_VM_READ\cf1 ,
\par \cf0                                false\cf1 ,\cf0  ProcessID\cf1 );
\par \cf0   \b try
\par \b0     \b if\b0  GetProcessMemoryInfo\cf1 (\cf0 ProcessHandle\cf1 ,
\par \cf0                             MemCounters\cf1 ,\cf0  sizeof\cf1 (\cf0 MemCounters\cf1 ))
\par \cf0     \b then\b0  Result\cf1 :=\cf0  MemCounters\cf1 ;
\par \cf0   \b finally
\par \b0     CloseHandle\cf1 (\cf0 ProcessHandle\cf1 );
\par \cf0   \b end\b0\cf1 ;
\par \cf0\b end\b0\cf1 ;
\par 
\par \cf0\b Procedure\b0  OVCInternationalDemoClass\cf1 ;
\par \cf0\b begin
\par \b0  \b with\b0  TOvcIntlSup\cf1 .\cf0 Create \b do\b0  \b begin
\par \b0     \cf2\i //Function InternationalDate( ForceCentury : Boolean) : string');
\par \i0\cf0     writeln\cf1 (\cf3 'InternationalDate: '\cf1 +\cf0 InternationalDate\cf1 (\cf0 true\cf1 ));
\par \cf0     \cf2\i //Function InternationalDatePChar( Dest : PChar; ForceCentury : Boolean) : PChar');
\par \i0\cf0     writeln\cf1 (\cf3 'InternationalLongDate: '\cf1 +\cf0 InternationalLongDate\cf1 (\cf0 false\cf1 ,\cf0 false\cf1 ));
\par \cf0     \cf2\i //Function InternationalTime( ShowSeconds : Boolean) : string');
\par \i0\cf0     writeln\cf1 (\cf3 'InternationalTime: '\cf1 +\cf0 InternationalTime\cf1 (\cf0 false\cf1 ));
\par \cf0     \cf2\i //Function InternationalTimePChar( Dest : PChar; ShowSeconds : Boolean) : PChar');
\par \i0\cf0     \cf2\i //Function MonthStringToMonth( const S : string; Width : Byte) : Byte');
\par \i0\cf0     writeln\cf1 (\cf0 Country\cf1 )
\par \cf0     Free\cf1 ;
\par \cf0   \b end\b0\cf1 ;
\par \cf0   \cf2\i //TerminateProcess( hProcess : THandle; uExitCode : UINT) : BOOL');
\par \i0\cf0   \cf2\i //GetExitCodeProcess( hProcess : THandle; var lpExitCode : DWORD) : BOOL');
\par \i0\cf0  \cf2\i //FatalExit( ExitCode : Integer)');
\par \i0\cf0  \cf2\i //ExecuteAndWait(cmdLine : String; visibility : Word;
\par \i0\cf0    \cf2\i //                     timeout : Cardinal = MaxInt;
\par \i0\cf0      \cf2\i //                   killAppOnTimeOut : Boolean = True) : Integer;
\par \i0\cf0   \cf2\i //GetTemporaryFilesPath : String;
\par \i0\cf0  \cf2\i //GetTemporaryFileName : String; //Zero
\par \i0\cf0  \cf2\i //TPanelStyle //TFontLook
\par \i0\cf0  \cf2\i //FindFileInPaths(const fileName, paths : String) : String;  //MakeForm
\par \i0\cf0  \cf2\i //PathsToString(const paths : TStrings) : String;
\par \i0\cf0  \cf2\i //StringToPaths(const pathsString : String; paths : TStrings);
\par \i0\cf0  \cf2\i //MacroExpandPath(const aPath : String) : String;
\par \i0\cf0  \cf2\i //TOnGetItemEvent //TCacheRecord
\par \i0\cf0    \cf2\i //tMessagefunc
\par \i0\cf0    \cf2\i //EFilerException(CL: TPSPascalCompiler);
\par //EInvalidFileSignature(CL: TPSPascalCompiler);
\par //TTextWriter(CL: TPSPascalCompiler);
\par //TTextReader(CL: TPSPascalCompiler);
\par //TBinaryWriter(CL: TPSPascalCompiler);
\par //TBinaryReader(CL: TPSPascalCompiler);
\par //TPersistentObjectList(CL: TPSPascalCompiler);
\par //TPersistentObject(CL: TPSPascalCompiler);
\par //IPersistentObject(CL: TPSPascalCompiler);
\par //TVirtualWriter(CL: TPSPascalCompiler);
\par //TVirtualReader(CL: TPSPascalCompiler);
\par //PersistentClasses(CL: TPSPascalCompiler);
\par \i0\cf0\b end\b0\cf1 ;\cf0     
\par 
\par 
\par \b function\b0  SplitToken\cf1 (\cf0\b const\b0  Text\cf1 :\cf0  \b string\b0\cf1 ;\cf0  SplitChar\cf1 :\cf0  Char\cf1 ;
\par \cf0                           \b var\b0  First\cf1 ,\cf0  Last\cf1 :\cf0  \b string\b0\cf1 ):\cf0  Boolean\cf1 ;
\par \cf0\b var\b0   SplitPos\cf1 :\cf0  Integer\cf1 ;
\par \cf0\b begin
\par \b0   Result\cf1 :=\cf0  False\cf1 ;
\par \cf0   SplitPos\cf1 :=\cf0  Pos\cf1 (\cf0 SplitChar\cf1 ,\cf0  Text\cf1 );
\par \cf0   \b if\b0  SplitPos \cf1 =\cf0  \cf4 0\cf0  \b then\b0  Exit\cf1 ;
\par \cf0   First\cf1 :=\cf0  Trim\cf1 (\cf0 Copy\cf1 (\cf0 Text\cf1 ,\cf0  \cf4 1\cf1 ,\cf0  SplitPos \cf1 -\cf4 1\cf1 ));
\par \cf0   Last\cf1 :=\cf0  Trim\cf1 (\cf0 Copy\cf1 (\cf0 Text\cf1 ,\cf0  SplitPos \cf1 +\cf4 1\cf1 ,\cf0  Length\cf1 (\cf0 Text\cf1 )\cf0  \cf1 -\cf0 SplitPos\cf1 ));
\par \cf0   Result\cf1 :=\cf0  \cf1 (\cf0 First \cf1 <>\cf3 ''\cf1 )\cf0  \b and\b0  \cf1 (\cf0 Last \cf1 <>\cf3 ''\cf1 );
\par \cf0\b end\b0\cf1 ;
\par 
\par 
\par \cf0\b function\b0  TForm1_scrollAllNode\cf1 (\cf0 aNode\cf1 :\cf0  TalXmlNode\cf1 ):\cf0  Integer\cf1 ;
\par \cf0\b Var\b0  aStack\cf1 :\cf0  Tstack\cf1 ;
\par \cf0     i\cf1 :\cf0  integer\cf1 ;
\par \cf0\b begin
\par \b0   Result \cf1 :=\cf0  \cf4 0\cf1 ;
\par \cf0   aStack \cf1 :=\cf0  Tstack\cf1 .\cf0 Create\cf1 ;
\par \cf0   \b try
\par \b0      \b For\b0  i \cf1 :=\cf0  \cf4 0\cf0  \b to\b0  aNode\cf1 .\cf0 ChildNodes\cf1 .\cf0 Count \cf1 -\cf0  \cf4 1\cf0  \b do
\par \b0         aStack\cf1 .\cf0 Push\cf1 ((\cf0 ANode\cf1 .\cf0 ChildNodes\cf1 [\cf0 i\cf1 ]));
\par \cf0          \b While\b0  astack\cf1 .\cf0 Count \cf1 >\cf0  \cf4 0\cf0  \b do\b0  \b begin
\par \b0         inc\cf1 (\cf0 result\cf1 );
\par \cf0         aNode \cf1 :=\cf0  TalxmlNode\cf1 (\cf0 astack\cf1 .\cf0 Pop\cf1 );
\par \cf0         \b If\b0  assigned\cf1 (\cf0 ANode\cf1 .\cf0 ChildNodes\cf1 )\cf0  \b then
\par \b0           \b For\b0  i \cf1 :=\cf0  \cf4 0\cf0  \b to\b0  ANode\cf1 .\cf0 ChildNodes\cf1 .\cf0 Count \cf1 -\cf0  \cf4 1\cf0  \b do
\par \b0             aStack\cf1 .\cf0 Push\cf1 ((\cf0 ANode\cf1 .\cf0 ChildNodes\cf1 [\cf0 i\cf1 ]));
\par \cf0            \b If\b0  assigned\cf1 (\cf0 ANode\cf1 .\cf0 AttributeNodes\cf1 )\cf0  \b then
\par \b0           \b For\b0  i \cf1 :=\cf0  \cf4 0\cf0  \b to\b0  ANode\cf1 .\cf0 attributeNodes\cf1 .\cf0 Count \cf1 -\cf0  \cf4 1\cf0  \b do
\par \b0             aStack\cf1 .\cf0 Push\cf1 ((\cf0 ANode\cf1 .\cf0 AttributeNodes\cf1 [\cf0 i\cf1 ]));
\par \cf0       \b end\b0\cf1 ;
\par \cf0   \b finally
\par \b0     aStack\cf1 .\cf0 Free\cf1 ;
\par \cf0   \b end\b0\cf1 ;
\par \cf0\b end\b0\cf1 ;
\par 
\par 
\par \cf0\b function\b0  CheckPSAPILoaded\cf1 :\cf0  Boolean\cf1 ;
\par \cf0\b var\b0  hPSAPI\cf1 :\cf0  THandle\cf1 ;
\par \cf0\b begin
\par \b0   \b if\b0  hPSAPI \cf1 =\cf0  \cf4 0\cf0  \b then\b0  \b begin
\par \b0\i \{$IFDEF MSWINDOWS\}
\par \i0     hPSAPI\cf1 :=\cf0  LoadLibrary\cf1 (\cf3 'PSAPI.dll'\cf1 );
\par \cf0     \cf2\i //writeln('debug DLL handle '+inttostr(hPSAPI));
\par \i0\cf0     \b if\b0  hPSAPI \cf1 >\cf0  \cf4 32\cf0  \b then\b0  result\cf1 :=\cf0  true\cf1 ;
\par \cf0     \b if\b0  hPSAPI \cf1 <\cf0  \cf4 32\cf0  \b then\b0  \b begin
\par \b0       hPSAPI\cf1 :=\cf0  \cf4 0\cf1 ;
\par \cf0       Result\cf1 :=\cf0  False\cf1 ;
\par \cf0       Exit\cf1 ;
\par \cf0     \b end\b0\cf1 ;
\par \cf0  \i \{$ENDIF\}\i0    
\par   \b end\b0\cf1 ;\cf0  
\par \b end\b0\cf1 ;
\par 
\par \cf0\b function\b0  IntToStrZeroPad\cf1 (\cf0 Value\cf1 ,\cf0  Count\cf1 :\cf0  Integer\cf1 ):\cf0  AnsiString\cf1 ;
\par \cf0\b begin
\par \b0   Result \cf1 :=\cf0  IntToStr\cf1 (\cf0 Value\cf1 );
\par \cf0   \b if\b0  Length\cf1 (\cf0 Result\cf1 )\cf0  \cf1 <\cf0  Count \b then
\par \b0     Result \cf1 :=\cf0  StrFillChar\cf1 (\cf3 '0'\cf1 ,\cf0  Count \cf1 -\cf0  Length\cf1 (\cf0 Result\cf1 ))\cf0  \cf1 +\cf0  Result\cf1 ;
\par \cf0\b end\b0\cf1 ;
\par 
\par \cf0\b function\b0  JclGUIDToString\cf1 (\cf0\b const\b0  GUID\cf1 :\cf0  TGUID\cf1 ):\cf0  \b string\b0\cf1 ;
\par \cf0\b begin
\par \b0   \i \{$IFDEf CLR\}
\par \i0   Result \cf1 :=\cf0  GUID\cf1 .\cf0 ToString\cf1 ();
\par \cf0   \i \{$ELSE\}
\par \i0   Result \cf1 :=\cf0  Format\cf1 (\cf3 '\{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x\}'\cf1 ,
\par \cf0     \cf1 [\cf0 GUID\cf1 .\cf0 D1\cf1 ,\cf0  GUID\cf1 .\cf0 D2\cf1 ,\cf0  GUID\cf1 .\cf0 D3\cf1 ,\cf0  GUID\cf1 .\cf0 D4\cf1 [\cf4 0\cf1 ],\cf0  GUID\cf1 .\cf0 D4\cf1 [\cf4 1\cf1 ],\cf0  GUID\cf1 .\cf0 D4\cf1 [\cf4 2\cf1 ],
\par \cf0      GUID\cf1 .\cf0 D4\cf1 [\cf4 3\cf1 ],\cf0  GUID\cf1 .\cf0 D4\cf1 [\cf4 4\cf1 ],\cf0  GUID\cf1 .\cf0 D4\cf1 [\cf4 5\cf1 ],\cf0  GUID\cf1 .\cf0 D4\cf1 [\cf4 6\cf1 ],\cf0  GUID\cf1 .\cf0 D4\cf1 [\cf4 7\cf1 ]]);
\par \cf0   \i \{$ENDIF CLR\}
\par \i0\b end\b0\cf1 ;
\par 
\par \cf2\i \{BOOL GetVersionEx( 
\par   LPOSVERSIONINFO lpVersionInformation );\}
\par 
\par \i0\cf0\b function\b0  GetOsVersionInfo2\cf1 :\cf0  TOSVersionInfo\cf1 ;\cf0  
\par \b var
\par \b0   verInfo\cf1 :\cf0  TOSVersionInfo\cf1 ;
\par \cf0\b begin
\par \b0   verinfo\cf1 .\cf0 dwOSVersionInfoSize\cf1 :=\cf0  sizeof\cf1 (\cf0 verinfo\cf1 );
\par \cf0   GetVersionEx\cf1 (\cf0 Verinfo\cf1 );
\par \cf0   result\cf1 :=\cf0  Verinfo\cf1 ;
\par \cf0\b end\b0\cf1 ;\cf0   
\par 
\par \b function\b0  GetOsVersionInfo3\cf1 :\cf0  TOSVersionInfo\cf1 ;\cf0  
\par \b var
\par \b0   verInfo\cf1 :\cf0  TOSVersionInfo\cf1 ;
\par \cf0\b begin
\par \b0   verinfo\cf1 .\cf0 dwOSVersionInfoSize\cf1 :=\cf0  sizeof\cf1 (\cf0 verinfo\cf1 );
\par \cf0   GetVersionEx3\cf1 (\cf0 Verinfo\cf1 );
\par \cf0   result\cf1 :=\cf0  Verinfo\cf1 ;
\par \cf0\b end\b0\cf1 ;\cf0  
\par 
\par \b function\b0  IsWindowsVista\cf1 :\cf0  boolean\cf1 ;
\par \cf0\b var
\par \b0   verInfo\cf1 :\cf0  TOSVersionInfo\cf1 ;
\par \cf0\b begin
\par \b0   verinfo\cf1 .\cf0 dwOSVersionInfoSize\cf1 :=\cf0  Sizeof\cf1 (\cf0 verinfo\cf1 );
\par \cf0   GetVersionEx\cf1 (\cf0 Verinfo\cf1 );
\par \cf0   result\cf1 :=\cf0  Verinfo\cf1 .\cf0 dwMajorVersion \cf1 >=\cf4 6\cf1 ;
\par \cf0\b end\b0\cf1 ;
\par \cf0  
\par 
\par \b var\b0   verInfo\cf1 :\cf0  TOSVersionInfo\cf1 ;
\par \cf0      aProcessHandle \cf1 :\cf0  THandle\cf1 ;
\par 
\par \cf0\b Begin\b0   \cf2\i //Main
\par //<Executable statements> //TOutlookExport_Spy;
\par \i0\cf0   Writeln\cf1 (\cf3 ''\cf1 );
\par \cf0   \cf2\i //Writeln('Start Command of DLL: '+CheckIEStartCommand);  
\par //<Definitions>  
\par \i0\cf0    \cf2\i //ares:= TResolver.create;
\par \i0\cf0  \cf2\i \{ with TResolver.create do begin
\par    //writeln(inttostr(GetHostByName(gethostname)));
\par     Free;   end;  \}
\par \i0\cf0     \cf2\i \{repeat 
\par      TApplication_PaintView(aform.canvas);
\par      switch:= NOT switch;
\par      Sleep(20);
\par    until isKeyPressed or FWait;\}
\par \i0\cf0     \cf2\i \{with TledForm.create(self) do begin
\par     showmodal; free; end;\}\i0\cf0  
\par  \cf2\i // function GetMacAddresses(const Machine: string; const Addresses: TStrings):Integer;
\par \i0\cf0    OVCInternationalDemoClass\cf1 ;
\par \cf0   
\par  \cf2\i //GetProcessMemoryInfo(Process 
\par \i0\cf0      writeln\cf1 (\cf3 'workset mem from dll '\cf1 +\cf0 inttostr\cf1 (\cf0 ProcessMemoryUsage\cf1 (\cf0 GetCurrentProcessID\cf1 )));
\par \cf0      writeln\cf1 (\cf3 'workset page from dll '\cf1 +\cf0 inttostr\cf1 (\cf0 ProcessPageUsage\cf1 (\cf0 GetCurrentProcessID\cf1 )));
\par \cf0      writeln\cf1 (\cf3 'workset memproc test in bytes '
\par \cf0                  \cf1 +\cf0 inttostr\cf1 (\cf0 ProcessAllRec\cf1 (\cf0 GetCurrentProcessID\cf1 ).\cf0 workingsetsize\cf1 ));
\par \cf0      writeln\cf1 (\cf3 'proc peak max. workingset in K '
\par \cf0               \cf1 +\cf0 inttostr\cf1 (\cf0 ProcessAllRec\cf1 (\cf0 GetCurrentProcessID\cf1 ).\cf0 PeakWorkingSetSize \b div\b0  \cf4 1024\cf1 ));
\par \cf0      writeln\cf1 (\cf3 'proc peak max. paged use in K '
\par \cf0               \cf1 +\cf0 inttostr\cf1 (\cf0 ProcessAllRec\cf1 (\cf0 GetCurrentProcessID\cf1 ).\cf0 QuotaPeakPagedPoolUsage\cf1 ));
\par \cf0      writeln\cf1 (\cf3 'proc page peak file usage K '
\par \cf0               \cf1 +\cf0 inttostr\cf1 (\cf0 getProcMemInfo\cf1 (\cf0 GetCurrentProcessID\cf1 ).\cf0 PeakPagefileUsage \b div\b0  \cf4 1024\cf1 ));
\par \cf0      \b if\b0  CheckPSAPILoaded \b then
\par \b0         writeln\cf1 (\cf3 '!workset! mem from dll in K '
\par \cf0               \cf1 +\cf0 inttostr\cf1 (\cf0 getProcMemInfo\cf1 (\cf0 GetCurrentProcessID\cf1 ).\cf0 Workingsetsize \b div\b0  \cf4 1024\cf1 ));
\par \cf0  
\par     \cf2\i // SplitImages(self);
\par \i0\cf0      \cf2\i //deletefiles(PICPATH,'*.bmp');
\par \i0\cf0       \cf2\i //GetCurrentHwProfile( var lpHwProfileInfo : THWProfileInfo) : BOOL');
\par \i0\cf0         \cf2\i //SetPriorityClass  //GetPriorityClass
\par \i0\cf0      \cf2\i //OpenClipboard(   //booleantostr(false);
\par \i0\cf0      \cf2\i //JclGUIDToString  //TJclNumericFormat 
\par \i0\cf0           \cf2\i //function IsClass(Address: Pointer): Boolean;
\par \i0\cf0           \cf2\i //function IsObject(Address: Pointer): Boolean;
\par \i0\cf0            \cf2\i //IsClass(Address: Pointer): Boolean;
\par \i0\cf0            \cf2\i //IsObject(Address: Pointer): Boolean;
\par \i0\cf0            \cf2\i //ReadKey  //IntToStrZeroPad //  StrFillChar //EndDialog( 
\par \i0\cf0          \cf2\i //GetDlgItem(  //SetDlgItemInt( //dialogbox
\par \i0\cf0          \cf2\i //TQuaternionList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //TByteList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //TSingleList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //TIntegerList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //TTexPointList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //TVectorList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //TAffineVectorList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //TBaseVectorList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //TBaseList(CL: TPSPascalCompiler);
\par \i0\cf0    \cf2\i //VectorLists(CL: TPSPascalCompiler); 
\par \i0\cf0    \cf2\i //TXIntegerList
\par \i0\cf0    \cf2\i //TJclSimpleLog  //jExecute 
\par \i0\cf0   
\par    writeln\cf1 (\cf3 'get current dir '\cf1 +\cf0 GetCurrentDir\cf1 );
\par \cf0    \cf2\i //GetCurrentModule  
\par \i0\cf0    \cf2\i //GetModuleFileName(hmod, szPath, MAX_PATH);
\par //HMODULE hmod = GetCurrentModule();
\par //TCHAR szPath[MAX_PATH + 1] = 0;          
\par //DWORD dwLen = GetModuleFileHName(hmod, szPath, MAX_PATH);    
\par \i0\cf0   \cf2\i //GetModuleHandle               
\par \i0\cf0    writeln\cf1 (\cf0 booleantostr\cf1 (\cf0 samepath\cf1 (\cf0 exepath\cf1 ,\cf0  exepath\cf1 )))
\par \cf0        
\par   verinfo\cf1 :=\cf0  GetOsVersionInfo2\cf1 ;\cf0  \cf2\i //script dll
\par \i0\cf0   writeln\cf1 (\cf3 'OS Verinfo Major: '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwMajorVersion\cf1 ))
\par \cf0   writeln\cf1 (\cf3 'OS Verinfo Minor: '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwMinorVersion\cf1 ))
\par \cf0   writeln\cf1 (\cf3 'OS VerSizeinfo '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwOSVersionInfoSize\cf1 ))
\par \cf0   
\par   verinfo\cf1 :=\cf0  GetOsVersionInfo\cf1 ;\cf0  \cf2\i //internal dll
\par \i0\cf0   writeln\cf1 (\cf3 'OS Verinfo Major: '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwMajorVersion\cf1 ))
\par \cf0   writeln\cf1 (\cf3 'OS Verinfo Minor: '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwMinorVersion\cf1 ))
\par \cf0   writeln\cf1 (\cf3 'OS VerSizeinfo '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwOSVersionInfoSize\cf1 ))
\par \cf0   
\par   verinfo\cf1 :=\cf0  GetOsVersionInfo3\cf1 ;\cf0  \cf2\i //dll external
\par \i0\cf0   writeln\cf1 (\cf3 'OS Verinfo Major: '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwMajorVersion\cf1 ))
\par \cf0   writeln\cf1 (\cf3 'OS Verinfo Minor: '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwMinorVersion\cf1 ))
\par \cf0   writeln\cf1 (\cf3 'OS VerSizeinfo '\cf1 +\cf0 inttostr\cf1 (\cf0 Verinfo\cf1 .\cf0 dwOSVersionInfoSize\cf1 ))
\par \cf0   
\par   \cf2\i //Function IsDelphiProject( const FileName : string) : Boolean');
\par \i0\cf0   writeln\cf1 (\cf0 booleantoStr\cf1 (\cf0 IsDelphiProject\cf1 (\cf0 exepath\cf1 +\cf3 'maxbox3.exe'\cf1 )));
\par \cf0   \cf2\i //FileBackup(const 
\par \i0\cf0   aProcessHandle\cf1 :=\cf0  OpenProcess2\cf1 (\cf0 PROCESS_QUERY_INFORMATION \b or\b0  PROCESS_VM_READ\cf1 ,
\par \cf0                                false\cf1 ,\cf0  GetCurrentProcessID\cf1 );
\par \cf0   writeln\cf1 (\cf3 'Process Handle direct: '\cf1 +\cf0 inttostr\cf1 (\cf0 aProcessHandle\cf1 ));
\par \cf0   aProcessHandle\cf1 :=\cf0  OpenProcess2\cf1 (\cf5 $0400\cf0  \b or\b0  \cf5 $0010\cf1 ,\cf0  false\cf1 ,\cf0  GetCurrentProcessID\cf1 );
\par \cf0   writeln\cf1 (\cf3 'Process Handle direct: '\cf1 +\cf0 inttostr\cf1 (\cf0 aProcessHandle\cf1 ));
\par \cf0  
\par \b End\b0\cf1 .\cf0  
\par 
\par \cf2\i //DOC
\par \i0\cf0 Small \b set\b0  \b for\b0  \b arduino\b0  \b and\b0  \b android\b0  \b unit\b0  testing 
\par 
\par http\cf1 :\cf2\i //glscene.sourceforge.net/wikka/HomePage
\par 
\par \i0\cf0\b unit\b0  Unit1\cf1 ;
\par 
\par \cf0\b interface
\par 
\par pascal\b0  delphi 
\par 
\par \b uses\b0  Windows\cf1 ,
\par \cf0      Messages\cf1 ,
\par \cf0      SysUtils\cf1 ,
\par \cf0      Variants\cf1 ,
\par \cf0      Classes\cf1 ,
\par \cf0      Graphics\cf1 ,
\par \cf0      Controls\cf1 ,
\par \cf0      Forms\cf1 ,
\par \cf0      Dialogs\cf1 ,
\par \cf0      Contnrs\cf1 ,
\par \cf0      StdCtrls\cf1 ,
\par \cf0      xmldom\cf1 ,
\par \cf0      XMLIntf\cf1 ,
\par \cf0      msxmldom\cf1 ,
\par \cf0      XMLDoc\cf1 ,
\par \cf0      AlFcnString\cf1 ,
\par \cf0      AlXmlDoc\cf1 ,
\par \cf0      ExtCtrls\cf1 ,
\par \cf0      OleCtrls\cf1 ,
\par \cf0      SHDocVw\cf1 ,
\par \cf0      ComObj\cf1 ,
\par \cf0      ALFcnFile\cf1 ,
\par \cf0      ALStringList\cf1 ;
\par 
\par \cf2\i \{------------------------------------\}
\par \i0\cf0\b Const\b0  WM_XmlFullyLoaded \cf1 =\cf0  WM_user \cf1 +\cf0  \cf4 1\cf1 ;
\par 
\par \cf0\b type
\par 
\par \b0   PPROCESS_MEMORY_COUNTERS \cf1 =\cf0  \cf1 ^\cf0 PROCESS_MEMORY_COUNTERS\cf1 ;
\par \cf0   PROCESS_MEMORY_COUNTERS \cf1 =\cf0  \b record
\par \b0     cb \cf1 :\cf0  DWORD\cf1 ;
\par \cf0     PageFaultCount \cf1 :\cf0  DWORD\cf1 ;
\par \cf0     PeakWorkingSetSize \cf1 :\cf0  DWORD\cf1 ;
\par \cf0     WorkingSetSize \cf1 :\cf0  DWORD\cf1 ;\cf0  \cf2\i //Task managers MemUsage number
\par \i0\cf0     QuotaPeakPagedPoolUsage \cf1 :\cf0  DWORD\cf1 ;
\par \cf0     QuotaPagedPoolUsage \cf1 :\cf0  DWORD\cf1 ;
\par \cf0     QuotaPeakNonPagedPoolUsage \cf1 :\cf0  DWORD\cf1 ;
\par \cf0     QuotaNonPagedPoolUsage \cf1 :\cf0  DWORD\cf1 ;
\par \cf0     PagefileUsage \cf1 :\cf0  DWORD\cf1 ;\cf0  \cf2\i //TaskMan's VM Size number
\par \i0\cf0     PeakPagefileUsage \cf1 :\cf0  DWORD\cf1 ;
\par \cf0   \b end\b0\cf1 ;
\par \cf0   TProcessMemoryCounters \cf1 =\cf0  PROCESS_MEMORY_COUNTERS\cf1 ;
\par 
\par \cf0   TForm1 \cf1 =\cf0  \b class\b0\cf1 (\cf0 TForm\cf1 )
\par \cf0     ButtonLoadXmlWithALXmlDocument\cf1 :\cf0  TButton\cf1 ;
\par \cf0     ButtonLoadXmlWithXmlDocument\cf1 :\cf0  TButton\cf1 ;
\par \cf0     MemoLoadXmlWithALXmlDocument\cf1 :\cf0  TMemo\cf1 ;
\par \cf0     MemoLoadXmlWithXmlDocument\cf1 :\cf0  TMemo\cf1 ;
\par \cf0     MainOpenDialog\cf1 :\cf0  TOpenDialog\cf1 ;
\par \cf0     ButtonGenerate100000NodeWithALXmlDocument\cf1 :\cf0  TButton\cf1 ;
\par \cf0     MemoGenerate100000NodeWithALXmlDocument\cf1 :\cf0  TMemo\cf1 ;
\par \cf0     MemoGenerate100000NodeWithXmlDocument\cf1 :\cf0  TMemo\cf1 ;
\par \cf0     ButtonGenerate100000NodeWithXmlDocument\cf1 :\cf0  TButton\cf1 ;
\par \cf0     ButtonParseXMLWithALXmlDocumentInSaxMode\cf1 :\cf0  TButton\cf1 ;
\par \cf0     MemoParseXmlWithALXmlDocumentInSaxMode\cf1 :\cf0  TMemo\cf1 ;
\par \cf0     Panel1\cf1 :\cf0  TPanel\cf1 ;
\par \cf0     Label8\cf1 :\cf0  TLabel\cf1 ;
\par \cf0     Label12\cf1 :\cf0  TLabel\cf1 ;
\par \cf0     Panel2\cf1 :\cf0  TPanel\cf1 ;
\par \cf0     PanelWebBrowser\cf1 :\cf0  TPanel\cf1 ;
\par \cf0     \b procedure\b0  ButtonLoadXmlWithALXmlDocumentClick\cf1 (\cf0 Sender\cf1 :\cf0  TObject\cf1 );
\par \cf0     \b procedure\b0  ButtonLoadXmlWithXmlDocumentClick\cf1 (\cf0 Sender\cf1 :\cf0  TObject\cf1 );
\par \cf0     \b procedure\b0  ButtonGenerate100000NodeWithALXmlDocumentClick\cf1 (\cf0 Sender\cf1 :\cf0  TObject\cf1 );
\par \cf0     \b procedure\b0  ButtonGenerate100000NodeWithXmlDocumentClick\cf1 (\cf0 Sender\cf1 :\cf0  TObject\cf1 );
\par \cf0     \b procedure\b0  ButtonParseXMLWithALXmlDocumentInSaxModeClick\cf1 (\cf0 Sender\cf1 :\cf0  TObject\cf1 );
\par \cf0     \b procedure\b0  FormClose\cf1 (\cf0 Sender\cf1 :\cf0  TObject\cf1 ;\cf0  \b var\b0  Action\cf1 :\cf0  TCloseAction\cf1 );
\par \cf0     \b procedure\b0  FormCreate\cf1 (\cf0 Sender\cf1 :\cf0  TObject\cf1 );
\par \cf0   \b private
\par \b0     FnodeCount\cf1 :\cf0  Integer\cf1 ;
\par \cf0     \b Function\b0  scrollAllNode\cf1 (\cf0 aNode\cf1 :\cf0  iXmlNode\cf1 ):\cf0  Integer\cf1 ;\cf0  \b overload\b0\cf1 ;
\par \cf0     \b Function\b0  scrollAllNode\cf1 (\cf0 aNode\cf1 :\cf0  TalXmlNode\cf1 ):\cf0  Integer\cf1 ;\cf0  \b overload\b0\cf1 ;
\par \cf0   \b public
\par \b0     \cf2\i \{ Public declarations \}
\par \i0\cf0   \b end\b0\cf1 ;
\par 
\par \cf0\b function\b0  GetProcessMemoryInfo\cf1 (\cf0 Process \cf1 :\cf0  THandle\cf1 ;\cf0  \b var\b0  MemoryCounters \cf1 :\cf0  TProcessMemoryCounters\cf1 ;\cf0  cb \cf1 :\cf0  DWORD\cf1 )\cf0  \cf1 :\cf0  BOOL\cf1 ;\cf0  \b stdcall\b0\cf1 ;
\par \cf0\b function\b0  ProcessMemoryUsage\cf1 (\cf0 ProcessID \cf1 :\cf0  DWORD\cf1 ):\cf0  DWORD\cf1 ;
\par 
\par \cf0\b var
\par \b0   Form1\cf1 :\cf0  TForm1\cf1 ;
\par 
\par \cf0\b implementation
\par 
\par \b0\cf2\i //\{$R *.dfm\}
\par 
\par \{**************************************************\}
\par \i0\cf0\b function\b0  GetProcessMemoryInfo\cf1 ;\cf0  \b external\b0  \cf3 'psapi.dll'\cf1 ;
\par 
\par \cf2\i \{****************************************************\}
\par \i0\cf0\b function\b0  ProcessMemoryUsage\cf1 (\cf0 ProcessID \cf1 :\cf0  DWORD\cf1 ):\cf0  DWORD\cf1 ;
\par \cf0\b var\b0  ProcessHandle \cf1 :\cf0  THandle\cf1 ;
\par \cf0     MemCounters   \cf1 :\cf0  TProcessMemoryCounters\cf1 ;
\par \cf0\b begin
\par \b0   Result \cf1 :=\cf0  \cf4 0\cf1 ;
\par \cf0   ProcessHandle \cf1 :=\cf0  OpenProcess\cf1 (\cf0 PROCESS_QUERY_INFORMATION \b or\b0  PROCESS_VM_READ\cf1 ,
\par \cf0                                false\cf1 ,
\par \cf0                                ProcessID\cf1 );
\par \cf0   \b try
\par \b0     \b if\b0  GetProcessMemoryInfo\cf1 (\cf0 ProcessHandle\cf1 ,
\par \cf0                             MemCounters\cf1 ,
\par \cf0                             sizeof\cf1 (\cf0 MemCounters\cf1 ))
\par \cf0     \b then\b0  Result \cf1 :=\cf0  MemCounters\cf1 .\cf0 WorkingSetSize\cf1 ;
\par \cf0   \b finally
\par \b0     CloseHandle\cf1 (\cf0 ProcessHandle\cf1 );
\par \cf0   \b end\b0\cf1 ;
\par \cf0\b end\b0\cf1 ;
\par 
\par \cf2\i \{****************************************************************\}
\par \i0\cf0\b Function\b0  CreateEmptyXMLDocument\cf1 (\cf0 Rootname\cf1 :\cf0 AnsiString\cf1 ):\cf0 IXMLDocument\cf1 ;
\par \cf0\b Var\b0  aXmlDoc\cf1 :\cf0  TXMLDocument\cf1 ;
\par \cf0\b begin
\par \b0   aXmlDoc \cf1 :=\cf0  TXMLDocument\cf1 .\cf0 Create\cf1 (\cf0\b nil\b0\cf1 );
\par \cf0   Result \cf1 :=\cf0  aXmlDoc\cf1 ;
\par \cf0   \b with\b0  result \b do\b0  \b begin
\par \b0     Options \cf1 :=\cf0  \cf1 [];
\par \cf0     ParseOptions \cf1 :=\cf0  \cf1 [];
\par \cf0     FileName \cf1 :=\cf0  \cf3 ''\cf1 ;
\par \cf0   \b end\b0\cf1 ;
\par \cf0\b End\b0\cf1 ;
\par 
\par \cf2\i \{******************************************************\}
\par \i0\cf0\b function\b0  TForm1\cf1 .\cf0 scrollAllNode\cf1 (\cf0 aNode\cf1 :\cf0  iXmlNode\cf1 ):\cf0  Integer\cf1 ;
\par \cf0\b Var\b0  aStack\cf1 :\cf0  Tstack\cf1 ;
\par \cf0     i\cf1 :\cf0  integer\cf1 ;
\par \cf0\b begin
\par \b0   Result \cf1 :=\cf0  \cf4 0\cf1 ;
\par \cf0   aStack \cf1 :=\cf0  Tstack\cf1 .\cf0 Create\cf1 ;
\par \cf0   \b try
\par \b0       \b For\b0  i \cf1 :=\cf0  \cf4 0\cf0  \b to\b0  aNode\cf1 .\cf0 ChildNodes\cf1 .\cf0 Count \cf1 -\cf0  \cf4 1\cf0  \b do
\par \b0         aStack\cf1 .\cf0 Push\cf1 (\cf0 pointer\cf1 (\cf0 ANode\cf1 .\cf0 ChildNodes\cf1 [\cf0 i\cf1 ]));
\par \cf0       \b While\b0  astack\cf1 .\cf0 Count \cf1 >\cf0  \cf4 0\cf0  \b do\b0  \b begin
\par \b0         inc\cf1 (\cf0 result\cf1 );
\par \cf0         aNode \cf1 :=\cf0  ixmlNode\cf1 (\cf0 astack\cf1 .\cf0 Pop\cf1 );
\par \cf0         \b If\b0  assigned\cf1 (\cf0 ANode\cf1 .\cf0 ChildNodes\cf1 )\cf0  \b then
\par \b0           \b For\b0  i \cf1 :=\cf0  \cf4 0\cf0  \b to\b0  ANode\cf1 .\cf0 ChildNodes\cf1 .\cf0 Count \cf1 -\cf0  \cf4 1\cf0  \b do
\par \b0             aStack\cf1 .\cf0 Push\cf1 (\cf0 pointer\cf1 (\cf0 ANode\cf1 .\cf0 ChildNodes\cf1 [\cf0 i\cf1 ]));
\par 
\par \cf0         \b If\b0  assigned\cf1 (\cf0 ANode\cf1 .\cf0 AttributeNodes\cf1 )\cf0  \b then
\par \b0           \b For\b0  i \cf1 :=\cf0  \cf4 0\cf0  \b to\b0  ANode\cf1 .\cf0 AttributeNodes\cf1 .\cf0 Count \cf1 -\cf0  \cf4 1\cf0  \b do
\par \b0             aStack\cf1 .\cf0 Push\cf1 (\cf0 pointer\cf1 (\cf0 ANode\cf1 .\cf0 AttributeNodes\cf1 [\cf0 i\cf1 ]));
\par \cf0       \b end\b0\cf1 ;
\par \cf0   \b finally
\par \b0     aStack\cf1 .\cf0 Free\cf1 ;
\par \cf0   \b end\b0\cf1 ;
\par 
\par \cf0\b end\b0\cf1 ;
\par 
\par \cf2\i //############################################################################
\par // Archimedes Spiral App
\par //############################################################################
\par 
\par \i0\cf0\b procedure\b0  SIRegister_TOvcIntlSup\cf1 (\cf0 CL\cf1 :\cf0  TPSPascalCompiler\cf1 );
\par \cf0\b begin
\par \b0   \cf2\i //with RegClassS(CL,'TObject', 'TOvcIntlSup') do
\par \i0\cf0   \b with\b0  CL\cf1 .\cf0 AddClassN\cf1 (\cf0 CL\cf1 .\cf0 FindClass\cf1 (\cf3 'TObject'\cf1 ),\cf3 'TOvcIntlSup'\cf1 )\cf0  \b do\b0  \b begin
\par \b0     RegisterMethod\cf1 (\cf3 'Constructor Create'\cf1 );
\par \cf0     \b Procedure\b0  Free\cf3 ');
\par \cf0     \b Function\b0  CurrentDateString\cf1 (\cf0  \b const\b0  Picture \cf1 :\cf0  \b string\b0\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  CurrentDatePChar\cf1 (\cf0  Dest \cf1 :\cf0  PChar\cf1 ;\cf0  Picture \cf1 :\cf0  PChar\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  CurrentTimeString\cf1 (\cf0  \b const\b0  Picture \cf1 :\cf0  \b string\b0\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  CurrentTimePChar\cf1 (\cf0  Dest \cf1 :\cf0  PChar\cf1 ;\cf0  Picture \cf1 :\cf0  PChar\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  DateToDateString\cf1 (\cf0\b const\b0  Picture\cf1 :\cf0\b string\b0\cf1 ;\cf0  Julian\cf1 :\cf0 TStDate\cf1 ;\cf0 Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  DateToDatePChar\cf1 (\cf0 Dest\cf1 :\cf0 PChar\cf1 ;\cf0 Picture\cf1 :\cf0 PChar\cf1 ;\cf0 Julian\cf1 :\cf0 TStDate\cf1 ;\cf0 Pack\cf1 :\cf0 Boolean\cf1 ):\cf0 PChar\cf3 ');
\par \cf0     \b Function\b0  DateTimeToDatePChar\cf1 (\cf0 Dest\cf1 :\cf0 PChar\cf1 ;\cf0 Picture\cf1 :\cf0 PChar\cf1 ;\cf0 DT\cf1 :\cf0 TDateTime\cf1 ;\cf0 Pack\cf1 :\cf0 Bool\cf1 ):\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  DateStringToDMY\cf1 (\cf0  \b const\b0  Picture\cf1 ,\cf0  S \cf1 :\cf0  \b string\b0\cf1 ;\cf0  \b var\b0  Day\cf1 ,\cf0  Month\cf1 ,\cf0  Year \cf1 :\cf0  Integer\cf1 ;\cf0  Epoch \cf1 :\cf0  Integer\cf1 )\cf0  \cf1 :\cf0  Boolean\cf3 ');
\par \cf0     \b Function\b0  DatePCharToDMY\cf1 (\cf0 Picture\cf1 ,\cf0 S\cf1 :\cf0 PChar\cf1 ;\cf0\b var\b0  Day\cf1 ,\cf0 Month\cf1 ,\cf0 Year\cf1 :\cf0 Integer\cf1 ;\cf0 Epoch\cf1 :\cf0 Integer\cf1 ):\cf0 Bool\cf3 ');
\par \cf0     \b Function\b0  DateStringIsBlank\cf1 (\cf0  \b const\b0  Picture\cf1 ,\cf0  S \cf1 :\cf0  \b string\b0\cf1 )\cf0  \cf1 :\cf0  Boolean\cf3 ');
\par \cf0     \b Function\b0  DatePCharIsBlank\cf1 (\cf0  Picture\cf1 ,\cf0  S \cf1 :\cf0  PChar\cf1 )\cf0  \cf1 :\cf0  Boolean\cf3 ');
\par \cf0     \b Function\b0  DateStringToDate\cf1 (\cf0  \b const\b0  Picture\cf1 ,\cf0  S \cf1 :\cf0  \b string\b0\cf1 ;\cf0  Epoch \cf1 :\cf0  Integer\cf1 )\cf0  \cf1 :\cf0  TStDate\cf3 ');
\par \cf0     \b Function\b0  DatePCharToDate\cf1 (\cf0  Picture\cf1 ,\cf0  S \cf1 :\cf0  PChar\cf1 ;\cf0  Epoch \cf1 :\cf0  Integer\cf1 )\cf0  \cf1 :\cf0  TStDate\cf3 ');
\par \cf0     \b Function\b0  DayOfWeekToString\cf1 (\cf0  WeekDay \cf1 :\cf0  TDayType\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  DayOfWeekToPChar\cf1 (\cf0  Dest \cf1 :\cf0  PChar\cf1 ;\cf0  WeekDay \cf1 :\cf0  TDayType\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  DMYtoDateString\cf1 (\cf0  \b const\b0  Picture \cf1 :\cf0  \b string\b0\cf1 ;\cf0  Day\cf1 ,\cf0  Month\cf1 ,\cf0  Year \cf1 :\cf0  Integer\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 ;\cf0  Epoch \cf1 :\cf0  Integer\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  DMYtoDatePChar\cf1 (\cf0  Dest \cf1 :\cf0  PChar\cf1 ;\cf0  Picture \cf1 :\cf0  PChar\cf1 ;\cf0  Day\cf1 ,\cf0  Month\cf1 ,\cf0  Year \cf1 :\cf0  Integer\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 ;\cf0  Epoch \cf1 :\cf0  Integer\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  InternationalCurrency\cf1 (\cf0  FormChar \cf1 :\cf0  Char\cf1 ;\cf0  MaxDigits \cf1 :\cf0  Byte\cf1 ;\cf0  Float\cf1 ,\cf0  AddCommas\cf1 ,\cf0  IsNumeric \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  InternationalCurrencyPChar\cf1 (\cf0  Dest \cf1 :\cf0  PChar\cf1 ;\cf0  FormChar \cf1 :\cf0  Char\cf1 ;\cf0  MaxDigits \cf1 :\cf0  Byte\cf1 ;\cf0  Float\cf1 ,\cf0  AddCommas\cf1 ,\cf0  IsNumeric \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  InternationalDate\cf1 (\cf0  ForceCentury \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  InternationalDatePChar\cf1 (\cf0  Dest \cf1 :\cf0  PChar\cf1 ;\cf0  ForceCentury \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  InternationalLongDate\cf1 (\cf0  ShortNames \cf1 :\cf0  Boolean\cf1 ;\cf0  ExcludeDOW \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  InternationalLongDatePChar\cf1 (\cf0 Dest\cf1 :\cf0 PChar\cf1 ;\cf0 ShortNames\cf1 :\cf0 Boolean\cf1 ;\cf0  ExcludeDOW\cf1 :\cf0 Boolean\cf1 ):\cf0 PChar\cf3 ');
\par \cf0     \b Function\b0  InternationalTime\cf1 (\cf0  ShowSeconds \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  InternationalTimePChar\cf1 (\cf0  Dest \cf1 :\cf0  PChar\cf1 ;\cf0  ShowSeconds \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  MonthStringToMonth\cf1 (\cf0  \b const\b0  S \cf1 :\cf0  \b string\b0\cf1 ;\cf0  Width \cf1 :\cf0  Byte\cf1 )\cf0  \cf1 :\cf0  Byte\cf3 ');
\par \cf0     \b Function\b0  MonthPCharToMonth\cf1 (\cf0  S \cf1 :\cf0  PChar\cf1 ;\cf0  Width \cf1 :\cf0  Byte\cf1 )\cf0  \cf1 :\cf0  Byte\cf3 ');
\par \cf0     \b Function\b0  MonthToString\cf1 (\cf0  Month \cf1 :\cf0  Integer\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  MonthToPChar\cf1 (\cf0  Dest \cf1 :\cf0  PChar\cf1 ;\cf0  Month \cf1 :\cf0  Integer\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Procedure\b0  ResetInternationalInfo\cf3 ');
\par \cf0     \b Function\b0  TimeStringToHMS\cf1 (\cf0\b const\b0  Picture\cf1 ,\cf0 S\cf1 :\cf0\b string\b0\cf1 ;\cf0\b var\b0  Hour\cf1 ,\cf0 Minute\cf1 ,\cf0 Second\cf1 :\cf0  Integer\cf1 ):\cf0 Boolean\cf3 ');
\par \cf0     \b Function\b0  TimePCharToHMS\cf1 (\cf0  Picture\cf1 ,\cf0  S \cf1 :\cf0  PChar\cf1 ;\cf0  \b var\b0  Hour\cf1 ,\cf0  Minute\cf1 ,\cf0  Second \cf1 :\cf0  Integer\cf1 ):\cf0 Boolean\cf3 ');
\par \cf0     \b Function\b0  TimeStringToTime\cf1 (\cf0  \b const\b0  Picture\cf1 ,\cf0  S \cf1 :\cf0  \b string\b0\cf1 )\cf0  \cf1 :\cf0  TStTime\cf3 ');
\par \cf0     \b Function\b0  TimePCharToTime\cf1 (\cf0  Picture\cf1 ,\cf0  S \cf1 :\cf0  PChar\cf1 )\cf0  \cf1 :\cf0  TStTime\cf3 ');
\par \cf0     \b Function\b0  TimeToTimeString\cf1 (\cf0  \b const\b0  Picture \cf1 :\cf0  \b string\b0\cf1 ;\cf0  T \cf1 :\cf0  TStTime\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  TimeToTimePChar\cf1 (\cf0 Dest\cf1 :\cf0 PChar\cf1 ;\cf0 Picture\cf1 :\cf0  PChar\cf1 ;\cf0  T \cf1 :\cf0  TStTime\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     \b Function\b0  TimeToAmPmString\cf1 (\cf0  \b const\b0  Picture \cf1 :\cf0  \b string\b0\cf1 ;\cf0  T \cf1 :\cf0  TStTime\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  \b string\b0\cf3 ');
\par \cf0     \b Function\b0  TimeToAmPmPChar\cf1 (\cf0 Dest\cf1 :\cf0  PChar\cf1 ;\cf0  Picture\cf1 :\cf0 PChar\cf1 ;\cf0  T\cf1 :\cf0  TStTime\cf1 ;\cf0  Pack \cf1 :\cf0  Boolean\cf1 )\cf0  \cf1 :\cf0  PChar\cf3 ');
\par \cf0     RegisterProperty\cf1 (\cf3 'AutoUpdate'\cf1 ,\cf0  \cf3 'Boolean'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'CurrencyLtStr'\cf1 ,\cf0  \cf3 'string'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'CurrencyRtStr'\cf1 ,\cf0  \cf3 'string'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'DecimalChar'\cf1 ,\cf0  \cf3 'Char'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'CommaChar'\cf1 ,\cf0  \cf3 'Char'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'Country'\cf1 ,\cf0  \cf3 'string'\cf1 ,\cf0  iptr\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'CurrencyDigits'\cf1 ,\cf0  \cf3 'Byte'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'ListChar'\cf1 ,\cf0  \cf3 'Char'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'SlashChar'\cf1 ,\cf0  \cf3 'Char'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'TrueChar'\cf1 ,\cf0  \cf3 'Char'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'FalseChar'\cf1 ,\cf0  \cf3 'Char'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'YesChar'\cf1 ,\cf0  \cf3 'Char'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'NoChar'\cf1 ,\cf0  \cf3 'Char'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0     RegisterProperty\cf1 (\cf3 'OnWinIniChange'\cf1 ,\cf0  \cf3 'TNotifyEvent'\cf1 ,\cf0  iptrw\cf1 );
\par \cf0   \b end\b0\cf1 ;
\par \cf0\b end\b0\cf1 ;
\par 
\par \cf0\b initialization\b0  
\par   MyIntObject\cf1 :=\cf0  TMyObject\cf1 .\cf0 Create\cf1 ;\cf0  
\par \b finalization\b0  
\par   MyIntObject\cf1 .\cf0 Free\cf1 ;\cf0  
\par 
\par But how about the DLL \b is\b0  written \b in\b0  C\cf1 ++?
\par 
\par \cf0 At the very \b end\b0  we call a C\cf1 ++\cf0  DLL from \b maXbox\b0\cf1 :
\par \cf0 First \b of\b0  all\cf1 ,\cf0  you have \b to\b0  translate the header\cf1 -\cf0\b file\b0  \cf1 (\cf0 should be delivered \b with\b0  the DLL\cf1 ),\cf0  which \b is\b0  like an \b interface\b0\cf1 -\cf0 section \b in\b0  OP\cf1 .\cf0  Headers \b in\b0  c usually contain all sorts \b of\b0  definitions which are relevant outside the module\cf1 .\cf0  \b In\b0  our c\cf1 ++\cf0  example it looks like\cf1 :\cf0  
\par 
\par \cf1 /*\cf0\b FILE\b0\cf1 :\cf0  income\cf1 .\cf0 h \cf1 */\cf0  
\par \b class\b0  CIncome 
\par \cf2\i \{ 
\par   public: 
\par     virtual double __stdcall GetIncome( double aNetto ) = 0 ; 
\par     virtual void   __stdcall SetRate( int aPercent, int  aYear ) = 0 ; 
\par     virtual void   __stdcall FreeObject() = 0 ; 
\par \}\i0\cf0  \cf1 ;
\par 
\par \cf0\b Then\b0  you translate it \b to\b0  an \b Abstract\b0  \b Class\b0  \b in\b0  a \b unit\b0  \b of\b0  her own\cf1 :\cf0  
\par 
\par \cf2\i //FILE: income.pas 
\par \i0\cf0\b interface\b0  
\par \b type\b0  
\par CIncome \cf1 =\cf0  \b class\b0  
\par    \b public\b0  
\par    \b function\b0  GetIncome\cf1 (\cf0\b const\b0  aNetto\cf1 :\cf0  double\cf1 ):\cf0  double\cf1 ;\cf0  
\par                                \b virtual\b0\cf1 ;\cf0  \b stdcall\b0\cf1 ;\cf0  \b abstract\b0\cf1 ;\cf0  
\par    \b procedure\b0  SetRate\cf1 (\cf0\b const\b0  aPercent\cf1 :\cf0  Integer\cf1 ;\cf0  aYear\cf1 :\cf0  integer\cf1 );\cf0  
\par                                \b virtual\b0\cf1 ;\cf0  \b stdcall\b0\cf1 ;\cf0  \b abstract\b0\cf1 ;\cf0  
\par    \b procedure\b0  FreeObject\cf1 ;\cf0  \b virtual\b0\cf1 ;\cf0  \b stdcall\b0\cf1 ;\cf0  \b abstract\b0\cf1 ;\cf0  
\par \b end\b0\cf1 ;
\par 
\par 
\par 
\par 
\par ----\cf0 app_template_loaded_code\cf1 ----
\par 
\par \cf4 10\cf0  vor \cf4 10\cf0  kannst Du entweder live am PC schauen
\par http\cf1 :\cf2\i //www.srf.ch/livestream/player/srf-1
\par 
\par \i0\cf0 oder anschliessend an die Sendung\cf1 :
\par \cf0 http\cf1 :\cf2\i //www.srf.ch/sendungen/10vor10
\par 
\par 
\par \i0\cf0 Short \b for\b0  \b Dynamic\b0  Link \b Library\b0\cf1 ,\cf0  a \b library\b0  \b of\b0  executable functions \b or\b0  data that can be used by a Windows application\cf1 .\cf0  Typically\cf1 ,\cf0  a DLL provides one \b or\b0  more particular functions \b and\b0  a \b program\b0  accesses the functions by creating either a static \b or\b0  \b dynamic\b0  link \b to\b0  the DLL\cf1 .\cf0  A static link remains constant during \b program\b0  execution \b while\b0  a \b dynamic\b0  link \b is\b0  created by the \b program\b0  \b as\b0  needed\cf1 .\cf0  DLLs can also contain just data\cf1 .\cf0  DLL files usually \b end\b0  \b with\b0  the extension \cf1 .\cf0 dll\cf1 ,.\cf0 exe\cf1 .,\cf0  drv\cf1 ,\cf0  \b or\b0  \cf1 .\cf0 fon\cf1 .
\par 
\par \cf0 A DLL can be used by several applications at the same time\cf1 .\cf0  Some DLLs are provided \b with\b0  the Windows operating system \b and\b0  available \b for\b0  any Windows application\cf1 .\cf0  Other DLLs are written \b for\b0  a particular application \b and\b0  are loaded \b with\b0  the application\cf1 .
\par 
\par 
\par \cf0 Disclaimer\cf1 :\cf0  The foregoing release may contain \b forward\b0\cf1 -\cf0 looking statements that
\par can be identified by terminology such \b as\b0  \cf3 'seek'\cf1 ,\cf0  \cf3 'not pursue'\cf1 ,\cf0  \cf3 'not approvable'\cf1 ,
\par \cf3 'continue'\cf1 ,\cf0  \cf3 'believes'\cf1 ,\cf0  \cf3 'believe'\cf1 ,\cf0  \cf3 'will'\cf1 ,\cf0  \cf3 'remained open to exploring'\cf1 ,
\par \cf3 'would'\cf1 ,\cf0  \cf3 'could'\cf1 ,\cf0  \b or\b0  similar expressions\cf1 ,\cf0  \b or\b0  by express \b or\b0  implied discussions
\par regarding Addex Therapeutics\cf1 ,\cf0  formerly known \b as\b0\cf1 ,\cf0  Addex Pharmaceuticals\cf1 ,\cf0  its
\par business\cf1 ,\cf0  the potential approval \b of\b0  its products by regulatory authorities\cf1 ,\cf0  \b or
\par \b0 regarding potential future revenues from such products\cf1 .\cf0  Such \b forward\b0\cf1 -\cf0 looking
\par statements reflect the current views \b of\b0  Addex Therapeutics regarding future
\par 
\par events\cf1 ,\cf0  future economic performance \b or\b0  prospects\cf1 ,\cf0  \b and\b0\cf1 ,\cf0  by their very nature\cf1 .\cf0  
\par 
\par \cf1 ----\cf0 Simple Browser started\cf1 ----
\par ----\cf0 Simple Browser started\cf1 ----
\par }