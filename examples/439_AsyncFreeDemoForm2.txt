PROGRAM AsyncFree_COM_Form;

//////////////////////////////////////////////////////////////////////
//  #sign: max: MAXBOX8: 8/11/2014 6:39:22 PM 
//  Purpose: Grabs async COM out of,  more items see below   //
//  #path>ples\C:\maXbook\maxbox3\mX3999\maxbox3\examples\          //
//  Lines of Code #locs:466
//////////////////////////////////////////////////////////////////////

Const TEXTOUT = 'hi world of COM Turbo Power coverage with cover age';

//############################################################################
// AsyncFree Prof TurboPower Spiral Architect
//############################################################################
//TODO: Button with stop event, change terminal color and save terminal to stream

{TYPE <Type declarations>} 

  var aform: TForm;
      FWait, bswitch: Boolean;
      termstream: TMemoryStream;

//<FUNCTION>
//<PROCEDURE> 


function SplitToken(const Text: string; SplitChar: Char;
    var First, Last: string): Boolean;
var  SplitPos: Integer;
begin
  Result:= False;
  SplitPos:= Pos(SplitChar, Text);
  if SplitPos = 0 then Exit;
  First:= Trim(Copy(Text, 1, SplitPos -1));
  Last:= Trim(Copy(Text, SplitPos +1, Length(Text) -SplitPos));
  Result:= (First <>'') and (Last <>'');
end;

procedure TestKeyStateDemo;
var I: integer;
BEGIN
   I := 0;
   REPEAT
      IF GetAsyncKeyState(VK_RETURN) <> 0 THEN BEGIN
         Inc(I);
         Writeln(itoa(I)+' ');
         //single mode!
         //WHILE GetAsyncKeyState(VK_RETURN) AND $8000 <> 0 DO {Nothing};
      END;
   UNTIL GetAsyncKeyState(VK_ESCAPE) <> 0;
   //SetConsoleTextAttribute(hOut, Attr);
   //SetConsoleCursorPosition(hOut, c);
   //WriteConsole(hOut, PChar(S), Length(S), Result, nil);
end;

//com form test vars maXcom
//*************************************Af COM_Code_Streamer*****************;

var
    AfTerminal1: TAfTerminal;
    AfComPort1: TAfComPort;
    AfPortRadioGroup1: TAfPortRadioGroup;
    Panel1: TPanel;
    
procedure FormClose(Sender: TObject; var Action: TCloseAction);
begin
  //AfComPort1.CloseComPort;
  //AfComPort1.Close;
  {AfComPort1.Free;
  AfTerminal1.Free;
  AfPortRadioGroup1.Free;}
    AfTerminal1.FreeOnRelease;
    AfComPort1.Close;
    AfComPort1.FreeOnRelease;
    AfPortRadioGroup1.FreeOnRelease;
  aForm.FreeOnRelease;
  WRITELN('ALL PORT AND TERMINAL CLOSED ');
end;
    
procedure FormFree(Sender: TObject);
begin
  AfTerminal1.selectAll;
  AfTerminal1.copytoclipboard;
  memo2.pastefromclipboard;
  sleep(800);
  aForm.close;
end;  

procedure ExporttoClip(Sender: TObject);
begin
  AfTerminal1.selectAll;
  AfTerminal1.copytoclipboard;
  AfTerminal1.clearSelection;
  AfTerminal1.setFocus;
  memo2.readonly:= false;
  memo2.pastefromclipboard;
  sleep(800);
end;  
  
procedure TPortForm1_AfTerminal1SendChar(Sender: TObject; var Key: Char);
begin
  AfComPort1.WriteChar(Key);
end;

procedure TPortForm1_AfComPort1DataRecieved(Sender: TObject; Count: Integer);
begin
  AfTerminal1.WriteString(AfComPort1.ReadString);
  try
  //AfTerminal1.WriteString(inttoStr(ord(AfComPort1.ReadChar)));
    write(AfComPort1.ReadString) //is buffer empty
  except
    raise;
  end
end;

procedure TPortForm1_Button1Click(Sender: TObject);
begin
  AfComPort1.ExecuteConfigDialog;
end;

procedure TPortForm1_AfPortRadioGroup1Click(Sender: TObject);
begin
  AfTerminal1.SetFocus;
end;

procedure BlinkToArduino(sender: TObject);
var retc: char;
begin
 //AfComPort1.comnumber:= AfPortRadioGroup1.ComponentIndex;
 //maxform1.ResetKeypressed;
 bswitch:= NOT bswitch;
 if bswitch then TBitBtn(sender).caption:= '&Stop Blink' else
   TBitBtn(sender).caption:= '&Blink';
 repeat
   //AfTerminal1.WriteChar('1');
   AfComPort1.WriteChar('1');
   sleep(100)
   //AfTerminal1.WriteChar('A');
   AfComPort1.WriteChar('A');
   sleep(100)
   //retc:= AfComPort1.ReadChar;
   Application.ProcessMessages;
 until NOT bswitch;
 //until isKeypressed;
 //retc = 'q';
    writeln('Blink Loop done at '+timetoStr(now));
end; 
   


procedure TPortForm1_FormCreate(Sender: TObject);
begin
  aForm:= TForm.create(self)
  with aForm do begin
    position:= poScreenCenter;
    FormStyle:= fsStayOnTop;
    color:= clblue;
    borderStyle:= bsDialog;
    caption:= 'mX3 Arduino COM Code StreamDreamBeam'
    width:= 820; height:= 710;
    OnClose:= @FormClose;
    Show;
  end;
  Panel1:= TPanel.Create(self);
   with Panel1 do begin
    parent:= aForm;
    //Caption:= 'Config Ports';
    SetBounds(575,20,150,250)
  end;
  with TOvcClock.create(self) do begin
    parent:= aForm;
    //Caption:= 'Config Ports';
    SetBounds(600,365,90,90)
    time:= now;
    DisplayMode:= dmAnalog;
  end;

  with TBitBtn.Create(aForm) do begin
    Parent:= aForm;
    setbounds(340, 600,150, 55);
    caption:= '&Config';
    font.size:= 12;
    glyph.LoadFromResourceName(getHINSTANCE,'TAFTERMINAL'); // CL_MPSTOP'); 
    mXButton(05,05,width, height,12,12,handle);
    onClick:= @TPortForm1_Button1Click;
  end;
 
  with TBitBtn.Create(aForm) do begin
    Parent:= aForm;
    setbounds(20, 600,150, 55);
    caption:= '&CLOSE';
    font.size:= 12;
    glyph.LoadFromResourceName(getHINSTANCE,'TAFCOMPORT'); // CL_MPSTOP'); 
    mXButton(05,05,width, height,12,12,handle);
    onClick:= @FormFree;
  end;
  with TBitBtn.Create(aForm) do begin
    Parent:= aForm;
    setbounds(340, 530,150, 55);
    caption:= '&Export';
    hint:= 'Export to Clipboard Save ';
    ShowHint:= True;
    font.size:= 12;
    glyph.LoadFromResourceName(getHINSTANCE,'TALMEMO'); // CL_MPSTOP'); 
    mXButton(05,05,width, height,12,12,handle);
    onClick:= @ExporttoClip;
  end;
  
  AfComPort1:= TAfComPort.Create(NIL);
   with AfComPort1 do begin
    BaudRate:= br4800; //br9600;
    Parity:= None;
    // show a possible cast to core
    //TAfComPortCore(Afcomport1).DirectWrite:= True;
    OnDataRecived:= @TPortForm1_AfComPort1DataRecieved;
  end;

   AfPortRadioGroup1:= TAfPortRadioGroup.Create(self);
   with AfPortRadioGroup1 do begin
      parent:= Panel1;
      SetBounds(26,18,95,190)
      ComPort:= AfComPort1;
      MaxComPorts:= 8;
      Options:= [pcCheckExist, pcHighlightOpen];
      Caption:= ' &Select Port';
      Show;
      OnClick:= @TPortForm1_AfPortRadioGroup1Click;
    end;
  with TBitBtn.Create(aForm) do begin
    Parent:= aForm;
    setbounds(180, 600,150, 55);
    caption:= '&Blink';
    font.size:= 12;
    glyph.LoadFromResourceName(getHINSTANCE,'TAFDATADISPATCHER'); // CL_MPSTOP'); 
    mXButton(05,05,width, height,12,12,handle);
    onClick:= @BlinktoArduino;
  end;

    //termstream:= TMemoryStream.create;  

  AfTerminal1:= TAfTerminal.create(self);
  with AfTerminal1 do begin
    parent:= aForm;
    SetBounds(10,10,520,480)
    //Align:= alClient;
    borderstyle:= bsDialog;
    CaretBlinkTime:= 500;
    //canvas
    Color:= clblack;
    Font.size:= 22;
    //font.name:= 'Courier';
    displaycols:= 30;
    autoscrollback:= true;
    MaxLineLength:= 32;
    //setlinelength(30);
    //Font.color:= clGreen;
    //bufferline
    Font.color:= clred; //yellow;
    TermColorMode:= cmline;
    //CharWidth:= 20;
    LogName:= 'asyncLOG.TXT';
    Logging:= tlAppend;//lgCreate; //tlAppend; //
    logflushtime:= 10;
    //VertScrollBarSize;
    //linecount:= 30;
    //usescroll:= true;
    //writetolog(logname)
    //LogMemStream:= termstream;
    //LogFileStream
    //copytoclipboard;
    //Options:= [];
    Show;
    WriteChar('H');
    WriteChar('i');
    WriteString(' * term in all *** ')
    OnSendChar:= @TPortForm1_AfTerminal1SendChar;
    //WriteColorChar('D',0,12)
    //DrawToCanvas
    //CharHeight:= 30;
    //OnFlushLog
    {WriteChar('1');
    WriteChar('A');}
  
  end;
  
   //BlinktoArduino; Init
      bswitch:= FALSE;
    
    //AfComPort1.WriteChar('T');
    //TAfTRMCharAttr
    //AfComPort1.WriteColorChar
     //SetFileSecurity
     //ReportEvent
    // RegSaveKey; 
end;

  //var FComPort: TAfComPort;
  
 type
  TInputRec = record
    aPrompt: string;
    MaxLength : integer;
    FieldType : TFieldType;
    FieldValue : Variant;
    EventType: Word;
  end; 

var
  StdIn: THandle;
  InputBuffer: TInputRec;
  InputEvents, ConsoleMode: DWORD;
  //SimpleComPort: TSimpleComPort;

procedure testasync_Demo;
begin
  //SetConsoleTitle('AsyncFree NonVCL example, press ESC to exit');
  //StdIn := GetStdHandle(STD_INPUT_HANDLE);
  if StdIn = INVALID_HANDLE_VALUE then RaiseLastWin32Error;
     //KEY_EVENT:
   
  //Win32Check(GetConsoleMode(StdIn, ConsoleMode));
 // Win32Check(SetConsoleMode(StdIn, ConsoleMode and (not ENABLE_ECHO_INPUT)));
   //SimpleComPort := TSimpleComPort.Create;
  //SimpleComPort.Open(1, 'baud=115200 parity=N data=8 stop=1');

  (*while True do
    //if ReadConsoleInput(StdIn, InputBuffer, 1, InputEvents) then
    case InputBuffer.EventType of
      KEY_EVENT:
        with InputBuffer.Event.KeyEvent do if bKeyDown then
          case AsciiChar of
            #08, #10, #13, #32..#255:
              SimpleComPort.WriteString(AsciiChar);
            #27:
              Break;
          end;
    end;
  SimpleComPort.Free;*)
end;

 //****************************Af COM_Code_End**************************

type Trec = record
             ind: byte;
           end;
           
 type
  //PInputRecord = ^TInputRecord;
  {_INPUT_RECORD = record
    EventType: Word;
    Reserved: Word; }  // this record member was missing
    {case Integer of
      0: (KeyEvent: TKeyEventRecord);
      1: (MouseEvent: TMouseEventRecord);
      2: (WindowBufferSizeEvent: TWindowBufferSizeRecord);
      3: (MenuEvent: TMenuEventRecord);
      4: (FocusEvent: TFocusEventRecord);}
  //end;

             
function getRecTest: TRec;
begin
  result.ind:= 12344;;
end;  

procedure AfComPort1DataRecived(Sender: TObject; Count: Integer);
var AfTerminal1: TAfTerminal;
    AfComPort1: TAfComPort;
begin
  writeln(inttostr(getRecTest.ind));
  AfTerminal1.WriteString(AfComPort1.ReadString);
end;

var  FComPort: TAfComPortCore;
procedure TSimpleComPort_PortEvent(Sender: TAfComPortCore;
                                EventKind: TAfCoreEvent; Data: DWORD);
//  FComPort: TAfComPort;
var acs: TComStat;
    count, idata: integer;
    St: string;
begin
   //acs.cbinQue:= 234;
   //acs1.reserved[1]:= 12;
  acs:= FComPort.ComStatus;
  Count:= acs.CBInQue;
  //count:= TComStat(FComPort).ComStatus;
    AfComPort1.BaudRate:= br9600;
    AfComPort1.OnDataRecived:= @AfComPort1DataRecived;
   //Count:= TComStat(FComPort.ComStatus).CBInQue;
   Count:= acs.CBInQue;
   //SetString(S, 0, Count);
   //PutEvent
   //PeekConsoleInput
  FComPort.ReadData(idata,Count);
  //Write(S);
end;

procedure TSimpleComPort_Open(PortNumber: Integer; const Parameters: String);
var DCB: TDCB;
  //C: array[0..255] of Char;
  C: PChar;
begin
  //StrPCopy(C, Parameters);
  //ZeroMemory(@DCB, Sizeof(DCB));
  Win32Check(BuildCommDCB(PChar(C), DCB));
  FComPort.DCB:= DCB;
  FComPort.OpenComPort(PortNumber);
  Writeln(Format('Port initialized: COM%d: %s', [PortNumber, Parameters]));
end;

//var FComPort: TAfComPortCore;
procedure TSimpleComPort_Create;
begin
  FComPort:= TAfComPortCore.Create;
  FComPort.OnPortEvent:= @TSimpleComPort_PortEvent;
  FComPort.DirectWrite:= True;
end;

procedure TSimpleComPort_Destroy;
begin
  FComPort.Free;
  //inherited Destroy;
end;


Begin  //Main
//<Executable statements>
  //TOutlookExport_Spy;
  Writeln('AsyncPro Start the Mart:');
//<Definitions>  

  {with TPortForm1.create(NIL) do begin
   //writeln(inttostr(GetHostByName(gethostname)));
    AfComPort1.BaudRate:= br4800;
    //OnDataRecived
    //Showmodal;
    Showmodal;
    Free;
  end;} 
  
  TPortForm1_FormCreate(Self);
  with TOvcCalculator.create(self) do begin
    parent:= aForm;
  //free;
    setbounds(550,505,200,150);
    displaystr:= 'maXcalc';
  end;
  
   //ares:= TResolver.create;
 { with TResolver.create do begin
   //writeln(inttostr(GetHostByName(gethostname)));
    Free; end;  }
   {repeat 
     TApplication_PaintView(aform.canvas);
     switch:= NOT switch;
     Sleep(20);
   until isKeyPressed or FWait;}
  //function GetMacAddresses(const Machine: string; const Addresses: TStrings):Integer;
    //OVCInternationalDemoClass;
    writeln(CreateGUIDString);
    //writeln(sha1(exepath+'maxbox3.exe'));
    writeln(getASCIIline);
    //TestKeyStateDemo;
    //doWebCamPic(ExePath+'mypictest12.png');

END. 


//############################################################################
// Archimedes Turbo Spiral App
//############################################################################

//GUI EXample:

type
  TPortForm1 = class(TForm)
    Panel1: TPanel;
    //AfTerminal1: TAfTerminal;
    //AfComPort1: TAfComPort;
    Button1: TButton;
    //AfPortRadioGroup1: TAfPortRadioGroup;
    procedure AfTerminal1SendChar(Sender: TObject; var Key: Char);
    procedure AfComPort1DataRecived(Sender: TObject; Count: Integer);
    procedure Button1Click(Sender: TObject);
    procedure AfPortRadioGroup1Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
  private
    { Private declarations }
  public
    AfTerminal1: TAfTerminal;
    AfComPort1: TAfComPort;
    AfPortRadioGroup1: TAfPortRadioGroup;
    { Public declarations }
  end;

var
  PortForm1: TPortForm1;

implementation

//{$R *.DFM}

procedure TPortForm1.AfTerminal1SendChar(Sender: TObject; var Key: Char);
begin
  AfComPort1.WriteChar(Key);
end;

procedure TPortForm1.AfComPort1DataRecived(Sender: TObject; Count: Integer);
begin
  AfTerminal1.WriteString(AfComPort1.ReadString);
end;

procedure TPortForm1.Button1Click(Sender: TObject);
begin
  AfComPort1.ExecuteConfigDialog;
end;

procedure TPortForm1.FormCreate(Sender: TObject);
begin

  AfComPort1:= TAfComPort.Create(self);
   with AfComPort1 do begin
    BaudRate:= br4800;
    OnDataRecived:= AfComPort1DataRecived;
  end;

   AfPortRadioGroup1:= TAfPortRadioGroup.Create(self);
   with AfPortRadioGroup1 do begin
      parent:= Panel1;
      Left:= 8;
      Top:= 8;
      Width:= 89;
      Height:= 193;
      ComPort:= AfComPort1;
      MaxComPorts:= 8;
      Options:= [pcCheckExist, pcHighlightOpen];
      Caption:= '&Select Port';
      Show;
      //TabOrder = 1
      OnClick:= AfPortRadioGroup1Click;
    end;

  AfTerminal1:= TAfTerminal.create(self);
  with AfTerminal1 do begin
    parent:= self;
    Left:= 0;
    Top:= 0;
    Width:= 420;
    Height:= 352;
    Align:= alClient;
    CaretBlinkTime:= 500;
    LogName:= 'LOG.TXT';
    Options:= [];
    Show;
    OnSendChar:= AfTerminal1SendChar;
   end;
 end;

procedure TPortForm1.FormDestroy(Sender: TObject);
begin
    AfTerminal1.FreeOnRelease;
    AfComPort1.Close;
    AfComPort1.FreeOnRelease;
    AfPortRadioGroup1.FreeOnRelease;
end;


procedure TPortForm1.AfPortRadioGroup1Click(Sender: TObject);
begin
  AfTerminal1.SetFocus;
end;

end.

program NonVCLExample;

//{$APPTYPE CONSOLE}

uses
  Windows, Classes, SysUtils, AfComPortCore;

type
  TSimpleComPort = class(TObject)
  private
    FComPort: TAfComPortCore;
    procedure PortEvent(Sender: TAfComPortCore; EventKind: TAfCoreEvent; Data: DWORD);
  public
    constructor Create;
    destructor Destroy; override;
    procedure Open(PortNumber: Integer; const Parameters: String);
    procedure WriteString(const S: String);
  end;

{ TSimpleComPort }

constructor TSimpleComPort.Create;
begin
  FComPort := TAfComPortCore.Create;
  FComPort.OnPortEvent := PortEvent;
  FComPort.DirectWrite := True;
end;

destructor TSimpleComPort.Destroy;
begin
  FComPort.Free;
  inherited Destroy;
end;

procedure TSimpleComPort.Open(PortNumber: Integer; const Parameters: String);
var
  DCB: TDCB;
  C: array[0..255] of Char;
begin
  StrPCopy(C, Parameters);
  ZeroMemory(@DCB, Sizeof(DCB));
  Win32Check(BuildCommDCB(C, DCB));
  FComPort.DCB := DCB;
  FComPort.OpenComPort(PortNumber);
  Writeln(Format('Port initialized: COM%d: %s', [PortNumber, Parameters]));
end;

procedure TSimpleComPort.PortEvent(Sender: TAfComPortCore;
  EventKind: TAfCoreEvent; Data: DWORD);

  procedure DisplayData;
var
  S: String;
  Count: DWORD;
begin
  Count := FComPort.ComStatus.cbInQue;
  SetString(S, nil, Count);
  FComPort.ReadData(Pointer(S)^, Count);
  Write(S);
end;

begin
  case EventKind of
    ceLineEvent:
      begin
        if Data and EV_RXCHAR <> 0 then
          DisplayData;
        if Data and (not EV_RXCHAR) <> 0 then
          Write(Format(#13#10'Line error: %.8xh'#13#10, [Data])); 
      end;
    ceNeedReadData:
      DisplayData;
  end;
end;

procedure TSimpleComPort.WriteString(const S: String);
begin
  FComPort.WriteData(Pointer(S)^, Length(S));
end;

var
  StdIn: THandle;
  InputBuffer: TInputRecord;
  InputEvents, ConsoleMode: DWORD;
  SimpleComPort: TSimpleComPort;

begin
  SetConsoleTitle('AsyncFree NonVCL example, press ESC to exit');
  StdIn := GetStdHandle(STD_INPUT_HANDLE);
  if StdIn = INVALID_HANDLE_VALUE then RaiseLastWin32Error;
  Win32Check(GetConsoleMode(StdIn, ConsoleMode));
  Win32Check(SetConsoleMode(StdIn, ConsoleMode and (not ENABLE_ECHO_INPUT)));

  SimpleComPort := TSimpleComPort.Create;
  SimpleComPort.Open(1, 'baud=115200 parity=N data=8 stop=1');

  while True do
    if ReadConsoleInput(StdIn, InputBuffer, 1, InputEvents) then
    case InputBuffer.EventType of
      KEY_EVENT:
        with InputBuffer.Event.KeyEvent do if bKeyDown then
          case AsciiChar of
            #08, #10, #13, #32..#255:
              SimpleComPort.WriteString(AsciiChar);
            #27:
              Break;
          end;
    end;
   SimpleComPort.Free;
end.



procedure SIRegister_TOvcIntlSup(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TObject', 'TOvcIntlSup') do
  with CL.AddClassN(CL.FindClass('TObject'),'TOvcIntlSup') do begin
    RegisterMethod('Constructor Create');
    Procedure Free');
    Function CurrentDateString( const Picture : string; Pack : Boolean) : string');
    Function CurrentDatePChar(Dest:PChar; Picture : PChar; Pack : Boolean) : PChar');
    Function CurrentTimeString( const Picture : string; Pack : Boolean) : string');
    Function CurrentTimePChar(Dest:PChar; Picture : PChar; Pack : Boolean) : PChar');
    Function DateToDateString(const Picture : string; Julian : TStDate; Pack : Boolean) : string');
    Function DateToDatePChar( Dest : PChar; Picture : PChar; Julian : TStDate; Pack : Boolean) : PChar');
    Function DateTimeToDatePChar( Dest : PChar; Picture : PChar; DT : TDateTime; Pack : Boolean) : PChar');
    Function DateStringToDMY( const Picture, S : string; var Day, Month, Year : Integer; Epoch : Integer) : Boolean');
    Function DatePCharToDMY( Picture, S : PChar; var Day, Month, Year : Integer; Epoch : Integer) : Boolean');
    Function DateStringIsBlank( const Picture, S : string) : Boolean');
    Function DatePCharIsBlank( Picture, S : PChar) : Boolean');
    Function DateStringToDate(const Picture,S : string; Epoch : Integer) : TStDate');
    Function DatePCharToDate( Picture, S : PChar; Epoch : Integer) : TStDate');
    Function DayOfWeekToString( WeekDay : TDayType) : string');
    Function DayOfWeekToPChar( Dest : PChar; WeekDay : TDayType) : PChar');
    Function DMYtoDateString( const Picture : string; Day, Month, Year : Integer; Pack : Boolean; Epoch : Integer) : string');
    Function DMYtoDatePChar( Dest : PChar; Picture : PChar; Day, Month, Year : Integer; Pack : Boolean; Epoch : Integer) : PChar');
    Function InternationalCurrency( FormChar : Char; MaxDigits : Byte; Float, AddCommas, IsNumeric : Boolean) : string');
    Function InternationalCurrencyPChar( Dest : PChar; FormChar : Char; MaxDigits : Byte; Float, AddCommas, IsNumeric : Boolean) : PChar');
    Function InternationalDate( ForceCentury : Boolean) : string');
    Function InternationalDatePChar( Dest : PChar; ForceCentury : Boolean) : PChar');
    Function InternationalLongDate( ShortNames : Boolean; ExcludeDOW : Boolean) : string');
    Function InternationalLongDatePChar( Dest : PChar; ShortNames : Boolean; ExcludeDOW : Boolean) : PChar');
    Function InternationalTime( ShowSeconds : Boolean) : string');
    Function InternationalTimePChar( Dest : PChar; ShowSeconds : Boolean) : PChar');
    Function MonthStringToMonth( const S : string; Width : Byte) : Byte');
    Function MonthPCharToMonth( S : PChar; Width : Byte) : Byte');
    Function MonthToString( Month : Integer) : string');
    Function MonthToPChar( Dest : PChar; Month : Integer) : PChar');
    Procedure ResetInternationalInfo');
    Function TimeStringToHMS( const Picture, S : string; var Hour, Minute, Second : Integer) : Boolean');
    Function TimePCharToHMS( Picture, S : PChar; var Hour, Minute, Second : Integer) : Boolean');
    Function TimeStringToTime( const Picture, S : string) : TStTime');
    Function TimePCharToTime( Picture, S : PChar) : TStTime');
    Function TimeToTimeString(const Picture : string; T : TStTime; Pack : Boolean) : string');
    Function TimeToTimePChar( Dest : PChar; Picture : PChar; T : TStTime; Pack : Boolean) : PChar');
    Function TimeToAmPmString(const Picture : string; T : TStTime; Pack : Boolean) : string');
    Function TimeToAmPmPChar( Dest : PChar; Picture : PChar; T : TStTime; Pack : Boolean) : PChar');
    RegisterProperty('AutoUpdate', 'Boolean', iptrw);
    RegisterProperty('CurrencyLtStr', 'string', iptrw);
    RegisterProperty('CurrencyRtStr', 'string', iptrw);
    RegisterProperty('DecimalChar', 'Char', iptrw);
    RegisterProperty('CommaChar', 'Char', iptrw);
    RegisterProperty('Country', 'string', iptr);
    RegisterProperty('CurrencyDigits', 'Byte', iptrw);
    RegisterProperty('ListChar', 'Char', iptrw);
    RegisterProperty('SlashChar', 'Char', iptrw);
    RegisterProperty('TrueChar', 'Char', iptrw);
    RegisterProperty('FalseChar', 'Char', iptrw);
    RegisterProperty('YesChar', 'Char', iptrw);
    RegisterProperty('NoChar', 'Char', iptrw);
    RegisterProperty('OnWinIniChange', 'TNotifyEvent', iptrw);
  end;
end;

procedure SIRegister_TAfTerminal(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TAfCustomTerminal', 'TAfTerminal') do
  with CL.AddClassN(CL.FindClass('TAfCustomTerminal'),'TAfTerminal') do begin
   REgisterPublishedProperties;
   RegisterProperty('caption', 'string', iptrW);
  RegisterProperty('LogName', 'string', iptrw);
  RegisterProperty('OnSendChar', 'TKeyPressEvent', iptrw);
  RegisterProperty('CaretBlinkTime', 'TAfCLVCaretBlinkTime', iptrw);
  RegisterProperty('LogFileStream', 'TAfFileStream', iptrw);
  RegisterProperty('LogMemStream', 'TMemoryStream', iptrw);
  RegisterProperty('OnBeepChar', 'TNotifyEvent', iptrw);
  RegisterProperty('OnDrawBuffer', 'TNotifyEvent', iptrw);
  RegisterProperty('OnFlushLog', 'TNotifyEvent', iptrw);
   RegisterProperty('Options', 'TAfCLVOptions', iptrw);
   //RegisterProperty('Options', 'TAfComOptions', iptrw);

  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TAfCustomTerminal(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TAfCustomLineViewer', 'TAfCustomTerminal') do
  with CL.AddClassN(CL.FindClass('TAfCustomLineViewer'),'TAfCustomTerminal') do begin
    RegisterMethod('Constructor Create( AOwner : TComponent)');
     RegisterMethod('Procedure Free');
     RegisterMethod('Procedure ClearBuffer');
    RegisterMethod('Function DefaultTermColor : TAfTRMCharAttr');
    RegisterMethod('Procedure DrawChangedBuffer');
    RegisterMethod('Procedure WriteChar( C : Char)');
    RegisterMethod('Procedure WriteColorChar( C : Char; BColor, FColor : TAfTRMCharColor)');
    RegisterMethod('Procedure WriteColorStringAndData( const S : String; BColor, FColor : TAfTRMCharColor; UserDataItem : Pointer)');
    RegisterMethod('Procedure WriteString( const S : String)');
  end;
end;



----app_template_loaded_code----


I'm fairly new to Delphi (though I've been programming in Pascal for some time) and to get to know it better, I've decided to make a small console game. The game should basically move a character across the screen according to keypressed up, down, left and right. You have to be able to press multiple keys, so that you can also move diagonally. I've found that I need to use the GetASyncKeyState for this. To test it I wrote the below test program, but I can't get it to work. I can compile it without errors, but when I run it, my console window just freezes, ignoring all keypresses. After a while my keypresses will result in a beep from the computer and I have to forcefully close the console window. Why doesn't the below code work?

CODE
PROGRAM Test;

//{$APPTYPE CONSOLE}

USES SysUtils, Windows;

VAR I : Integer;

BEGIN
   I := 0;
   REPEAT
      IF GetAsyncKeyState(VK_RETURN) <> 0 THEN BEGIN
         Inc(I);
         Write(I);
      END;
   UNTIL GetAsyncKeyState(VK_ESCAPE) <> 0;
END.

buho (Programmer) 	
25 Sep 06 8:15
What OS version are you using (Win9x, 2K, XP)?

In 2K your code works as expected to work and it can be used to check the arrow keys. The problem is I don't know what *you* are expecting for it :).

Change it a little, use Write(I, #13#10); instead of Write(I); and recompile.

Run it and do a very quick press in the ENTER key; you'll see something like

1
2
3
4
5
6
...
nnn

This is due to the fact that the code detectes the keypress while the key is actually down (and what is quick for you are ages for the CPU).
 
Press ENTER and keep it down: you'll see an endless stream of numbers in your console screen.

Press any other key but ESCAPE; of course you'll see nothing; now keep ESCAPE and the console is done.

Now change the code a little:

CODE

...
   REPEAT
      IF GetAsyncKeyState(VK_RETURN) <> 0 THEN BEGIN
         Inc(I);
         Write(I, #13#10);
      WHILE GetAsyncKeyState(VK_RETURN) AND $8000 <> 0 DO {Nothing};
      END;
   UNTIL GetAsyncKeyState(VK_ESCAPE) <> 0;
...

Now you can press ENTER and have only one count per press.

HTH.
buho (A).
buho (Programmer) 	
25 Sep 06 8:34
If you are trying to get a hang on Delphi, go straigth to Windows applications.

Console applications have not use except in some very rare market niches, and after mastering Windows applications you'll be better prepared to tackle console ones.

buho (A).
chrknudsen (Programmer) (OP) 	
25 Sep 06 10:51
Thanks for the replies! clown

As to what I expect of the code, I expect it to do exactly what it did when you ran it in 2K. However, as I wrote in my initial post, when I compile and run the program, my console window freezes and doesn't react to keypresses. I've also made similar tests with KeyState, but with the same result (the console window freezes).

My plan is to make an ASCII game, which is why I'm making a console and not a Windows application.

 property BkSpcMode;
    property BorderStyle;
    property CaretBlinkTime;
    property Color;
    property Dispatcher:TAfCustomDataDispatcher read GetDispatcher write SetDispatcher;
    property Ctl3D;
    property DragCursor;
    property DragMode;
    property Enabled;
    property Font;
    property LeftSpace;
    property Logging;
    property LogFlushTime;
    property LogName;
    property LogSize;
    property MaxLineLength;
    property Options;
    property ParentColor;
    property ParentCtl3D;
    property ParentFont;
    property ParentShowHint;
    property PopupMenu;
    property SelectedColor;
    property SelectedStyle;
    property SelectedTextColor;
    property ScrollBackCaret;
    property ScrollBackKey;
    property ScrollBackRows;
   
  RegisterProperty('caption', 'string', iptrW);
  RegisterProperty('LogName', 'string', iptrw);
  RegisterProperty('OnSendChar', 'TKeyPressEvent', iptrw);
  RegisterProperty('CaretBlinkTime', 'TAfCLVCaretBlinkTime', iptrw);
  RegisterProperty('LogFileStream', 'TAfFileStream', iptrw);
  RegisterProperty('LogMemStream', 'TMemoryStream', iptrw);
  RegisterProperty('OnBeepChar', 'TNotifyEvent', iptrw);
  RegisterProperty('OnDrawBuffer', 'TNotifyEvent', iptrw);
  RegisterProperty('OnFlushLog', 'TNotifyEvent', iptrw);

  in async comport writedata also string !
  
  STD_INPUT_HANDLE
   KEY_EVENT:
     
  http://tpapro.sourceforge.net/Faq.html
 
 in win32? 
    Win32Check(GetConsoleMode(StdIn, ConsoleMode));
  Win32Check(SetConsoleMode(StdIn, ConsoleMode and (not ENABLE_ECHO_INPUT)));
 SetConsoleTitle('AsyncFree NonVCL example, press ESC to exit');
 
 Sketch uses 2,510 bytes (7%) of program storage space. Maximum is 32,256 bytes.
Global variables use 189 bytes (9%) of dynamic memory, leaving 1,859 bytes for local variables. Maximum is 2,048 bytes.
 
/*
  Blink2
  Turns on an LED on for one second, then off for one second, repeatedly.
  This example code is in the mX public domain. locs=60
 */
 
// Pin 13 has an LED connected on most Arduino boards.
// give it a name:
int ledR = 11;
int led = 13;
int val = 0;
bool gorun = false;

// setup routine runs once when you press reset:
void setup() {                
  // initialize the digital pin as an output.
  pinMode(led, OUTPUT); 
  pinMode(ledR, OUTPUT); 
  Serial.begin(9600); // connect to serial port  
}

// the loop routine runs over and over again:
void loop() {
  val = Serial.read();
  //Serial.print(val, HEX); show time stream
  //Serial.write(val);
 
  if (val !=-1){ 
   
    if (val == '9')  
     gorun = true;
     else gorun = false;
 
    if (val=='1'){
      digitalWrite(ledR,HIGH);
       //delay(1000);               // wait a sec
      }
    if (val=='A'){
      digitalWrite(ledR,LOW);
      }
    
    if (val=='3'){
      digitalWrite(led,HIGH);
       delay(1000);               // wait for a second
      digitalWrite(led,LOW);
       delay(1000);               // wait for a second
      }
    if (val=='C'){
      digitalWrite(led,LOW);
      }
    Serial.write(val);            // read back to monitor
  }
  
   if (gorun == true) {
   digitalWrite(ledR, HIGH);   // turn LED on (HIGH is the voltage level)
   delay(500);                 // wait for a second
   digitalWrite(ledR, LOW);    // turn LED off by making the voltage LOW
   delay(500);                 // wait for a second
  } 
}
 
 
procedure SIRegister_TAfCustomSerialPort(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TAfDataDispConnComponent', 'TAfCustomSerialPort') do
  with CL.AddClassN(CL.FindClass('TAfDataDispConnComponent'),'TAfCustomSerialPort') do begin
    RegisterMethod('Constructor Create( AOwner : TComponent)');
     RegisterMethod('Procedure Free');
     RegisterMethod('Function ExecuteConfigDialog : Boolean');
     RegisterMethod('Procedure Open');
     RegisterMethod('Procedure Close');
     RegisterMethod('Function InBufUsed : Integer');
    RegisterMethod('Function OutBufFree : Integer');
    RegisterMethod('Function OutBufUsed : Integer');
    RegisterMethod('Procedure PurgeRX');
    RegisterMethod('Procedure PurgeTX');
    RegisterMethod('Function ReadChar : Char');
    RegisterMethod('Procedure ReadData( var Buf, Size : Integer)');
    RegisterMethod('Function ReadString : String');
    RegisterMethod('Function SynchronizeEvent( EventKind : TAfComPortEventKind; Data : TAfComPortEventData; Timeout : Integer) : Boolean');
    RegisterMethod('Procedure WriteChar( C : Char)');
    RegisterMethod('Procedure WriteString( const S : String)');
    RegisterPublishedProperties;
    RegisterProperty('Active', 'Boolean', iptrw);
    RegisterProperty('DCB', 'TDCB', iptrw);
    RegisterProperty('Handle', 'THandle', iptr);
    RegisterProperty('CTSHold', 'Boolean', iptr);
    RegisterProperty('DSRHold', 'Boolean', iptr);
    RegisterProperty('RLSDHold', 'Boolean', iptr);
    RegisterProperty('XOffHold', 'Boolean', iptr);
    RegisterProperty('XOffSent', 'Boolean', iptr);
    RegisterProperty('CTS', 'Boolean', iptr);
    RegisterProperty('DSR', 'Boolean', iptr);
    RegisterProperty('RING', 'Boolean', iptr);
    RegisterProperty('RLSD', 'Boolean', iptr);
  end;
end;
