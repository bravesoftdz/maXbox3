PROGRAM Statistic_Class_Grid_SETTEST;
//shows lotto tips and all the binominal coefficients  


Type 

    TSysteminfo = record
        dwNumberOfProcessors: word;
        wProcessorArchitecture: word; 
      end;  

   procedure GetSystemInfo(lpSystemInfo: TSysteminfo); 
          External 'GetSystemInfo@kernel32.dll stdcall';


Const
   CROW = 5;
   CCOL = 10;
   LotNR = 6;
   LotRANGE = 45;                                                

Type 
   TLottolist = array[1..lotNR] of byte;
   TLottStat = array[1..lotRANGE] of integer;

Var 
//<Variable declarations>
    quadrat,square: extended;
    iz, i, j: integer;
    bigstring: string;
    flable: shortstring;
    larr: TLottolist; 
    comblist: TStringList;
    sGrid1: TStringGrid;  
    mForm: Tform;
//    suit:TShortSuit;


//<FUNCTION> //<PROCEDURE> 

procedure CreateDrawForm;
begin
  mForm:= TForm.create(self);
  with mForm do begin
    FormStyle:= fsStayOnTop;
    Position:= poScreenCenter;
    color:= clred;
    Caption:= 'Max Lotto Coefficient Statistics';
    Width:= 800;
    Height:= 650;
    BorderStyle:= bsDialog;
    //onClose:= @FormClose;
    Show
  end;
  sGrid1:= TStringGrid.Create(self);
  sGrid1.parent:= mForm;
  with sGrid1 do begin
    defaultColwidth:= 60;
    defaultRowheight:= 60;
    height:= 415;
    width:= 755;       
    colcount:= CCOL+1;  
    rowcount:= CROW+1;
    top:= 20;
    borderStyle:= bsNone;
    GridLineWidth:= 8;
    scrollbars:= false;
  end; 
 end;


function TForm1_makecard(L,T:Integer; newvalue:TCardValue; newSuit:TShortSuit):TCard;
{create and set position for a card}
begin
  result:= TCard.Create(mform);
  with result do begin
    parent:= mform;
    top:=T; left:=L;
    setcard(newvalue,newSuit);
    bringToFront;
  end;
end;


procedure cardSetTest;
var suit1,i: integer;
   cards0: array[0..11] of TCard;
   startx,starty:integer;
   suit:TShortSuit;   //  TShortSuit=(CardS,CardD,CardC,CardH);
   suits: set of TShortSuit;
begin
   startx:= 100;
   starty:= 480;
// for suit1:= low(TShortSuit) to high(TShortSuit) do  won't work
  for i:= 11 to 13 do 
   for suit1:= 0 to 3 do begin
     cards0[4*(i-11)+suit1]:= TForm1_makecard(startx,starty,i,TShortSuit(suit1));
     startx:= startx+50;
   end;
   suit:= CardC;
   writeln(inttoStr(high(cards0))) //debug 
   writeln(inttoStr(ord(suit))) 
   writeln(inttoStr(ord(TShortSuit(suit1))))  
end;

procedure putNumbers(vrange: byte);
var ti, z, myrand: byte;
    dup: boolean;
begin
  ti:= 1;
  Randomize
  //if vrange < lotnr then vrange:= 6; 
  repeat
    myrand:= Random(vrange)+1;     
    dup:= false;
    for z:= 1 to lotnr do 
      if (larr[z] = myrand) then dup:= true;
    if (not dup) then begin
      larr[ti]:= myrand;
      //lstat[myrand]:= lstat[myrand] + 1;
      ti:= ti + 1;
    end;
  until ti = lotnr + 1
end;  


procedure FillGrid;
var i: byte;
begin
  j:= 1
  with sGrid1 do begin
    for i:= 1 to lotrange do begin
      for iz:= 1 to lotnr do
        if larr[iz] = i then
          Cells[((i+CCOL-1) mod CCOL)+1, j]:= intToStr(i);
      if i mod CCOL = 0 then
       inc(j)
    end;
    Font.Size:= 40;
    Cells[6,5]:= '!!!';
  end;  
end;


function GetBigIntFact(aval: byte): string;
  //unit mybigint
var mbResult: TMyBigInt;
    i: integer;
begin
  mbResult:= TMyBigInt.Create(1);
  try
    for i:= 1  to aval do 
      //mbResult.Multiply(mbresult, mbresult);
      mbResult.Multiply1(mbresult, i);
    Result:= mbResult.ToString;
  finally 
    //FreeAndNil(mbResult);
    mbResult.Free;
  end;
end;


function getPermutation(npr, k: integer): extended; 
//2. Permutation(Variation without repeating) = nPr = n!/(n-k)!
begin
  result:= (Fact(npr)/Fact(npr-k));
  //test 4 of 10 = 5040 = NPR(10,4)
end;

function getCombination(npr, k: integer): extended; 
//3. Combination (binominal coefficient)= nCr = nPr / k!
begin
  result:= (Fact(npr)/Fact(npr-k)/Fact(k));
  //ncr:= npr/round(fact(ncr))
  //test 4 of 20 = 4845 = NCR(20,4)
end;

function setPrivilege: boolean;
//var tp: TTokenPrivileges;
  //CL.AddTypeS('TTokenPrivileges', '_TOKEN_PRIVILEGES');
  //CL.AddTypeS('TOKEN_PRIVILEGES', '_TOKEN_PRIVILEGES');
 {var macd: TACL;
  CL.AddTypeS('_ACL', 'record AclRevision : Byte; Sbz1 : Byte; AclSize : Word; '
   +'AceCount : Word; Sbz2 : Word; end');
  CL.AddTypeS('TACL', '_ACL');
  CL.AddTypeS('ACL', '_ACL');
  CL.AddTypeS('TAclInformationClass', '( AclInfoPad, AclRevisionInformation, Ac'
   +'lSizeInformation )');  }
begin
  writeln('waitForSingleObject test '+inttoStr(waitForSingleObject(Hinstance, 1000)));
  writeln('getlastError '+inttoStr(getlastError));
  ShowMessage('System Error Message: '+ SysErrorMessage(GetLastError));
  
  {if DeleteFile('CanDeletMe.txt')
  then ShowMessage('File deleted OK')
  else ShowMessage('File not deleted, error code = '+
                   IntToStr(GetLastError)+ SysErrorMessage(GetLastError));}
  Writeln('win32platform test '+ifThen(Win32Platform = VER_PLATFORM_WIN32_NT, 'WinNT','Win anythingX'));                  
  
  writeln('SM_REMOTESESSION test '+inttoStr(GetSystemMetrics(SM_REMOTESESSION)));
 
  RemoveDir('c:\NoSuchFolder') ;
  //ShowMessage('System Error Message: '+ SysErrorMessage(GetLastError)) ;
  writeln('System Error Message: '+ SysErrorMessage(GetLastError)); 
   //FormatMessage 
  //openProcessToken
{  CL.AddDelphiFunction('Function OpenProcessToken( ProcessHandle : THandle; DesiredAccess : DWORD; var TokenHandle : THandle) : BOOL');
 CL.AddDelphiFunction('Function OpenThreadToken( ThreadHandle : THandle; DesiredAccess : DWORD; OpenAsSelf : BOOL; var TokenHandle : THandle) : BOOL');}
{  CL.AddDelphiFunction('Function AdjustTokenPrivileges( TokenHandle : THandle; DisableAllPrivileges : BOOL; const NewState : TTokenPrivileges; BufferLength : DWORD; PreviousState : PTokenPrivileges; var ReturnLength : DWORD) : BOOL;');
 }

end;

  function isService: boolean;
  begin
    result:= NOT(Application is TApplication);
    {result:= Application is TServiceApplication;}
  end;  

  function isNotService: boolean;
  begin
    result:= Application is TApplication;
  end;  

  //SM_REMOTESESSION = $1000
  
  function isTerminalSession: boolean;
  begin
    result:= GetSystemMetrics(SM_REMOTESESSION) > 0;
  end;  
  
  function ExeFileIsRunning(ExeFile: string): boolean;
      var
      H:word;
      begin
      H:= CreateFile(PChar(ExeFile), GENERIC_READ,
      0, 0, OPEN_EXISTING, 0, 0);
      Result:= (H >= 65535);
      CloseHandle(H);
   end;
   
   function GetNumberOfProcessors: longint;
   var
   SystemInfo: TSystemInfo;
   begin
     GetSystemInfo(SystemInfo);
     Result:= SystemInfo.dwNumberOfProcessors;
     Result:= SystemInfo.wProcessorArchitecture; 
    end;
    
    procedure TForm1_StringGrid1DrawCell(Sender: TObject; ACol, ARow: Integer;
                                                   Rect: TRect; State: TGridDrawState);
   var stringgrid1: TStringGrid;
       image1: TImage;
 
   begin
   if ARow = 0 then
     StringGrid1.Canvas.Draw(Rect.Left,Rect.Top, Image1.Picture.Bitmap);
   end;
   
   function GetURLByIndy(const AURL: String): String;
   var
     IdHTTP: TIdHTTP;
   begin
     IdHTTP:= TIdHTTP.Create(nil);
   try
     Result:= IdHTTP.Get(AURL);
   finally
     IdHTTP.Free;
   end;
   end;
   
   function GetFolderDate(Folder: String) : TDateTime;
    var
      Rec: TSearchRec;
      Found: integer;
      Date: TDateTime;
      begin
        if Folder[length(folder)]= '\' then
        Delete(Folder, length(folder), 1);
        Result:= 0;
        Found:= FindFirst(Folder, faDirectory);
      try
      if Found = 0 then begin
         Date:= FileDateToDateTime(searchRecTime);
         result:= Date;
      end;
      finally
         FindClose;
      end;
      end;
      
      Function TForm1_getFileCount: integer;
      var
        DOSerr: integer;
        fsrch: TsearchRec;
      begin
        result:= 0;
        doserr:= FindFirst('*.*',faAnyFile);
      if (DOSerr = 0) then begin
        while (DOSerr = 0) do begin
           if (searchrecattr and faDirectory) = 0 then inc(result);
        DOSerr:= findnext;
      end;
      findClose;
      end;
      end;
      
   function getWinProcessList2:TStringList;
   var
     ContinueLoop: boolean;
     FSnapshotHandle: THandle;
     FProcessEntry32: TProcessEntry32;
     resultstring : string;
     UserName, Domain: AnsiString;
   begin
     Result:=TStringList.Create;
     FSnapshotHandle := CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);
     FProcessEntry32.dwSize := Sizeof(FProcessEntry32);
     ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32);
     while ContinueLoop do begin
       resultstring := '';
       UserName := '';
       domain :='';
       writeln((FProcessEntry32.szExeFile[10]))  //szExeFile[MAX_PATH-1]));
   
       resultstring:= FProcessEntry32.szExeFile[10]+';'
               +IntToStr(FProcessEntry32.th32ProcessID)+';';
       if  GetProcessUserBypid(FProcessEntry32.th32ProcessID,UserName, Domain) then
             resultstring :=  resultstring + Domain+'\'+UserName;
       Result.add(resultstring);
       ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32);
     end;
     CloseHandle(FSnapshotHandle);
   end;
   
      
   procedure TestListView;
   var lsvProcess: TListView;
       FSnapshotHandle: THandle;
       Te32: TTHREADENTRY32;
       FProcessEntry32: TProcessEntry32;//TTHREADENTRY32;
       ContinueLoop: boolean;
       NewItem : TListItem; 
      begin
      lsvProcess.Items.Clear;
      FSnapshotHandle:= CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);
      //Delphi OS Training 2004
      //http://max.kleiner.com 3
      FProcessEntry32.dwSize:= Sizeof(FProcessEntry32);
      ContinueLoop:=Process32First(FSnapshotHandle,FProcessEntry32);
      
      while integer(ContinueLoop)<>0 do begin
        NewItem:= lsvProcess.Items.add;
        NewItem.Caption:= ExtractFileName(FProcessEntry32.szExeFile[MAX_PATH]);
        NewItem.subItems.Add(FProcessEntry32.szExeFile[MAX_PATH]);
        ContinueLoop:= Process32Next(FSnapshotHandle,FProcessEntry32);
      end;
      CloseHandle(FSnapshotHandle);   
    end;


   var dat_e: TDateTime;
 
BEGIN  //Main
//<Executable statements>
  {x:= 100;
  quadrat:= power(x,2); 
  writeln(format('%f', [quadrat]))
  square:= sqrt(quadrat)
  writeln(format('%f', [square]))
  writeln(format('%s',[inttobin(97 XOR 223)]))}

  CreateDrawForm;
  PutNumbers(lotrange)
  FillGrid;  
  
  writeln(floattoStr(getPermutation(45,6)))
  writeln(floattoStr(getCombination(45,6)))
  writeln(floattoStr(getCombination(45,22)))
  comblist:= TStringlist.create;
  for i:= 1 to LotRANGE do
    comblist.add(Format('case: %d is %f',[i, getCombination(45,i)]));
  for i:= 1 to LotRANGE do
    Writeln(comblist[i-1]);
  comblist.Free;  
  for i:= 1 to lotnr do 
    Write(inttostr(larr[i])+ ' ');
    
    cardSetTest;
    
    //maXform1.imglogo.show;
      maXform1.imglogobox.show;
    setPrivilege; 
    writeln('isService: '+BoToStr(isService)); 
    writeln('isNotService: '+BoToStr(isNotService)); 
    writeln('isTerminalSession '+BoToStr(isTerminalSession)); 
    
    writeln(inttoStr(ackermann(3,4)));
    //ExeFileIsRunning(exepath+'maxbox3.exe');
    writeln(inttostr(GetNumberOfProcessors));
    //Memo2.Lines.Text:= GetURLByIndy('http://www.kleiner.ch');
    writeln(datetimetoStr(GetFolderDate(exepath)))
    dat_e:= GetFolderDate(exepath)
    ShowMessage(FormatDateTime('dddd, d. mmmm yyyy, hh:mm:ss', dat_e));
    writeln('TForm1_getFileCount: '+inttoStr(TForm1_getFileCount))
   
    {writeln(inttoStr(getWinProcessList.count)) 
    writeln((getWinProcessList.strings[2])); 
    writeln(getWinProcessList.text)} 
     writeln(getprocesslist.text)
     
End. 

doc:

  typedef struct tagPROCESSENTRY32 {
  DWORD     dwSize;
  DWORD     cntUsage;
  DWORD     th32ProcessID;
  ULONG_PTR th32DefaultHeapID;
  DWORD     th32ModuleID;
  DWORD     cntThreads;
  DWORD     th32ParentProcessID;
  LONG      pcPriClassBase;
  DWORD     dwFlags;
  TCHAR     szExeFile[MAX_PATH];
} PROCESSENTRY32, *PPROCESSENTRY32;


forget the FormatMessage() take the sysErrorMessage!
Convert the OS Error Code into a User Friendly Message
Here's a quick example - trying to delete a non existing folder. RemoveDir deletes an existing empty directory. The return value is true if a new directory was successfully deleted, false if an error occurred. Read GetLastError to find out why an error occurred.

 RemoveDir('c:\NoSuchFolder') ;

 ShowMessage('System Error Message: '+ SysErrorMessage(GetLastError)) 

-----------------------------------------------------
     {for i:= 1 to 10 do
       for j:= 1 to 10 do begin
         //printf('%d',[j])
           write(inttostr(j*i)+ '  ')
           if j=10 then writeln('')
        end
        writeln('')
     for i:= 1 to 10 do
       for j:= 1 to 10 do begin
         //printf('%d',[j])
           ein:= j*i;
           if (ein < 10) and (j<7) then
             write(inttostr(ein)+ '    ')
             else 
             write(inttostr(ein)+ '  ')
          if j=10 then writeln('')
        end}
       // big fact 70 = 1.1978571669969891796072783721689e+100

        
  00000000000000000000000100101100 XOR
  00000000000000000000000100101100
                         000000000

----app_template_loaded----

Corrections of V 3.5 beta

cid:  182  winmemory: Twinmemory
cid:  183  winmemory.#0: TLabel
cid:  184  winmemory_1: Twinmemory
cid:  185  winmemory_1.#0: TLabel


  Dealing with Big Numbers (Integers)
  -----------------------------------
  
  As you may know there's no simple solution to print or store big numbers, for example you want to compute fact(70), your calculator shows:
  fact(70) = 1.1978571669969891796072783721689e+100
  
  but the maximum range on Delphi depends on your operating system types, means nowadays an int64 range is the big int.
  Now that the "signed" Words are finally up-to-par with the unsigned integer types, Delphi 4 introduces a new 64-bits integer type, called Int64, with a whopping range of -2^63..2^63 - 1  

 Another way is to use the type extended, but the limitation is precision like
   
        Writeln(FloatToStr(Fact(70)))
 
    it only shows 
    1.2E+0100

With a BigInt Library (bigintlib) you'll see the full range of Fact(70):

11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000
    
The call respectively the calculation goes like this:

function GetBigIntFact(aval: byte): string;
//call of unit mybigint
var mbRes: TMyBigInt;
    i: integer;
begin
  mbRes:= TMyBigInt.Create(1);
  try
    //multiplication of factor
    for i:= 1  to aval do 
      mbRes.Multiply1(mbresult, i);
    Result:= mbRes.ToString;
  finally 
    //FreeAndNil(mbResult);
    mbRes.Free;
  end;
end;
    
Or you want the power of 100        
2^100=
1267650600228229401496703205376
  
The definition of the function could be the following:

function GetBigIntPower(aval: integer): string;
var mbResult: TMyBigInt;
     i: integer;
begin
  mbResult:= TMyBigInt.Create(1);
  try
    for i:= 1 to aval do 
      mbResult.Multiply1(mbresult, 2);
    Result:= mbResult.ToString;
  finally 
    mbResult.Free;
  end;
end;
  
  
At least one really big, it's 2^1000

10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376


the class of the unit from swiss delphi:

  TMyBigInt = class
  private
    Len: Integer;
    Value: AnsiString;
    procedure Trim;
    procedure Shift(k: Integer);
    procedure MultiplyAtom(Multiplier1: TMyBigInt; Multiplier2: Integer);
  public
    constructor Create(iValue: Integer = 0);
    procedure Add(Addend1, Addend2: TMyBigInt);
    procedure Multiply(Multiplier1, Multiplier2: TMyBigInt); overload;
    procedure Multiply(Multiplier1: TMyBigInt; Multiplier2: Integer); overload;
    function ToString: string;
    procedure CopyFrom(mbCopy: TMyBigInt);
  end;
    
    
    Before the LTO flag commit:

Sketch uses 26,628 bytes (82%) of program storage space. Maximum is 32,256 bytes.
Global variables use 984 bytes (48%) of dynamic memory, leaving 1,064 bytes for local variables. Maximum is 2,048 bytes.

After:

Sketch uses 72,984 bytes (226%) of program storage space. Maximum is 32,256 bytes.
Global variables use 1,222 bytes (59%) of dynamic memory, leaving 826 bytes for local variables. Maximum is 2,048 bytes.


typedef struct tagPROCESSENTRY32 {
Members

dwSize

    The size of the structure, in bytes. Before calling the Process32First function, set this member to sizeof(PROCESSENTRY32). If you do not initialize dwSize, Process32First fails.
cntUsage

    This member is no longer used and is always set to zero.
th32ProcessID

    The process identifier.
th32DefaultHeapID

    This member is no longer used and is always set to zero.
th32ModuleID

    This member is no longer used and is always set to zero.
cntThreads

    The number of execution threads started by the process.
th32ParentProcessID

    The identifier of the process that created this process (its parent process).
pcPriClassBase

    The base priority of any threads created by this process.
dwFlags

    This member is no longer used, and is always set to zero.
szExeFile

    The name of the executable file for the process. To retrieve the full path to the executable file, call the Module32First function and check the szExePath member of the MODULEENTRY32 structure that is returned. However, if the calling process is a 32-bit process, you must call the QueryFullProcessImageName function to retrieve the full path of the executable file for a 64-bit process.
