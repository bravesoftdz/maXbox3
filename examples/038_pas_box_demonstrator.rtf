{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;\red255\green255\blue255;\red0\green128\blue128;\red255\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Untitled}}
\deflang1033\pard\plain\f0\fs20 \cf0\i //(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((()
\par //calculates a cipher suite from string & generates lotto numbers
\par //DEMONSTRATES maXbox with use of INCLUDE & DLL; _38, loc's =185
\par //V2.1 with relative file path to /examples
\par //(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((()
\par 
\par 
\par \i0\cf1 program\cf2  \cf1 maXbox_Demonstrator_CODESIGN_Show;
\par 
\par function\cf2  \cf1 _SayHello2:\cf2  \cf1 boolean;
\par external\cf2  \cf3 '_SayHello2@income.dll stdcall'\cf1 ;
\par 
\par \b const
\par \b0\cf2   \cf0\i //something to enlarge the entropy like substitution-box
\par \i0\cf2   \cf1 C1\cf2  \cf1 =\cf2  \cf4 52845\cf1 ;
\par \cf2   \cf1 C2\cf2  \cf1 =\cf2  \cf4 22719\cf1 ;\cf2  
\par   \cf1 MYKEY\cf2  \cf1 =\cf2  \cf4 16549813\cf1 ;
\par \cf2   \cf1 LOTNUMB\cf2  \cf1 =\cf2  \cf4 6\cf1 ;
\par \cf2   \cf1 LOTRANGE\cf2  \cf1 =\cf2  \cf4 45\cf1 ;
\par \cf2   \cf1 FNAME\cf2  \cf1 =\cf2  \cf3 'readmefirst_maxbox.txt'\cf1 ;
\par \cf2   \cf1 CIPHERNAME\cf2  \cf1 =\cf2  \cf3 'crypto_readmefirst.txt'\cf1 ;
\par 
\par type\cf2  
\par   \cf1 TLottoList\cf2  \cf1 =\cf2  \cf1 array[\cf4 1\cf1 ..LOTNUMB]\cf2  \cf1 of\cf2  \cf1 byte;
\par \cf2   \cf1 T_Status\cf2  \cf1 =(success,\cf2  \cf1 failure,\cf2  \cf1 pending);
\par \cf2   \cf1 TPasStyle\cf2  \cf1 =\cf2  \cf1 (a,b,c,d,e,f);
\par \cf2   \cf1 TPasStyles\cf2  \cf1 =\cf2  \cf1 set\cf2  \cf1 of\cf2  \cf1 TPasStyle;
\par \cf2    
\par \cf1 var\cf2  
\par   \cf1 TPas:\cf2  \cf1 TPasStyles;
\par \cf2   \cf0\i //XLApp: Variant;
\par \i0\cf2   \cf1 FNAME_PATH,\cf2  \cf1 CIPHERNAME_PATH:\cf2  \cf1 string;
\par 
\par 
\par \{\cf4 $\cf1 I\cf2  \cf1 maxdefine.inc\}
\par 
\par \{\cf4 $\cf1 I\cf2  \cf1 pas_includebox.inc\}
\par 
\par 
\par \cf0\i //-------------------cryptor service---------------------//
\par 
\par \i0\cf1 function\cf2  \cf1 EncryptDecrypt(\b const\b0\cf2  \cf1 S:\cf2  \cf1 string;\cf2  \cf1 Key:\cf2  \cf1 word;\cf2  \cf1 mode:\cf2  \cf1\b char\b0 ):\cf2  \cf1 string;
\par var
\par \cf2   \cf1 i,\cf2  \cf1 myint:\cf2  \cf1 word;
\par begin
\par \cf2   \cf1 SetLength(Result,\cf2  \cf1 length(s));
\par \cf2   \cf0\i //cipher in order of ord ;)
\par \i0\cf2   \cf1\b for\b0\cf2  \cf1 i:=\cf2  \cf4 1\cf2  \cf1 to\cf2  \cf1 Length(S)\cf2  \cf1\b do\b0\cf2  \cf1 begin
\par \cf2     \cf1 myint:=\cf2  \cf1 ord(S[i])\cf2  \cf1 xor\cf2  \cf1 (Key\cf2  \cf1 shr\cf2  \cf4 8\cf1 )
\par \cf2     \cf1 Result[i]:=\cf2  \cf1 chr(myint);
\par \cf2     \cf1\b if\b0\cf2  \cf1 mode\cf2  \cf1 =\cf2  \cf3 'E'\cf2  \cf1 then
\par \cf2       \cf1 Key:=\cf2  \cf1 (ord(Result[i])\cf2  \cf1 +\cf2  \cf1 Key)\cf2  \cf1 *\cf2  \cf1 C1\cf2  \cf1 +\cf2  \cf1 C2;
\par \cf2     \cf1\b if\b0\cf2  \cf1 mode\cf2  \cf1 =\cf2  \cf3 'D'\cf2  \cf1 then\cf2  
\par       \cf1 Key:=\cf2  \cf1 (ord(S[i])\cf2  \cf1 +\cf2  \cf1 Key)\cf2  \cf1 *\cf2  \cf1 C1\cf2  \cf1 +\cf2  \cf1 C2;
\par \cf2   \cf1 end;
\par end;
\par 
\par procedure\cf2  \cf1 StringToFile(acontent,\cf2  \cf1 afilename:string);
\par begin
\par \cf2  \cf1 with\cf2  \cf1 TFileStream.Create(afilename,\cf2  \cf1 fmOpenWrite\cf2  \cf1 or\cf2  \cf1 fmCreate)\cf2  \cf1\b do\b0\cf2  \cf1 begin
\par \cf2    \cf1\b try
\par \b0\cf2      \cf1 Write(acontent,\cf2  \cf1 length(acontent));
\par \cf2    \cf1 finally
\par \cf2      \cf1 Free;
\par \cf2    \cf1 end
\par \cf2  \cf1 end\cf2   
\par \cf1 end;
\par 
\par function\cf2  \cf1 FileToString(afilename:\cf2  \cf1 string):string;
\par begin
\par \cf2  \cf1 with\cf2  \cf1 TFileStream.Create(afilename,\cf2  \cf1 fmOpenRead\cf2  \cf1 or\cf2  \cf1 fmShareCompat)\cf2  \cf1\b do\b0\cf2  \cf1 begin
\par \cf2    \cf1\b try\b0\cf2  
\par      \cf1 SetLength(result,\cf2  \cf1 Size);
\par \cf2      \cf1 Read(result,\cf2  \cf1 Size);
\par \cf2    \cf1 finally\cf2  
\par      \cf1 Free;
\par \cf2    \cf1 end\cf2   
\par  \cf1 end
\par end;
\par 
\par function\cf2  \cf1 StartLoadService:\cf2  \cf1 TStringList;
\par begin
\par \cf2   \cf1\b if\b0\cf2  \cf1 fileExists(FNAME_PATH)\cf2  \cf1 then\cf2  \cf1 begin
\par \cf2     \cf1 result:=\cf2  \cf1 TStringList.create;
\par \cf2     \cf1 result.loadfromfile(FNAME_PATH);
\par \cf2   \cf1 end
\par end;\cf2     
\par 
\par \cf0\i //-------------------lotto generator---------------------//
\par 
\par \i0\cf1 function\cf2  \cf1 initArray(var\cf2  \cf1 larray:\cf2  \cf1 TLottoList):\cf2  \cf1 boolean;
\par var\cf2  \cf1 i:\cf2  \cf1 byte;
\par begin
\par \cf2  \cf1\b for\b0\cf2  \cf1 i:=\cf2  \cf4 1\cf2  \cf1 to\cf2  \cf1 LOTNUMB\cf2  \cf1\b do\b0\cf2  
\par    \cf1 larray[i]:=\cf2  \cf4 0\cf1 ;
\par \cf2   \cf1 result:=\cf2  \cf1\b true
\par \b0 end;
\par 
\par procedure\cf2  \cf1 putNumbers(vrange:\cf2  \cf1 byte;\cf2  \cf1 var\cf2  \cf1 larray:\cf2  \cf1 TLottoList);
\par var\cf2  \cf1 ti,\cf2  \cf1 z,\cf2  \cf1 myrand,\cf2  \cf1 sum:\cf2  \cf1 byte;
\par \cf2     \cf1 dup:\cf2  \cf1 boolean;
\par begin
\par \cf2   \cf1 ti:=\cf2  \cf4 1\cf1 ;
\par \cf2   \cf1 sum:=\cf2  \cf4 0\cf1 ;
\par \cf2   \cf1 Randomize;
\par \cf2   \cf0\i //precondition set by validation
\par \i0\cf2   \cf1\b if\b0\cf2  \cf1 vrange\cf2  \cf1 <\cf2  \cf1 LOTNUMB\cf2  \cf1 then\cf2  \cf1 vrange:=\cf2  \cf4 6\cf1 ;\cf2  
\par   \cf1 repeat
\par \cf2     \cf1 myrand:=\cf2  \cf1 Random(vrange)+\cf2  \cf4 1\cf1 ;\cf2      
\par     \cf1 dup:=\cf2  \cf1\b false\b0 ;
\par \cf2     \cf1\b for\b0\cf2  \cf1 z:=\cf2  \cf4 1\cf2  \cf1 to\cf2  \cf1 LOTNUMB\cf2  \cf1\b do\b0\cf2  
\par       \cf1\b if\b0\cf2  \cf1 (larray[z]\cf2  \cf1 =\cf2  \cf1 myrand)\cf2  \cf1 then\cf2  \cf1 dup:=\cf2  \cf1\b true\b0 ;
\par \cf2     \cf1\b if\b0\cf2  \cf1 (not\cf2  \cf1 dup)\cf2  \cf1 then\cf2  \cf1 begin
\par \cf2       \cf1 larray[ti]:=\cf2  \cf1 myrand;
\par \cf2       \cf1 ti:=\cf2  \cf1 ti\cf2  \cf1 +\cf2  \cf4 1\cf1 ;
\par \cf2       \cf1 sum:=\cf2  \cf1 sum\cf2  \cf1 +\cf2  \cf1 myrand
\par \cf2     \cf1 end;
\par \cf2   \cf0\i //postcondition & proof
\par \i0\cf2   \cf1 until\cf2  \cf1 ti\cf2  \cf1 =\cf2  \cf1 LOTNUMB\cf2  \cf1 +\cf2  \cf4 1
\par \cf2   \cf1 writeln(\cf3 'sum of numbers: '\cf2  \cf1 +\cf2  \cf1 intToStr(sum))
\par end;\cf2   
\par 
\par \cf1 procedure\cf2  \cf1 viewNumbers(larray:\cf2  \cf1 TLottoList);
\par var\cf2  \cf1 i:\cf2  \cf1 byte;
\par begin
\par \cf2  \cf1\b for\b0\cf2  \cf1 i:=\cf2  \cf4 1\cf2  \cf1 to\cf2  \cf1 LOTNUMB\cf2  \cf1\b do
\par \b0\cf2    \cf1 showMessage(\cf3 'lottonumber '\cf1 +inttostr(i)\cf2  \cf1 +\cf3 ': '\cf1 +inttostr(larray[i]))
\par end;
\par 
\par function\cf2  \cf1 startLottoService(lotrange:\cf2  \cf1 byte):\cf2  \cf1 T_Status;
\par var\cf2  \cf1 larray:\cf2  \cf1 TLottoList;
\par begin
\par \cf2   \cf1 result:=\cf2  \cf1 failure;\cf2   
\par   \cf1\b if\b0\cf2  \cf1 initArray(larray)\cf2  \cf1 then\cf2  \cf1 begin
\par \cf2     \cf1 putNumbers(LOTRANGE,\cf2  \cf1 larray)
\par \cf2     \cf1 viewNumbers(larray);
\par \cf2     \cf1 result:=\cf2  \cf1 success
\par \cf2   \cf1 end;
\par end;\cf2  
\par 
\par \cf0\i //-------------------lotto generator---------------------//
\par 
\par \i0\cf1 var
\par \cf2   \cf1 mycipher,\cf2  \cf1 cipherback:\cf2  \cf1 string;
\par \cf2   
\par \cf1 begin
\par \cf2   \cf1 FNAME_PATH:=\cf2  \cf1 ExePath+\cf3 'examples\\'+FNAME;
\par \cf2   \cf1 CIPHERNAME_PATH:=\cf2  \cf1 ExePath+\cf3 'examples\\'+CIPHERNAME;
\par \cf2   
\par   \cf1 showMessage(\cf3 'first you have seen the two include files: '\cf4 #13\cf2  \cf4 #10
\par \cf2                \cf1 +\cf3 '\{$I maxdefine.inc\} and \{$I pas_includebox.inc\}'\cf2  \cf4 #13\cf2  \cf4 #10
\par \cf2                \cf1 +\cf3 ' then you will see 6 lotto numbers:'\cf1 );
\par \cf2   \cf1\b if\b0\cf2  \cf1 startLottoService(lotrange)\cf2  \cf1 =\cf2  \cf1 success\cf2  \cf1 then
\par \cf2     \cf1 writeln(\cf3 'lotto service get at: '\cf2  \cf1 +\cf2  \cf1 TimeToStr(Time))\cf2  \cf1\b else
\par \b0\cf2     \cf1 writeln(\cf3 'bad news from service: '\cf2  \cf1 +\cf2  \cf1 TimeToStr(Time));
\par \cf2   \cf1 showMessage(\cf3 'now a hash from "maxland" a include function: '\cf2  
\par                                          \cf1 +intToStr(hash2(\cf3 'maxland'\cf1 )));
\par \cf2   \cf0\i //first encrypt loaded file and store it
\par \i0\cf2   \cf1 showMessage(\cf3 'so now maXbox is to cipher the file '\cf1 +FNAME_PATH);
\par \cf2   \cf1\b try\b0\cf2  
\par     \cf1 mycipher:=\cf2  \cf1 encryptDecrypt(StartLoadService.text,\cf2  \cf1 MYKEY,\cf2  \cf3 'E'\cf1 )
\par \cf2       \cf1 StringToFile(mycipher,\cf2  \cf1 CIPHERNAME_PATH)
\par \cf2     \cf0\i //second decrypt file and store it back
\par \i0\cf2     \cf1 cipherback:=\cf2  \cf1 FileToString(CIPHERNAME_PATH);
\par \cf2     \cf1\b if\b0\cf2  \cf1 length(mycipher)\cf2  \cf1 =\cf2  \cf1 length(cipherback)\cf2  \cf1 then\cf2  \cf1 begin
\par \cf2       \cf1 writeln(encryptDecrypt(cipherback,\cf2  \cf1 MYKEY,\cf2  \cf3 'D'\cf1 ))
\par \cf2       \cf1 StringToFile(encryptDecrypt(cipherback,\cf2  \cf1 MYKEY,\cf2  \cf3 'D'\cf1 ),\cf2  \cf1 FNAME_PATH)
\par \cf2     \cf1 end;\cf2   
\par   \cf1 finally\cf2  
\par     \cf0\i //fileList.free; is just missing!!
\par \i0\cf2     \cf1 beep2(\cf4 444\cf1 ,\cf2  \cf4 400\cf1 )
\par \cf2   \cf1 end
\par \cf2    \cf1 showMessage(\cf3 'then we call a C++ dll function: '\cf1 )
\par \cf2    \cf0\i //from C++ DLL
\par \i0\cf2    \cf1\b if\b0\cf2  \cf1 _SayHello2\cf2  \cf1 then
\par \cf2      \cf1 writeln(\cf3 'dll invocation realised'\cf1 );
\par \cf2    \cf0\i //from include file
\par \i0\cf2    \cf1 showMessage(\cf3 'and at last some include routines: '\cf1 )
\par \cf2    \cf1 write(floatToStr(intToFloat(\cf4 2346\cf1 )));
\par \cf2    \cf1 write(\cf3 ' run forest run: '\cf1 )
\par \cf2    \cf1 write(intToHex(\cf4 111123\cf1 ,\cf4 8\cf1 ))
\par \cf2    \cf0\i //write('this one liner')  
\par \i0\cf2    \cf1 writeln(AddThousandSeparator(\cf3 '400500210'\cf1 ,\cf2  \cf3 ''''\cf1 ));
\par \cf2    \cf1 showAboutBox;\cf2  
\par \cf1 end.
\par 
\par \b void\b0\cf2  \cf1\b __stdcall\b0\cf2  \cf1 FreeObject()\cf2  
\par   \cf1 \{\cf2  
\par     \cf1\b delete\b0\cf2  \cf1\b this\b0\cf2  \cf1 ;\cf2  
\par   \cf1 \}\cf2  
\par 
\par }