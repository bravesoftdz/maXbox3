{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;\red255\green0\blue0;\red0\green128\blue128;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Untitled}}
\deflang1033\pard\plain\f0\fs20 \cf0\b PROGRAM\b0\cf1  DataGrid_2\cf2 ;
\par 
\par \cf0\i ///////////////////////////////////////////////////////////////////////////
\par //  #sign:max: APSN21: 31.01.2014 23:10:08 
\par //  Purpose: how to call a dll function, still on progress  
\par //  #path>ples\\E:\\maxbox\\maxbox3\\examples\\                                
\par //  Lines of Code #locs:518
\par ///////////////////////////////////////////////////////////////////////////
\par 
\par \i0\b Const\b0\cf1  TEXTOUT \cf2 =\cf1  \cf3 'hi world of dll func in opcode '\cf2 ;
\par 
\par \cf0\i //############################################################################
\par // Archimedes DLL Architect
\par //############################################################################
\par //TODO: Button with stop event, change color and save bitmap as png
\par \i0\cf1   \cf0\i //TODO: transfer the App to a dll stub function!
\par \i0\cf1   \cf0\i //\{ TODO : the following line looks like a bug... \}
\par 
\par \i0\b type
\par \b0\cf1  TAppData \cf2 =\cf1  \cf0\b record
\par \b0\cf1    Name\cf2 :\cf1  \cf0\b shortstring\b0\cf2 ;
\par \cf1    Size\cf2 :\cf1  longint\cf2 ;
\par \cf1    Release\cf2 :\cf1  \cf0\b shortstring\b0\cf2 ;
\par \cf1    descript\cf2 :\cf1  \cf0\b shortstring\b0\cf2 ;
\par \cf1  \cf0\b end\b0\cf2 ;
\par 
\par 
\par \cf0\i \{type  
\par   PROCESS_MEMORY_COUNTERS = record
\par     cb : DWORD;
\par     PageFaultCount : DWORD;
\par     PeakWorkingSetSize : DWORD;
\par     WorkingSetSize : DWORD; //Task managers MemUsage number
\par     QuotaPeakPagedPoolUsage : DWORD;
\par     QuotaPagedPoolUsage : DWORD;
\par     QuotaPeakNonPagedPoolUsage : DWORD;
\par     QuotaNonPagedPoolUsage : DWORD;
\par     PagefileUsage : DWORD; //TaskMan's VM Size number
\par     PeakPagefileUsage : DWORD;
\par   end;
\par   TProcessMemoryCounters = PROCESS_MEMORY_COUNTERS;\}
\par \i0\cf1   
\par   \cf0\i \{ _OSVERSIONINFOA = record
\par     dwOSVersionInfoSize: DWORD;
\par     dwMajorVersion: DWORD;
\par     dwMinorVersion: DWORD;
\par     dwBuildNumber: DWORD;
\par     dwPlatformId: DWORD;
\par     szCSDVersion: array[0..127] of AnsiChar; \{ Maintenance AnsiString for PSS usage \}
\par \i0\cf1   \cf0\i \{end;
\par  //TIntegerList
\par  //var aos: TOSVersionInfo;
\par 
\par //  function  \{**************************************************\}
\par \i0\b function\b0\cf1  GetProcessMemoryInfo\cf2 (\cf1 Process\cf2 :\cf1  THandle\cf2 ;\cf1  \cf0\b var\b0\cf1  MemoryCounters\cf2 :\cf1  TProcessMemoryCounters\cf2 ;
\par \cf1                                     cb\cf2 :\cf1  DWORD\cf2 ):\cf1  BOOL\cf2 ;\cf1  \cf0\i //stdcall;; 
\par \i0\cf1      \cf0\b External\b0\cf1  \cf3 'GetProcessMemoryInfo@psapi.dll stdcall'\cf2 ;
\par \cf1      
\par  \cf0\b Function\b0\cf1  OpenProcess2\cf2 (\cf1 dwDesiredAccess\cf2 :\cf1  DWORD\cf2 ;\cf1  bInheritHandle\cf2 :\cf1 BOOL\cf2 ;\cf1  dwProcessId\cf2 :\cf1  DWORD\cf2 ):\cf1 THandle\cf2 ;
\par \cf1      \cf0\b External\b0\cf1   \cf3 'OpenProcess@kernel32.dll stdcall'\cf2 ;
\par 
\par 
\par \cf0\i \{TYPE <Type declarations>\}\i0\cf1  
\par   \cf0\b var\b0\cf1  FWait\cf2 ,\cf1  switch\cf2 :\cf1  Boolean\cf2 ;
\par \cf1       FValueA\cf2 ,\cf1  FValueB\cf2 :\cf1  Float\cf2 ;
\par \cf1       \cf0\i //asd: TDoubleArray;
\par \i0\cf1     aGrid\cf2 :\cf1  TStringGrid\cf2 ;
\par \cf1     app\cf2 :\cf1  TAppData\cf2 ;
\par \cf1     f\cf2 :\cf1  Text\cf2 ;\cf1  \cf0\i \{file of\}\i0\cf1  \cf0\i //TAppData;
\par \i0\cf1     FaDatfile\cf2 :\cf1  \cf0\b String\b0\cf2 ;
\par \cf1     Fmodified\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     myrec\cf2 :\cf1  TSearchrec\cf2 ;
\par \cf1     \cf0\i //file: dwstestbin
\par \i0\cf1   
\par      
\par \cf0\i //<FUNCTION>
\par //<PROCEDURE> 
\par 
\par \i0\b procedure\b0\cf1  TBuildAppGrid_fillGrid\cf2 ;
\par \cf0\b var
\par \b0\cf1   crow\cf2 :\cf1  Integer\cf2 ;
\par \cf1   \cf0\i //UTF8FileHeader: integer;
\par \i0\cf1   \cf0\i //ad: UTF8FileHeader
\par \i0\cf1   mss\cf2 :\cf1  TCopyFileFlag\cf2 ;\cf1  \cf0\i //, TFileIterator, TFileSearcher;
\par \i0\b begin
\par \b0\cf1   crow \cf2 :=\cf1  \cf2 1;
\par \cf1   \cf0\b with\b0\cf1  aGrid \cf0\b do\b0\cf1  \cf0\b begin
\par \b0\cf1     Cells\cf2 [0,0]:=\cf1  \cf3 'Application Name'\cf2 ;
\par \cf1     ColWidths\cf2 [0]:=\cf1  \cf2 120;
\par \cf1     Cells\cf2 [1,0]:=\cf1  \cf3 'App Size'\cf2 ;
\par \cf1     ColWidths\cf2 [1]:=\cf1  \cf2 60;
\par \cf1     Cells\cf2 [2,0]:=\cf1  \cf3 'Release Date'\cf2 ;
\par \cf1     ColWidths\cf2 [2]:=\cf1  \cf2 90;
\par \cf1     Cells\cf2 [3,0]:=\cf1  \cf3 'Description'\cf2 ;
\par \cf1     ColWidths\cf2 [3]:=\cf1  \cf2 140;
\par \cf1     \cf0\b if\b0\cf1  FaDatFile \cf2 <>\cf1  \cf3 ''\cf1  \cf0\b then\b0\cf1  \cf0\b begin
\par \b0\cf1       \cf0\i //AssignFileRead(f,FaDatFile);
\par \i0\cf1       \cf0\i //AssignFile(f,FaDatFile);
\par \i0\cf1       \cf0\i //findfirst
\par \i0\cf1       \cf0\i //findfirstutf8
\par \i0\cf1       \cf0\i //findfirst2
\par \i0\cf1       \cf0\i //ReadFileToString
\par \i0\cf1         \cf0\i //keypressed
\par \i0\cf1         \cf0\i //findnext2
\par \i0\cf1         \cf0\i //findclose
\par \i0\cf1        \cf0\i // Reset2(f);
\par \i0\cf1        \cf0\i //reset2
\par \i0\cf1       \cf0\b try
\par \b0\cf1         \cf0\i //while not Eof(F) do begin
\par \i0\cf1           \cf0\i //Read (F, app);
\par \i0\cf1           Cells\cf2 [0,\cf1 crow\cf2 ]:=\cf1  app\cf2 .\cf1 Name\cf2 ;
\par \cf1           Cells\cf2 [1,\cf1 crow\cf2 ]:=\cf1  intToStr\cf2 (\cf1 app\cf2 .\cf1 size\cf2 );
\par \cf1           Cells\cf2 [2,\cf1 crow\cf2 ]:=\cf1  app\cf2 .\cf1 Release\cf2 ;
\par \cf1           Cells\cf2 [3,\cf1 crow\cf2 ]:=\cf1  app\cf2 .\cf1 descript\cf2 ;
\par \cf1           Inc\cf2 (\cf1 cRow\cf2 );
\par \cf1           RowCount\cf2 :=\cf1  crow \cf2 +1;\cf1   \cf0\i //new entry
\par \i0\cf1         \cf0\i //end;
\par \i0\cf1       \cf0\b finally
\par \b0\cf1         \cf0\i //CloseFile(f);
\par \i0\cf1       \cf0\b end\b0\cf2 ;
\par \cf1     \cf0\b end\b0\cf2 ;\cf0\i // if FileExists...
\par \i0\cf1   \cf0\b end\b0\cf2 ;\cf1  \cf0\i //with
\par \i0\b end\b0\cf2 ;
\par 
\par 
\par \cf0\b var\b0\cf1   nYear\cf2 ,
\par \cf1   nMonth\cf2 ,
\par \cf1   nDay\cf2 ,
\par \cf1   fcounter\cf2 :\cf1  word\cf2 ;
\par \cf1   dflistView\cf2 :\cf1  TListBox\cf2 ;
\par \cf1   
\par \cf0\b procedure\b0\cf1  \cf0\i \{constructor\}\i0\cf1  TChangeFinder_Create_prepList_and_Date\cf2 (\cf1 alistView\cf2 :\cf1  TListBox\cf2 );
\par \cf0\b begin
\par \b0\cf1   \cf0\i //GetDate(Year, Month, Day, DayofWeek);
\par \i0\cf1   \cf0\i //now date is to slow
\par \i0\cf1   \cf0\i //inherited Create;
\par \i0\cf1   dflistView\cf2 :=\cf1  alistView\cf2 ;
\par \cf1   decodedate\cf2 (\cf1 date\cf2 ,\cf1  nyear\cf2 ,\cf1  nmonth\cf2 ,\cf1  nday\cf2 );
\par \cf1     dflistView\cf2 .\cf1 items\cf2 .\cf1 insert\cf2 (0,\cf1  format\cf2 (\cf3 '%-120s %10s -%5s'\cf2 ,
\par \cf1        \cf2 [\cf3 'Filename:'\cf2 ,\cf1  \cf3 'Size:'\cf2 ,\cf1  \cf3 'Time:'\cf2 ]));
\par \cf1      fcounter\cf2 :=\cf1  \cf2 1;
\par \cf1   \cf0\b with\b0\cf1  alistView\cf2 .\cf1 Items \cf0\b do\b0\cf1  \cf0\b begin
\par \b0\cf1     BeginUpdate\cf2 ;
\par \cf1     Clear\cf2 ;
\par \cf1     EndUpdate\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par \cf1   
\par       \cf0\i //faDirectory = $00000010;
\par \i0\cf1       \cf0\i //faAnyFile   = $0000003F;   
\par 
\par 
\par \i0\b PROCEDURE\b0\cf1  TChangeFinder_ShowFiles\cf2 (\cf1 Showpath\cf2 :\cf1  \cf0\b STRING\b0\cf2 ;\cf1  sr\cf2 :\cf1  TSearchRec\cf2 );
\par \cf0\b VAR
\par \b0\cf1   arcdisp\cf2 :\cf1  \cf0\b shortSTRING\b0\cf2 ;
\par \cf1   DateRec\cf2 :\cf1  TDateTime\cf2 ;
\par \cf1   lenStr\cf2 ,
\par \cf1   insertStr\cf2 ,
\par \cf1   fname\cf2 ,
\par \cf1   fext\cf2 ,\cf1  outPutStr\cf2 :\cf1  \cf0\b string\b0\cf2 ;
\par \cf1   len      \cf2 :\cf1  BYTE\cf2 ;
\par \cf1   AYear\cf2 ,\cf1  AMonth\cf2 ,\cf1  ADay\cf2 :\cf1  Word\cf2 ;
\par \cf1   aHour\cf2 ,\cf1  aMin\cf2 ,\cf1  aSec\cf2 ,\cf1  aMsec\cf2 :\cf1  word\cf2 ;
\par 
\par \cf0\b BEGIN
\par \b0\cf1   \cf0\i //IF sr.Attr IN [$8..$F] \{, $28..$2F]\} THEN BEGIN
\par \i0\cf1     \cf0\b IF\b0\cf1  Pos\cf2 (\cf3 '.'\cf2 ,\cf1  sr\cf2 .\cf1 Name\cf2 )\cf1  \cf2 >\cf1  \cf2 0\cf1  \cf0\b THEN
\par \b0\cf1       Delete\cf2 (\cf1 sr\cf2 .\cf1 Name\cf2 ,\cf1  Pos\cf2 (\cf3 '.'\cf2 ,\cf1  sr\cf2 .\cf1 Name\cf2 ),\cf1  \cf2 1);
\par \cf1   \cf0\i //END;
\par \i0\cf1   \cf0\b IF\b0\cf1  \cf2 (\cf1 Pos\cf2 (\cf3 '.'\cf2 ,\cf1  sr\cf2 .\cf1 Name\cf2 )\cf1  \cf2 >\cf1  \cf2 0)\cf1  \cf0\b AND\b0\cf1  \cf2 (\cf1 Length\cf2 (\cf1 sr\cf2 .\cf1 Name\cf2 )\cf1  \cf2 >\cf1  \cf2 0)\cf1  \cf0\b THEN\b0\cf1  \cf0\b begin
\par \b0\cf1     fname\cf2 :=\cf1  Copy\cf2 (\cf1 sr\cf2 .\cf1 Name\cf2 ,\cf1  \cf2 1,\cf1  Pos\cf2 (\cf3 '.'\cf2 ,\cf1  sr\cf2 .\cf1 Name\cf2 )\cf1  \cf2 -\cf1  \cf2 1);
\par \cf1     fext\cf2 :=\cf1  sr\cf2 .\cf1 Name\cf2 ;
\par \cf1     Delete\cf2 (\cf1 fext\cf2 ,\cf1  \cf2 1,\cf1  Pos\cf2 (\cf3 '.'\cf2 ,\cf1  fext\cf2 ));
\par \cf1   \cf0\b END\b0\cf1  \cf0\b ELSE\b0\cf1  \cf0\b BEGIN
\par \b0\cf1     fname\cf2 :=\cf1  sr\cf2 .\cf1 Name\cf2 ;
\par \cf1     fext\cf2 :=\cf1  \cf3 '  '\cf2 ;
\par \cf1   \cf0\b END\b0\cf2 ;
\par \cf1   arcdisp\cf2 :=\cf1  \cf3 '    '\cf2 ;
\par \cf0\i //&&\{$WARN SYMBOL_PLATFORM OFF\}
\par \i0\cf1   \cf0\b IF\b0\cf1  sr\cf2 .\cf1 Attr \cf0\b AND\b0\cf1  faArchive  \cf2 =\cf1  faArchive  \cf0\b THEN\b0\cf1  arcdisp\cf2 [1]\cf1  \cf2 :=\cf1  \cf3 'A'\cf2 ;
\par \cf1   \cf0\b IF\b0\cf1  sr\cf2 .\cf1 Attr \cf0\b AND\b0\cf1  faReadOnly \cf2 =\cf1  faReadOnly \cf0\b THEN\b0\cf1  arcdisp\cf2 [2]\cf1  \cf2 :=\cf1  \cf3 'R'\cf2 ;
\par \cf1   \cf0\b IF\b0\cf1  sr\cf2 .\cf1 Attr \cf0\b AND\b0\cf1  faHidden   \cf2 =\cf1  faHidden   \cf0\b THEN\b0\cf1  arcdisp\cf2 [3]\cf1  \cf2 :=\cf1  \cf3 'H'\cf2 ;
\par \cf1   \cf0\b IF\b0\cf1  sr\cf2 .\cf1 Attr \cf0\b AND\b0\cf1  faSysFile  \cf2 =\cf1  faSysFile  \cf0\b THEN\b0\cf1  arcdisp\cf2 [4]\cf1  \cf2 :=\cf1  \cf3 'S'\cf2 ;
\par \cf0\i //\{$WARN SYMBOL_PLATFORM ON\}
\par \i0\cf1   \cf0\i //8..15, 40..47
\par \i0\cf1   \cf0\i //IF NOT (sr.Attr IN [$8..$F, $28..$2F]) THEN BEGIN
\par \i0\cf1     \cf0\i //Str(sr.Size, lenStr);
\par \i0\cf1     \cf0\b IF\b0\cf1  Length\cf2 (\cf1 lenStr\cf2 )\cf1  \cf2 >\cf1  \cf2 3\cf1  \cf0\b THEN\b0\cf1  \cf0\b BEGIN
\par \b0\cf1       insertStr\cf2 :=\cf1  \cf3 '.'\cf2 ;
\par \cf1       len\cf2 :=\cf1  Length\cf2 (\cf1 lenStr\cf2 )\cf1  \cf2 -\cf1  \cf2 2;
\par \cf1       Insert\cf2 (\cf1 insertStr\cf2 ,\cf1  lenStr\cf2 ,\cf1  len\cf2 );
\par \cf1       \cf0\b IF\b0\cf1  Length\cf2 (\cf1 lenStr\cf2 )\cf1  \cf2 >\cf1  \cf2 7\cf1  \cf0\b THEN\b0\cf1  \cf0\b BEGIN
\par \b0\cf1         len\cf2 :=\cf1  Length\cf2 (\cf1 lenStr\cf2 )\cf1  \cf2 -\cf1  \cf2 6;
\par \cf1         Insert\cf2 (\cf1 insertStr\cf2 ,\cf1  lenStr\cf2 ,\cf1  len\cf2 );
\par \cf1       \cf0\b END\b0\cf2 ;
\par \cf1     \cf0\b END\b0\cf2 ;
\par \cf1   \cf0\i //END;
\par \i0\cf1   \cf0\i //IF NOT (sr.Attr IN [$8..$F, $28..$2F]) THEN BEGIN
\par \i0\cf1    \cf0\i //check the system now date
\par \i0\cf1     dateRec\cf2 :=\cf1  FileDatetoDateTime\cf2 (\cf1 sr\cf2 .\cf1 Time\cf2 );
\par \cf1     DecodeDate\cf2 (\cf1 dateRec\cf2 ,\cf1  AYear\cf2 ,\cf1  AMonth\cf2 ,\cf1  ADay\cf2 );
\par \cf1     DecodeTime\cf2 (\cf1 dateRec\cf2 ,\cf1  aHour\cf2 ,\cf1  aMin\cf2 ,\cf1  aSec\cf2 ,\cf1  aMsec\cf2 );\cf1  \cf0\i //new 1.8
\par \i0\cf1     \cf0\i //daterec:= now;  //testroutine
\par \i0\cf1     \cf0\b IF\b0\cf1  \cf2 (\cf1 ADay \cf2 =\cf1  nDay\cf2 )\cf1  \cf0\b AND\b0\cf1  \cf2 (\cf1 AYear \cf2 =\cf1  nYear\cf2 )\cf1  \cf0\b AND\b0\cf1  \cf2 (\cf1 AMonth \cf2 =\cf1  nMonth\cf2 )\cf1  \cf0\b THEN\b0\cf1  \cf0\b BEGIN
\par \b0\cf1         \cf0\b IF\b0\cf1  Showpath\cf2 [\cf1 Length\cf2 (\cf1 Showpath\cf2 )]\cf1  \cf2 =\cf1  \cf3 '\\'\cf1  \cf0\b THEN
\par \b0\cf1         Delete\cf2 (\cf1 Showpath\cf2 ,\cf1  Length\cf2 (\cf1 Showpath\cf2 ),\cf1  \cf2 1);
\par \cf1         outPutStr\cf2 :=\cf1  Showpath \cf2 +\cf1  \cf3 '\\'\cf1  \cf2 +\cf1  fname \cf2 +\cf1  \cf3 '.'\cf1  \cf2 +\cf1  fext\cf2 ;
\par \cf1         \cf0\i //dflistview.Columns:= 3;
\par \i0\cf1         \cf0\i //dflistView.TabWith:= 50;
\par \i0\cf1         \cf0\i //dflistView.Items.add(outPutStr +^I+ lenStr);  // ^I is the Tab char
\par \i0\cf1         dflistView\cf2 .\cf1 Items\cf2 .\cf1 Insert\cf2 (0,\cf1  format\cf2 (\cf3 '%-80s %10s -%5s'\cf2 ,
\par \cf1            \cf2 [\cf1 outPutStr\cf2 ,\cf1  lenStr\cf2 ,\cf1  inttoStr\cf2 (\cf1 aHour\cf2 )+\cf3 ':'\cf2 +\cf1 inttoStr\cf2 (\cf1 aMin\cf2 )]));
\par \cf1      \cf0\b END\b0\cf2 ;
\par \cf1   \cf0\i //END;
\par \i0\b END\b0\cf2 ;
\par 
\par 
\par \cf0\b PROCEDURE\b0\cf1  TChangeFinder_SearchDirectories\cf2 (\cf1 path\cf2 :\cf1  \cf0\b string\b0\cf2 ;\cf1  \cf0\b const\b0\cf1  fname\cf2 :\cf1  \cf0\b STRING\b0\cf2 );
\par \cf0\b VAR
\par \b0\cf1   sRecord \cf2 :\cf1  TSearchRec\cf2 ;
\par \cf1   Showpath\cf2 :\cf1  \cf0\b STRING\b0\cf2 ;
\par \cf1   \cf0\i //myf: TChangeFinder; 
\par \i0\cf1   \cf0\i //amod: TmodCommand;
\par \i0\b BEGIN
\par \b0\cf1   \cf0\i (* Suche nach Dateien: *)
\par \i0\cf1   \cf0\b IF\b0\cf1  Length\cf2 (\cf1 path\cf2 )\cf1  \cf2 >\cf1  \cf2 0\cf1  \cf0\b THEN
\par \b0\cf1     \cf0\b IF\b0\cf1  path\cf2 [\cf1 Length\cf2 (\cf1 path\cf2 )]\cf1  \cf2 <>\cf1  \cf3 '\\'\cf1  \cf0\b THEN
\par \b0\cf1       path \cf2 :=\cf1  path \cf2 +\cf1  \cf3 '\\'\cf2 ;
\par \cf1   SRecord\cf2 .\cf1 Name\cf2 :=\cf1  \cf3 ''\cf2 ;
\par \cf1   \cf0\b if\b0\cf1  FindFirst2\cf2 (\cf1 path\cf2 +\cf1 fname\cf2 ,\cf1  faAnyfile \cf0\b MOD\b0\cf1  faDirectory\cf2 ,\cf1  SRecord\cf2 )\cf1  \cf2 =\cf1  \cf2 0\cf1  \cf0\b then\b0\cf1  \cf0\b begin
\par \b0\cf1     Showpath\cf2 :=\cf1  \cf3 '        .   '\cf2 ;
\par \cf1     \cf0\b IF\b0\cf1  SRecord\cf2 .\cf1 Name \cf2 <>\cf1  \cf3 ''\cf1  \cf0\b THEN\b0\cf1  \cf0\b BEGIN
\par \b0\cf1       \cf0\b IF\b0\cf1  Length\cf2 (\cf1 path\cf2 )\cf1   \cf2 >\cf1  \cf2 3\cf1  \cf0\b THEN
\par \b0\cf1       Showpath\cf2 :=\cf1  Copy\cf2 (\cf1 path\cf2 ,\cf1  \cf2 1,\cf1  Length\cf2 (\cf1 path\cf2 )\cf1  \cf2 -\cf1  \cf2 1)
\par \cf1      \cf0\b ELSE\b0\cf1  Showpath\cf2 :=\cf1  path\cf2 ;
\par \cf1     \cf0\b END\b0\cf2 ;
\par \cf1    \cf0\b try
\par \b0\cf1     \cf0\b repeat
\par \b0\cf1      \cf0\i //0..14, 32..46
\par \i0\cf1       \cf0\i //IF SRecord.Attr IN [$0..$E, $20..$2E] THEN
\par \i0\cf1       \cf0\i //IF (SRecord.Attr <=$E) or (SRecord.Attr >=$20) or (SRecord.Attr <=$2E) then
\par \i0\cf1       \cf0\i //IN [$0..$E, $20..$2E] THEN
\par \i0\cf1       
\par       \cf0\i //FindFirst(StartDir+FileMask, faAnyFile-faDirectory) = 0;
\par \i0\cf1       \cf0\b IF\b0\cf1  \cf2 (\cf1 SRecord\cf2 .\cf1 Attr \cf2 =\cf1  faAnyFile\cf2 -\cf1 faDirectory\cf2 )\cf1  \cf0\b then
\par \b0\cf1           TChangeFinder_ShowFiles\cf2 (\cf1 Showpath\cf2 ,\cf1 SRecord\cf2 );
\par \cf1     \cf0\b until\b0\cf1  FindNext2\cf2 (\cf1 sRecord\cf2 )\cf1  \cf2 <>\cf1  \cf2 0;
\par \cf1    \cf0\b finally
\par \b0\cf1       WFindClose\cf2 (\cf1 sRecord\cf2 .\cf1 findhandle\cf2 );
\par \cf1    \cf0\b end\b0\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf1   \cf0\i (* Suche nach Verzeichnissen: *)
\par \i0\cf1   \cf0\i // hidden dir available with fahidden
\par \i0\cf1   \cf0\b if\b0\cf1  FindFirst2\cf2 (\cf1 path \cf2 +\cf1  \cf3 '*.*'\cf2 ,\cf1  faDirectory \cf0\b or\b0\cf1  faHidden\cf2 ,\cf1  SRecord\cf2 )\cf1  \cf2 =\cf1  \cf2 0\cf1  \cf0\b then\b0\cf1  \cf0\b begin
\par \b0\cf1     \cf0\b try
\par \b0\cf1     \cf0\b repeat
\par \b0\cf1         \cf0\b IF\b0\cf1  \cf2 (\cf1 SRecord\cf2 .\cf1 Attr \cf0\b AND\b0\cf1  faDirectory \cf2 <>\cf1  \cf2 0)\cf1  \cf0\b AND
\par \b0\cf1        \cf2 (\cf1 SRecord\cf2 .\cf1 Name\cf2 [1]\cf1  \cf2 <>\cf1  \cf3 '.'\cf2 )\cf1  \cf0\b THEN
\par \b0\cf1       \cf0\i //recursion to get subdirectories
\par \i0\cf1       TChangeFinder_SearchDirectories\cf2 (\cf1 path \cf2 +\cf1  SRecord\cf2 .\cf1 Name\cf2 ,\cf1  fname\cf2 );
\par \cf1       writeln\cf2 (\cf1 path \cf2 +\cf1  SRecord\cf2 .\cf1 Name\cf2 )
\par \cf1     \cf0\b until\b0\cf1  FindNext2\cf2 (\cf1 sRecord\cf2 )\cf1  \cf2 <>\cf1  \cf2 0;
\par \cf1     \cf0\b finally
\par \b0\cf1       WFindClose\cf2 (\cf1 sRecord\cf2 .\cf1 findhandle\cf2 );
\par \cf1     \cf0\b end\b0\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par 
\par 
\par 
\par 
\par \cf0\i \{**************************************************\}
\par //function GetProcessMemoryInfo; external 'psapi.dll';
\par \{****************************************************\}
\par 
\par \i0\b function\b0\cf1  ProcessMemoryUsage\cf2 (\cf1 ProcessID \cf2 :\cf1  DWORD\cf2 ):\cf1  DWORD\cf2 ;
\par \cf0\b var\b0\cf1  ProcessHandle \cf2 :\cf1  THandle\cf2 ;
\par \cf1     MemCounters   \cf2 :\cf1  TProcessMemoryCounters\cf2 ;
\par \cf0\b begin
\par \b0\cf1   Result\cf2 :=\cf1  \cf2 0;
\par \cf1   ProcessHandle\cf2 :=\cf1  OpenProcess2\cf2 (\cf1 PROCESS_QUERY_INFORMATION \cf0\b or\b0\cf1  PROCESS_VM_READ\cf2 ,
\par \cf1                                false\cf2 ,\cf1  ProcessID\cf2 );
\par \cf1   \cf0\b try
\par \b0\cf1     \cf0\b if\b0\cf1  GetProcessMemoryInfo\cf2 (\cf1 ProcessHandle\cf2 ,
\par \cf1                             MemCounters\cf2 ,\cf1  sizeof\cf2 (\cf1 MemCounters\cf2 ))
\par \cf1     \cf0\b then\b0\cf1  Result\cf2 :=\cf1  MemCounters\cf2 .\cf1 WorkingSetSize\cf2 ;
\par \cf1   \cf0\b finally
\par \b0\cf1     CloseHandle\cf2 (\cf1 ProcessHandle\cf2 );
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b function\b0\cf1  ProcessPageUsage\cf2 (\cf1 ProcessID \cf2 :\cf1  DWORD\cf2 ):\cf1  DWORD\cf2 ;
\par \cf0\b var\b0\cf1  ProcessHandle \cf2 :\cf1  THandle\cf2 ;
\par \cf1     MemCounters   \cf2 :\cf1  TProcessMemoryCounters\cf2 ;
\par \cf0\b begin
\par \b0\cf1   Result\cf2 :=\cf1  \cf2 0;
\par \cf1   ProcessHandle\cf2 :=\cf1  OpenProcess2\cf2 (\cf1 PROCESS_QUERY_INFORMATION \cf0\b or\b0\cf1  PROCESS_VM_READ\cf2 ,
\par \cf1                                false\cf2 ,\cf1  ProcessID\cf2 );
\par \cf1   \cf0\b try
\par \b0\cf1     \cf0\b if\b0\cf1  GetProcessMemoryInfo\cf2 (\cf1 ProcessHandle\cf2 ,
\par \cf1                             MemCounters\cf2 ,\cf1  sizeof\cf2 (\cf1 MemCounters\cf2 ))
\par \cf1     \cf0\b then\b0\cf1  Result\cf2 :=\cf1  MemCounters\cf2 .\cf1 PagefileUsage\cf2 ;
\par \cf1   \cf0\b finally
\par \b0\cf1     CloseHandle\cf2 (\cf1 ProcessHandle\cf2 );
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b function\b0\cf1  ProcessAllRec\cf2 (\cf1 ProcessID \cf2 :\cf1  DWORD\cf2 ):\cf1  TProcessMemoryCounters\cf2 ;
\par \cf0\b var\b0\cf1  ProcessHandle \cf2 :\cf1  THandle\cf2 ;
\par \cf1     MemCounters   \cf2 :\cf1  TProcessMemoryCounters\cf2 ;
\par \cf0\b begin
\par \b0\cf1   \cf0\i //Result:= NULL;
\par \i0\cf1   ProcessHandle\cf2 :=\cf1  OpenProcess2\cf2 (\cf1 PROCESS_QUERY_INFORMATION \cf0\b or\b0\cf1  PROCESS_VM_READ\cf2 ,
\par \cf1                                false\cf2 ,\cf1  ProcessID\cf2 );
\par \cf1   \cf0\b try
\par \b0\cf1     \cf0\b if\b0\cf1  GetProcessMemoryInfo\cf2 (\cf1 ProcessHandle\cf2 ,
\par \cf1                             MemCounters\cf2 ,\cf1  sizeof\cf2 (\cf1 MemCounters\cf2 ))
\par \cf1     \cf0\b then\b0\cf1  Result\cf2 :=\cf1  MemCounters\cf2 ;
\par \cf1   \cf0\b finally
\par \b0\cf1     CloseHandle\cf2 (\cf1 ProcessHandle\cf2 );
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b Procedure\b0\cf1  OVCInternationalDemoClass\cf2 ;
\par \cf0\b begin
\par \b0\cf1  \cf0\b with\b0\cf1  TOvcIntlSup\cf2 .\cf1 Create \cf0\b do\b0\cf1  \cf0\b begin
\par \b0\cf1     \cf0\i //Function InternationalDate( ForceCentury : Boolean) : string');
\par \i0\cf1     writeln\cf2 (\cf3 'InternationalDate: '\cf2 +\cf1 InternationalDate\cf2 (\cf1 true\cf2 ));
\par \cf1     \cf0\i //Function InternationalDatePChar( Dest : PChar; ForceCentury : Boolean) : PChar');
\par \i0\cf1     writeln\cf2 (\cf3 'InternationalLongDate: '\cf2 +\cf1 InternationalLongDate\cf2 (\cf1 false\cf2 ,\cf1 false\cf2 ));
\par \cf1     \cf0\i //Function InternationalTime( ShowSeconds : Boolean) : string');
\par \i0\cf1     writeln\cf2 (\cf3 'InternationalTime: '\cf2 +\cf1 InternationalTime\cf2 (\cf1 false\cf2 ));
\par \cf1     \cf0\i //Function InternationalTimePChar( Dest : PChar; ShowSeconds : Boolean) : PChar');
\par \i0\cf1     \cf0\i //Function MonthStringToMonth( const S : string; Width : Byte) : Byte');
\par \i0\cf1     writeln\cf2 (\cf1 Country\cf2 )
\par \cf1     Free\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf1   \cf0\i //TerminateProcess( hProcess : THandle; uExitCode : UINT) : BOOL');
\par \i0\cf1   \cf0\i //GetExitCodeProcess( hProcess : THandle; var lpExitCode : DWORD) : BOOL');
\par \i0\cf1  \cf0\i //FatalExit( ExitCode : Integer)');
\par \i0\cf1  \cf0\i //ExecuteAndWait(cmdLine : String; visibility : Word;
\par \i0\cf1    \cf0\i //                     timeout : Cardinal = MaxInt;
\par \i0\cf1      \cf0\i //                   killAppOnTimeOut : Boolean = True) : Integer;
\par \i0\cf1   \cf0\i //GetTemporaryFilesPath : String;
\par \i0\cf1  \cf0\i //GetTemporaryFileName : String;
\par \i0\cf1  \cf0\i //Zero
\par \i0\cf1  \cf0\i //TPanelStyle
\par \i0\cf1    \cf0\i //TFontLook
\par \i0\cf1  \cf0\i //FindFileInPaths(const fileName, paths : String) : String;
\par \i0\cf1      \cf0\i //MakeForm
\par \i0\cf1  \cf0\i //PathsToString(const paths : TStrings) : String;
\par \i0\cf1  \cf0\i //StringToPaths(const pathsString : String; paths : TStrings);
\par \i0\cf1  \cf0\i //MacroExpandPath(const aPath : String) : String;
\par \i0\cf1  \cf0\i //TOnGetItemEvent
\par \i0\cf1    \cf0\i //TCacheRecord
\par \i0\cf1    \cf0\i //tMessagefunc
\par \i0\cf1    \cf0\i //EFilerException(CL: TPSPascalCompiler);
\par //EInvalidFileSignature(CL: TPSPascalCompiler);
\par //TTextWriter(CL: TPSPascalCompiler);
\par //TTextReader(CL: TPSPascalCompiler);
\par //TBinaryWriter(CL: TPSPascalCompiler);
\par //TBinaryReader(CL: TPSPascalCompiler);
\par //TPersistentObjectList(CL: TPSPascalCompiler);
\par //TPersistentObject(CL: TPSPascalCompiler);
\par //IPersistentObject(CL: TPSPascalCompiler);
\par //TVirtualWriter(CL: TPSPascalCompiler);
\par //TVirtualReader(CL: TPSPascalCompiler);
\par //PersistentClasses(CL: TPSPascalCompiler);
\par \i0\b end\b0\cf2 ;\cf1     
\par 
\par 
\par \cf0\b function\b0\cf1  SplitToken\cf2 (\cf0\b const\b0\cf1  Text\cf2 :\cf1  \cf0\b string\b0\cf2 ;\cf1  SplitChar\cf2 :\cf1  Char\cf2 ;
\par \cf1                           \cf0\b var\b0\cf1  First\cf2 ,\cf1  Last\cf2 :\cf1  \cf0\b string\b0\cf2 ):\cf1  Boolean\cf2 ;
\par \cf0\b var\b0\cf1   SplitPos\cf2 :\cf1  Integer\cf2 ;
\par \cf1       ec\cf2 :\cf1  EJclError\cf2 ;
\par \cf0\b begin
\par \b0\cf1   Result\cf2 :=\cf1  False\cf2 ;
\par \cf1   SplitPos\cf2 :=\cf1  Pos\cf2 (\cf1 SplitChar\cf2 ,\cf1  Text\cf2 );
\par \cf1   \cf0\b if\b0\cf1  SplitPos \cf2 =\cf1  \cf2 0\cf1  \cf0\b then\b0\cf1  Exit\cf2 ;
\par \cf1   First\cf2 :=\cf1  Trim\cf2 (\cf1 Copy\cf2 (\cf1 Text\cf2 ,\cf1  \cf2 1,\cf1  SplitPos \cf2 -1));
\par \cf1   Last\cf2 :=\cf1  Trim\cf2 (\cf1 Copy\cf2 (\cf1 Text\cf2 ,\cf1  SplitPos \cf2 +1,\cf1  Length\cf2 (\cf1 Text\cf2 )\cf1  \cf2 -\cf1 SplitPos\cf2 ));
\par \cf1   Result\cf2 :=\cf1  \cf2 (\cf1 First \cf2 <>\cf3 ''\cf2 )\cf1  \cf0\b and\b0\cf1  \cf2 (\cf1 Last \cf2 <>\cf3 ''\cf2 );
\par \cf0\b end\b0\cf2 ;
\par 
\par 
\par \cf0\b function\b0\cf1  TForm1_scrollAllNode\cf2 (\cf1 aNode\cf2 :\cf1  TalXmlNode\cf2 ):\cf1  Integer\cf2 ;
\par \cf0\b Var\b0\cf1  aStack\cf2 :\cf1  Tstack\cf2 ;
\par \cf1     i\cf2 :\cf1  integer\cf2 ;
\par \cf0\b begin
\par \b0\cf1   Result \cf2 :=\cf1  \cf2 0;
\par \cf1   aStack \cf2 :=\cf1  Tstack\cf2 .\cf1 Create\cf2 ;
\par \cf1   \cf0\b try
\par \b0\cf1      \cf0\b For\b0\cf1  i \cf2 :=\cf1  \cf2 0\cf1  \cf0\b to\b0\cf1  aNode\cf2 .\cf1 ChildNodes\cf2 .\cf1 Count \cf2 -\cf1  \cf2 1\cf1  \cf0\b do
\par \b0\cf1         aStack\cf2 .\cf1 Push\cf2 ((\cf1 ANode\cf2 .\cf1 ChildNodes\cf2 [\cf1 i\cf2 ]));
\par \cf1          \cf0\b While\b0\cf1  astack\cf2 .\cf1 Count \cf2 >\cf1  \cf2 0\cf1  \cf0\b do\b0\cf1  \cf0\b begin
\par \b0\cf1         inc\cf2 (\cf1 result\cf2 );
\par \cf1         aNode \cf2 :=\cf1  TalxmlNode\cf2 (\cf1 astack\cf2 .\cf1 Pop\cf2 );
\par \cf1         \cf0\b If\b0\cf1  assigned\cf2 (\cf1 ANode\cf2 .\cf1 ChildNodes\cf2 )\cf1  \cf0\b then
\par \b0\cf1           \cf0\b For\b0\cf1  i \cf2 :=\cf1  \cf2 0\cf1  \cf0\b to\b0\cf1  ANode\cf2 .\cf1 ChildNodes\cf2 .\cf1 Count \cf2 -\cf1  \cf2 1\cf1  \cf0\b do
\par \b0\cf1             aStack\cf2 .\cf1 Push\cf2 ((\cf1 ANode\cf2 .\cf1 ChildNodes\cf2 [\cf1 i\cf2 ]));
\par \cf1            \cf0\b If\b0\cf1  assigned\cf2 (\cf1 ANode\cf2 .\cf1 AttributeNodes\cf2 )\cf1  \cf0\b then
\par \b0\cf1           \cf0\b For\b0\cf1  i \cf2 :=\cf1  \cf2 0\cf1  \cf0\b to\b0\cf1  ANode\cf2 .\cf1 attributeNodes\cf2 .\cf1 Count \cf2 -\cf1  \cf2 1\cf1  \cf0\b do
\par \b0\cf1             aStack\cf2 .\cf1 Push\cf2 ((\cf1 ANode\cf2 .\cf1 AttributeNodes\cf2 [\cf1 i\cf2 ]));
\par \cf1       \cf0\b end\b0\cf2 ;
\par \cf1   \cf0\b finally
\par \b0\cf1     aStack\cf2 .\cf1 Free\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b function\b0\cf1  IntToStrZeroPad\cf2 (\cf1 Value\cf2 ,\cf1  Count\cf2 :\cf1  Integer\cf2 ):\cf1  AnsiString\cf2 ;
\par \cf0\b begin
\par \b0\cf1   Result \cf2 :=\cf1  IntToStr\cf2 (\cf1 Value\cf2 );
\par \cf1   \cf0\b if\b0\cf1  Length\cf2 (\cf1 Result\cf2 )\cf1  \cf2 <\cf1  Count \cf0\b then
\par \b0\cf1     Result \cf2 :=\cf1  StrFillChar\cf2 (\cf3 '0'\cf2 ,\cf1  Count \cf2 -\cf1  Length\cf2 (\cf1 Result\cf2 ))\cf1  \cf2 +\cf1  Result\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b function\b0\cf1  JclGUIDToString\cf2 (\cf0\b const\b0\cf1  GUID\cf2 :\cf1  TGUID\cf2 ):\cf1  \cf0\b string\b0\cf2 ;
\par \cf0\b begin
\par \b0\cf1   \i \{$IFDEf CLR\}
\par \i0   Result \cf2 :=\cf1  GUID\cf2 .\cf1 ToString\cf2 ();
\par \cf1   \i \{$ELSE\}
\par \i0   Result \cf2 :=\cf1  Format\cf2 (\cf3 '\{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x\}'\cf2 ,
\par \cf1     \cf2 [\cf1 GUID\cf2 .\cf1 D1\cf2 ,\cf1  GUID\cf2 .\cf1 D2\cf2 ,\cf1  GUID\cf2 .\cf1 D3\cf2 ,\cf1  GUID\cf2 .\cf1 D4\cf2 [0],\cf1  GUID\cf2 .\cf1 D4\cf2 [1],\cf1  GUID\cf2 .\cf1 D4\cf2 [2],
\par \cf1      GUID\cf2 .\cf1 D4\cf2 [3],\cf1  GUID\cf2 .\cf1 D4\cf2 [4],\cf1  GUID\cf2 .\cf1 D4\cf2 [5],\cf1  GUID\cf2 .\cf1 D4\cf2 [6],\cf1  GUID\cf2 .\cf1 D4\cf2 [7]]);
\par \cf1   \i \{$ENDIF CLR\}
\par \i0\cf0\b end\b0\cf2 ;
\par 
\par 
\par \cf0\b function\b0\cf1  GetOsVersionInfo2\cf2 :\cf1  TOSVersionInfo\cf2 ;\cf1  
\par \cf0\b var
\par \b0\cf1   verInfo\cf2 :\cf1  TOSVersionInfo\cf2 ;
\par \cf0\b begin
\par \b0\cf1   verinfo\cf2 .\cf1 dwOSVersionInfoSize\cf2 :=\cf1  sizeof\cf2 (\cf1 verinfo\cf2 );
\par \cf1   GetVersionEx\cf2 (\cf1 Verinfo\cf2 );
\par \cf1   result\cf2 :=\cf1  Verinfo\cf2 ;
\par \cf0\b end\b0\cf2 ;\cf1   
\par 
\par \cf0\b var\b0\cf1   verInfo\cf2 :\cf1  TOSVersionInfo\cf2 ;
\par 
\par \cf0\b Begin\b0\cf1   \cf0\i //Main
\par //<Executable statements>
\par \i0\cf1   \cf0\i //TOutlookExport_Spy;
\par \i0\cf1   Writeln\cf2 (\cf3 ''\cf2 );
\par \cf1   \cf0\i //Writeln('Start Command of DLL: '+CheckIEStartCommand);  
\par //<Definitions>  
\par \i0\cf1    \cf0\i //ares:= TResolver.create;
\par \i0\cf1  \cf0\i \{ with TResolver.create do begin
\par    //writeln(inttostr(GetHostByName(gethostname)));
\par     Free;   end;  \}
\par \i0\cf1     \cf0\i \{repeat 
\par      TApplication_PaintView(aform.canvas);
\par      switch:= NOT switch;
\par      Sleep(20);
\par    until isKeyPressed or FWait;\}
\par \i0\cf1     \cf0\i \{with TledForm.create(self) do begin
\par     showmodal; free; end;\}\i0\cf1  
\par  \cf0\i // function GetMacAddresses(const Machine: string; const Addresses: TStrings):Integer;
\par \i0\cf1    OVCInternationalDemoClass\cf2 ;
\par \cf1   
\par  \cf0\i //GetProcessMemoryInfo(Process 
\par \i0\cf1      writeln\cf2 (\cf3 'mem from dll '\cf2 +\cf1 inttostr\cf2 (\cf1 ProcessMemoryUsage\cf2 (\cf1 GetCurrentProcessID\cf2 )));
\par \cf1      writeln\cf2 (\cf3 'page from dll '\cf2 +\cf1 inttostr\cf2 (\cf1 ProcessPageUsage\cf2 (\cf1 GetCurrentProcessID\cf2 )));
\par \cf1      writeln\cf2 (\cf3 'proc all from dll '
\par \cf1                  \cf2 +\cf1 inttostr\cf2 (\cf1 ProcessAllRec\cf2 (\cf1 GetCurrentProcessID\cf2 ).\cf1 workingsetsize\cf2 ));
\par \cf1      writeln\cf2 (\cf3 'proc peak workingset '
\par \cf1               \cf2 +\cf1 inttostr\cf2 (\cf1 ProcessAllRec\cf2 (\cf1 GetCurrentProcessID\cf2 ).\cf1 PeakWorkingSetSize \cf0\b div\b0\cf1  \cf2 1024));
\par \cf1      writeln\cf2 (\cf3 'proc peak paged use '
\par \cf1               \cf2 +\cf1 inttostr\cf2 (\cf1 ProcessAllRec\cf2 (\cf1 GetCurrentProcessID\cf2 ).\cf1 QuotaPeakPagedPoolUsage\cf2 ));
\par \cf1      writeln\cf2 (\cf3 'proc page peak file '
\par \cf1               \cf2 +\cf1 inttostr\cf2 (\cf1 getProcMemInfo\cf2 (\cf1 GetCurrentProcessID\cf2 ).\cf1 PeakPagefileUsage \cf0\b div\b0\cf1  \cf2 1024));
\par \cf1  
\par     \cf0\i // SplitImages(self);
\par \i0\cf1      \cf0\i //deletefiles(PICPATH,'*.bmp');
\par \i0\cf1       \cf0\i //GetCurrentHwProfile( var lpHwProfileInfo : THWProfileInfo) : BOOL');
\par \i0\cf1         \cf0\i //SetPriorityClass
\par \i0\cf1         \cf0\i //GetPriorityClass
\par \i0\cf1      \cf0\i //OpenClipboard( 
\par \i0\cf1      \cf0\i //booleantostr(false);
\par \i0\cf1      \cf0\i //JclGUIDToString
\par \i0\cf1        \cf0\i //TJclNumericFormat 
\par \i0\cf1           \cf0\i //function IsClass(Address: Pointer): Boolean;
\par \i0\cf1           \cf0\i //function IsObject(Address: Pointer): Boolean;
\par \i0\cf1            \cf0\i //IsClass(Address: Pointer): Boolean;
\par \i0\cf1            \cf0\i //IsObject(Address: Pointer): Boolean;
\par \i0\cf1            \cf0\i //ReadKey
\par \i0\cf1              \cf0\i //IntToStrZeroPad
\par \i0\cf1            \cf0\i //  StrFillChar
\par \i0\cf1            \cf0\i //EndDialog( 
\par \i0\cf1              \cf0\i //GetDlgItem(
\par \i0\cf1              \cf0\i //SetDlgItemInt( 
\par \i0\cf1                \cf0\i //dialogbox
\par \i0\cf1          \cf0\i //TQuaternionList(CL: TPSPascalCompiler);
\par //TByteList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //TSingleList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //TIntegerList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //TTexPointList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //TVectorList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //TAffineVectorList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //TBaseVectorList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //TBaseList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //VectorLists(CL: TPSPascalCompiler);
\par \i0\cf1    \cf0\i //TXIntegerList
\par \i0\cf1    \cf0\i //TJclSimpleLog
\par \i0\cf1      \cf0\i //jExecute 
\par \i0\cf1        writeln\cf2 (\cf1 booleantostr\cf2 (\cf1 samepath\cf2 (\cf1 exepath\cf2 ,\cf1  exepath\cf2 )))
\par \cf1        
\par   verinfo\cf2 :=\cf1  GetOsVersionInfo2\cf2 ;
\par \cf1   writeln\cf2 (\cf3 'OS Verinfo '\cf2 +\cf1 inttostr\cf2 (\cf1 Verinfo\cf2 .\cf1 dwMajorVersion\cf2 ))
\par \cf1   writeln\cf2 (\cf3 'OS Verinfo '\cf2 +\cf1 inttostr\cf2 (\cf1 Verinfo\cf2 .\cf1 dwMinorVersion\cf2 ))
\par \cf1   writeln\cf2 (\cf3 'OS Versizeinfo '\cf2 +\cf1 inttostr\cf2 (\cf1 Verinfo\cf2 .\cf1 dwOSVersionInfoSize\cf2 ))
\par \cf1   \cf0\i //Function IsDelphiProject( const FileName : string) : Boolean');
\par \i0\cf1   writeln\cf2 (\cf1 booleantoStr\cf2 (\cf1 IsDelphiProject\cf2 (\cf1 exepath\cf2 +\cf3 'maxbox3.exe'\cf2 )));
\par \cf1   \cf0\i //FileBackup(const 
\par \i0\cf1   
\par   TChangeFinder_SearchDirectories\cf2 (\cf1 exepath\cf2 +\cf3 'examples'\cf2 ,\cf3 '*.txt'\cf2 );
\par \cf1          
\par \cf0\b END\b0\cf2 .\cf1  
\par 
\par small \cf0\b set\b0\cf1  \cf0\b for\b0\cf1  \cf0\b arduino\b0\cf1  \cf0\b and\b0\cf1  \cf0\b android\b0\cf1  testing 
\par 
\par \cf0\b var\b0\cf1  drive\cf2 :\cf1  \cf0\b string\b0\cf2 [20];
\par \cf1     mycf\cf2 :\cf1  TChangeFinder\cf2 ;
\par \cf0\b begin
\par \b0\cf1   screen\cf2 .\cf1 cursor\cf2 :=\cf1 crHourglass\cf2 ;
\par \cf1     drive\cf2 :=\cf1  dcbHD\cf2 .\cf1 Drive\cf2 ;
\par \cf1     drive\cf2 :=\cf1  drive \cf2 +\cf1  \cf3 ':'\cf2 ;
\par \cf1     mycf\cf2 :=\cf1  TChangeFinder\cf2 .\cf1 prepList_and_Date\cf2 (\cf1 frmMain\cf2 .\cf1 livchangefind\cf2 );
\par \cf1     mycf\cf2 .\cf1 SearchDirectories\cf2 (\cf1 drive \cf2 +\cf1  \cf3 '\\'\cf2 ,\cf3 '*.*'\cf2 );
\par \cf1     mycf\cf2 .\cf1 Free\cf2 ;
\par \cf1     screen\cf2 .\cf1 cursor\cf2 :=\cf1 crDefault\cf2 ;
\par \cf0\b end\b0\cf2 ;\cf1  \cf2 \}
\par 
\par 
\par 
\par \cf1 http\cf2 :\cf0\i //glscene.sourceforge.net/wikka/HomePage
\par 
\par \{-Modulename and path: udwsfiler
\par //
\par //D:\\franktech\\Delphmax\\dws\\DWSServer.mpb
\par //Category    Access method
\par //
\par //Developer kleiner kommunikation
\par //Last Modification on 30.06.03 17:51:54:
\par //question is destructor of grid
\par   descript as a new field on 20.6.03
\par   modified flag on 30.6.03
\par //==========================================================================\}
\par \i0\b unit\b0\cf1  udwsfilerwiz\cf2 ;
\par 
\par 
\par \cf0\b interface
\par 
\par uses\b0\cf1  QGrids\cf2 ;
\par 
\par \cf0\b type
\par \b0\cf1  TAppData \cf2 =\cf1  \cf0\b record
\par \b0\cf1    Name\cf2 :\cf1  \cf0\b string\b0\cf2 [50];
\par \cf1    Size\cf2 :\cf1  longint\cf2 ;
\par \cf1    Release\cf2 :\cf1  \cf0\b string\b0\cf2 [30];
\par \cf1    descript\cf2 :\cf1  \cf0\b string\b0\cf2 [80];
\par \cf1  \cf0\b end\b0\cf2 ;
\par 
\par \cf1   TBuildAppGrid \cf2 =\cf1  \cf0\b class\b0\cf1  \cf2 (\cf1 TObject\cf2 )
\par \cf1   \cf0\b private
\par \b0\cf1     aGrid\cf2 :\cf1  TStringGrid\cf2 ;
\par \cf1     app\cf2 :\cf1  TAppData\cf2 ;
\par \cf1     f\cf2 :\cf1  \cf0\b file\b0\cf1  \cf0\b of\b0\cf1  TAppData\cf2 ;
\par \cf1     FaDatfile\cf2 :\cf1  \cf0\b ShortString\b0\cf2 ;
\par \cf1     Fmodified\cf2 :\cf1  Boolean\cf2 ;
\par \cf1   \cf0\b protected
\par \b0\cf1     \cf0\b function\b0\cf1  GetaDatfile\cf2 :\cf1  \cf0\b ShortString\b0\cf2 ;
\par \cf1     \cf0\b procedure\b0\cf1  SetaDatfile\cf2 (\cf0\b const\b0\cf1  Value\cf2 :\cf1  \cf0\b ShortString\b0\cf2 );
\par \cf1   \cf0\b public
\par \b0\cf1     \cf0\b constructor\b0\cf1  initGrid\cf2 (\cf1 vGrid\cf2 :\cf1  TStringGrid\cf2 ;\cf1  vFile\cf2 :\cf1  \cf0\b shortString\b0\cf2 );
\par \cf1     \cf0\b procedure\b0\cf1  fillGrid\cf2 ;
\par \cf1     \cf0\b procedure\b0\cf1  storeGrid\cf2 ;
\par \cf1     \cf0\b property\b0\cf1  aDatfile\cf2 :\cf1  \cf0\b ShortString\b0\cf1  \cf0\b read\b0\cf1  GetaDatfile \cf0\b write\b0\cf1  SetaDatfile\cf2 ;
\par \cf1     \cf0\b property\b0\cf1  modified\cf2 :\cf1  Boolean \cf0\b read\b0\cf1  Fmodified \cf0\b write\b0\cf1  Fmodified\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;
\par 
\par 
\par \cf0\b implementation
\par 
\par uses\b0\cf1  sysutils\cf2 ,\cf1  QDialogs\cf2 ,\cf1  QControls\cf2 ,
\par \cf1   QStdCtrls\cf2 ;
\par 
\par 
\par \cf0\i \{
\par ******************************** TBuildAppGrid *********************************
\par \}
\par \i0\b constructor\b0\cf1  TBuildAppGrid\cf2 .\cf1 initGrid\cf2 (\cf1 vGrid\cf2 :\cf1  TStringGrid\cf2 ;\cf1  vFile\cf2 :\cf1  \cf0\b shortString\b0\cf2 );
\par \cf0\b begin
\par \b0\cf1   aGrid\cf2 :=\cf1  vGrid\cf2 ;
\par \cf1   aDatfile\cf2 :=\cf1  vFile\cf2 ;
\par \cf1   \cf0\b with\b0\cf1  aGrid \cf0\b do\b0\cf1  \cf0\b begin
\par \b0\cf1     ScrollBars\cf2 :=\cf1  ssAutoVertical\cf2 ;
\par \cf1     FixedRows \cf2 :=\cf1  \cf2 1;
\par \cf1     FixedCols\cf2 :=\cf1  \cf2 0;
\par \cf1     ColCount\cf2 :=\cf1  \cf2 4;
\par \cf1     RowCount\cf2 :=\cf1  \cf2 2;\cf1  \cf0\i //title is one row
\par \i0\cf1   \cf0\b end\b0\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b procedure\b0\cf1  TBuildAppGrid\cf2 .\cf1 fillGrid\cf2 ;
\par \cf0\b var
\par \b0\cf1   crow\cf2 :\cf1  Integer\cf2 ;
\par \cf0\b begin
\par \b0\cf1   crow \cf2 :=\cf1  \cf2 1;
\par \cf1   \cf0\b with\b0\cf1  aGrid \cf0\b do\b0\cf1  \cf0\b begin
\par \b0\cf1     Cells\cf2 [0,0]:=\cf1  \cf3 'Application Name'\cf2 ;
\par \cf1     ColWidths\cf2 [0]:=\cf1  \cf2 120;
\par \cf1     Cells\cf2 [1,0]:=\cf1  \cf3 'App Size'\cf2 ;
\par \cf1     ColWidths\cf2 [1]:=\cf1  \cf2 60;
\par \cf1     Cells\cf2 [2,0]:=\cf1  \cf3 'Release Date'\cf2 ;
\par \cf1     ColWidths\cf2 [2]:=\cf1  \cf2 90;
\par \cf1     Cells\cf2 [3,0]:=\cf1  \cf3 'Description'\cf2 ;
\par \cf1     ColWidths\cf2 [3]:=\cf1  \cf2 140;
\par \cf1     \cf0\b if\b0\cf1  aDatFile \cf2 <>\cf1  \cf3 ''\cf1  \cf0\b then\b0\cf1  \cf0\b begin
\par \b0\cf1       AssignFile\cf2 (\cf1 f\cf2 ,\cf1 aDatFile\cf2 );
\par \cf1       Reset\cf2 (\cf1 f\cf2 );
\par \cf1       \cf0\b try
\par \b0\cf1         \cf0\b while\b0\cf1  \cf0\b not\b0\cf1  Eof\cf2 (\cf1 F\cf2 )\cf1  \cf0\b do\b0\cf1  \cf0\b begin
\par \b0\cf1           Read \cf2 (\cf1 F\cf2 ,\cf1  app\cf2 );
\par \cf1           Cells\cf2 [0,\cf1 crow\cf2 ]:=\cf1  app\cf2 .\cf1 Name\cf2 ;
\par \cf1           Cells\cf2 [1,\cf1 crow\cf2 ]:=\cf1  intToStr\cf2 (\cf1 app\cf2 .\cf1 size\cf2 );
\par \cf1           Cells\cf2 [2,\cf1 crow\cf2 ]:=\cf1  app\cf2 .\cf1 Release\cf2 ;
\par \cf1           Cells\cf2 [3,\cf1 crow\cf2 ]:=\cf1  app\cf2 .\cf1 descript\cf2 ;
\par \cf1           Inc\cf2 (\cf1 cRow\cf2 );
\par \cf1           RowCount\cf2 :=\cf1  crow \cf2 +1;\cf1   \cf0\i //new entry
\par \i0\cf1         \cf0\b end\b0\cf2 ;
\par \cf1       \cf0\b finally
\par \b0\cf1         CloseFile\cf2 (\cf1 f\cf2 );
\par \cf1       \cf0\b end\b0\cf2 ;
\par \cf1     \cf0\b end\b0\cf2 ;\cf0\i // if FileExists...
\par \i0\cf1   \cf0\b end\b0\cf2 ;\cf1  \cf0\i //with
\par \i0\b end\b0\cf2 ;
\par 
\par \cf0\b function\b0\cf1  TBuildAppGrid\cf2 .\cf1 GetaDatfile\cf2 :\cf1  \cf0\b ShortString\b0\cf2 ;
\par \cf0\b begin
\par \b0\cf1   \cf0\b if\b0\cf1  FileExists\cf2 (\cf1 FaDatFile\cf2 )\cf1  \cf0\b then
\par \b0\cf1   result\cf2 :=\cf1  FaDatFile
\par   \cf0\b else\b0\cf1  \cf0\b begin
\par \b0\cf1      AssignFile\cf2 (\cf1 f\cf2 ,\cf1  FaDatFile\cf2 );
\par \cf1      Rewrite\cf2 (\cf1 f\cf2 );
\par \cf1      closefile\cf2 (\cf1 f\cf2 );
\par \cf1      result\cf2 :=\cf1  FaDatFile\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b procedure\b0\cf1  TBuildAppGrid\cf2 .\cf1 SetaDatfile\cf2 (\cf0\b const\b0\cf1  Value\cf2 :\cf1  \cf0\b ShortString\b0\cf2 );
\par \cf0\b begin
\par \b0\cf1   \cf0\b if\b0\cf1  FaDatfile \cf2 <>\cf1  Value \cf0\b then
\par \b0\cf1   \cf0\b begin
\par \b0\cf1     FaDatfile \cf2 :=\cf1  Value\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;
\par \cf0\b end\b0\cf2 ;
\par 
\par \cf0\b procedure\b0\cf1  TBuildAppGrid\cf2 .\cf1 storeGrid\cf2 ;
\par \cf0\b var
\par \b0\cf1   crow\cf2 :\cf1  Integer\cf2 ;
\par \cf0\b begin
\par \b0\cf1   \cf0\b if\b0\cf1  FModified \cf0\b then
\par \b0\cf1   \cf0\b if\b0\cf1  MessageDlg\cf2 (\cf3 'Save Changes in '\cf1  \cf2 +
\par \cf1              aDatFile\cf2 ,\cf1  mtConfirmation\cf2 ,\cf1 mbOkCancel\cf2 ,0)\cf1  \cf2 =\cf1  mrOK \cf0\b then
\par \b0\cf1    \cf0\b begin
\par \b0\cf1      AssignFile\cf2 (\cf1 f\cf2 ,\cf1  aDatfile\cf2 );
\par \cf1      Rewrite\cf2 (\cf1 f\cf2 );
\par \cf1    \cf0\b try
\par \b0\cf1      \cf0\b for\b0\cf1  crow\cf2 :=\cf1  \cf2 1\cf1  \cf0\b to\b0\cf1  Pred\cf2 (\cf1 aGrid\cf2 .\cf1 RowCount\cf2 )\cf1  \cf0\b do\b0\cf1  \cf0\b begin
\par \b0\cf1        app\cf2 .\cf1 Name\cf2 :=\cf1  aGrid\cf2 .\cf1 Cells\cf2 [0,\cf1  crow\cf2 ];
\par \cf1        app\cf2 .\cf1 size\cf2 :=\cf1  strToInt\cf2 (\cf1 aGrid\cf2 .\cf1 Cells\cf2 [1,\cf1  crow\cf2 ]);
\par \cf1        app\cf2 .\cf1 Release\cf2 :=\cf1  aGrid\cf2 .\cf1 Cells\cf2 [2,\cf1  crow\cf2 ];
\par \cf1        app\cf2 .\cf1 descript\cf2 :=\cf1  aGrid\cf2 .\cf1 Cells\cf2 [3,\cf1  crow\cf2 ];
\par \cf1        Write \cf2 (\cf1 f\cf2 ,\cf1  app\cf2 );
\par \cf1      \cf0\b end\b0\cf2 ;
\par \cf1    \cf0\b finally
\par \b0\cf1      CloseFile\cf2 (\cf1 f\cf2 );
\par \cf1    \cf0\b end\b0\cf2 ;
\par \cf1   \cf0\b end\b0\cf2 ;\cf1  \cf0\i //if MessageDlg...
\par \i0\b end\b0\cf2 ;
\par 
\par \cf0\b end\b0\cf2 .
\par 
\par 
\par \cf1 und am TV \cf0\b in\b0\cf1  SRF Info   um \cf2 22:30\cf1  oder um \cf2 23\cf1  Uhr
\par 
\par Wieso dann ausgerechnet um \cf2 10\cf1  vor \cf2 10!?!
\par ----\cf1 Simple Browser started\cf2 ----
\par ----\cf1 Simple Browser started\cf2 ----
\par }