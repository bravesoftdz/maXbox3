{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;\red128\green0\blue128;\red0\green128\blue128;\red255\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Untitled}}
\deflang1033\pard\plain\f0\fs20 \cf0\i //calculates a cipher suite from string _36
\par //key substitution during encryption, 
\par //DEMONSTRATES USE OF INCLUDE & DLL; loc's =126
\par 
\par //\{$I maxdefine.inc\}
\par //uses maxdefine.inc
\par 
\par \i0\cf1\b program\b0  simple_Cipher_Refactor\cf2 ;
\par 
\par \cf1\b function\b0  _SayHello2\cf2 :\cf1  boolean\cf2 ;
\par \cf1\b external\b0  \cf3 '_SayHello2@income.dll stdcall'\cf2 ;
\par 
\par \cf1\b const
\par \b0   \cf0\i //something to enlarge the entropy like substitution-box
\par \i0\cf1   C1 \cf2 =\cf1  \cf4 52845\cf2 ;
\par \cf1   C2 \cf2 =\cf1  \cf4 22719\cf2 ;\cf1  
\par   FNAME \cf2 =\cf1  \cf3 'readmefirst_maxbox.txt'\cf2 ;
\par \cf1   CIPHERNAME \cf2 =\cf1  \cf3 'crypto_readmefirst.txt'\cf2 ;
\par \cf1   MYKEY \cf2 =\cf1  \cf4 16549813\cf2 ;
\par 
\par \cf1\b type
\par \b0    TPasStyle \cf2 =\cf1  \cf2 (\cf1 a\cf2 ,\cf1 b\cf2 ,\cf1 c\cf2 ,\cf1 d\cf2 ,\cf1 e\cf2 ,\cf1 f\cf2 );
\par \cf1    TPasStyles \cf2 =\cf1  \b set\b0  \b of\b0  TPasStyle\cf2 ;
\par \cf1    
\par \b var\b0  TPas\cf2 :\cf1  TPasStyles\cf2 ;
\par 
\par \cf1\i \{$I maxdefine.inc\}
\par 
\par \{$I pas_includebox.inc\}
\par 
\par \i0\b FUNCTION\b0  HASH \cf2 (\cf1 X \cf2 :\cf1  \b string\b0\cf2 )\cf1  \cf2 :\cf1  INTEGER\cf2 ;
\par \cf1\b VAR\b0  I\cf2 ,\cf1 H \cf2 :\cf1  INTEGER\cf2 ;
\par \cf1\b BEGIN
\par \b0   TPas\cf2 :=[\cf1 a\cf2 ,\cf1 c\cf2 ];
\par \cf1    \cf0\i //if c in TPas then
\par \i0\cf1    \cf0\i //showmessage(' this is outside')
\par \i0\cf1   H \cf2 :=\cf1  \cf4 0\cf2 ;
\par \cf1   \b FOR\b0  I \cf2 :=\cf1  \cf4 1\cf1  \b TO\b0  \cf4 5\cf1  \b DO
\par \b0       H \cf2 :=\cf1  \cf2 (\cf1 H \cf2 *\cf1  \cf4 10\cf1  \cf2 +\cf1  ORD\cf2 (\cf1 X\cf2 [\cf1 I\cf2 ]));
\par \cf1   result\cf2 :=\cf1  H \b MOD\b0  \cf4 20\cf2 ;
\par \cf1\b END\b0\cf2 ;
\par 
\par 
\par \cf1\b function\b0  EncryptDecrypt\cf2 (\cf1\b const\b0  S\cf2 :\cf1  \b string\b0\cf2 ;\cf1  Key\cf2 :\cf1  word\cf2 ;\cf1  mode\cf2 :\cf1  char\cf2 ):\cf1  \b string\b0\cf2 ;
\par \cf1\b var
\par \b0   i\cf2 ,\cf1  myint\cf2 :\cf1  word\cf2 ;
\par \cf1\b begin
\par \b0   SetLength\cf2 (\cf1 Result\cf2 ,\cf1  length\cf2 (\cf1 s\cf2 ));
\par \cf1   \cf0\i //cipher in order of ord ;)
\par \i0\cf1   \b for\b0  i\cf2 :=\cf1  \cf4 1\cf1  \b to\b0  Length\cf2 (\cf1 S\cf2 )\cf1  \b do\b0  \b begin
\par \b0     myint\cf2 :=\cf1  ord\cf2 (\cf1 S\cf2 [\cf1 i\cf2 ])\cf1  \b xor\b0  \cf2 (\cf1 Key \b shr\b0  \cf4 8\cf2 )
\par \cf1     Result\cf2 [\cf1 i\cf2 ]:=\cf1  chr\cf2 (\cf1 myint\cf2 );
\par \cf1     \b if\b0  mode \cf2 =\cf1  \cf3 'E'\cf1  \b then
\par \b0       Key\cf2 :=\cf1  \cf2 (\cf1 ord\cf2 (\cf1 Result\cf2 [\cf1 i\cf2 ])\cf1  \cf2 +\cf1  Key\cf2 )\cf1  \cf2 *\cf1  C1 \cf2 +\cf1  C2\cf2 ;
\par \cf1     \b if\b0  mode \cf2 =\cf1  \cf3 'D'\cf1  \b then\b0  
\par       Key\cf2 :=\cf1  \cf2 (\cf1 ord\cf2 (\cf1 S\cf2 [\cf1 i\cf2 ])\cf1  \cf2 +\cf1  Key\cf2 )\cf1  \cf2 *\cf1  C1 \cf2 +\cf1  C2\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  StringToFile\cf2 (\cf1 acontent\cf2 ,\cf1  afilename\cf2 :\cf1\b string\b0\cf2 );
\par \cf1\b begin
\par \b0  \b with\b0  TFileStream\cf2 .\cf1 Create\cf2 (\cf1 afilename\cf2 ,\cf1  fmOpenWrite \b or\b0  fmCreate\cf2 )\cf1  \b do\b0  \b begin
\par \b0    \b try
\par \b0      Write\cf2 (\cf1 acontent\cf2 ,\cf1  length\cf2 (\cf1 acontent\cf2 ));
\par \cf1    \b finally
\par \b0      Free\cf2 ;
\par \cf1    \b end
\par \b0  \b end\b0   
\par \b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  FileToString\cf2 (\cf1 afilename\cf2 :\cf1  \b string\b0\cf2 ):\cf1\b string\b0\cf2 ;
\par \cf1\b begin
\par \b0  \b with\b0  TFileStream\cf2 .\cf1 Create\cf2 (\cf1 afilename\cf2 ,\cf1  fmOpenRead \b or\b0  fmShareCompat\cf2 )\cf1  \b do\b0  \b begin
\par \b0    \b try\b0  
\par      SetLength\cf2 (\cf1 result\cf2 ,\cf1  Size\cf2 );
\par \cf1      Read\cf2 (\cf1 result\cf2 ,\cf1  Size\cf2 );
\par \cf1    \b finally\b0  
\par      Free\cf2 ;
\par \cf1    \b end\b0   
\par  \b end
\par end\b0\cf2 ;
\par 
\par \cf1\b function\b0  StartLoadService\cf2 :\cf1  TStringList\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  fileExists\cf2 (\cf1 ExePath\cf2 +\cf3 'examples/'\cf2 +\cf1 FNAME\cf2 )\cf1  \b then\b0  \b begin
\par \b0     result\cf2 :=\cf1  TStringList\cf2 .\cf1 create\cf2 ;
\par \cf1     result\cf2 .\cf1 loadfromfile\cf2 (\cf1 ExePath\cf2 +\cf3 'examples/'\cf2 +\cf1 FNAME\cf2 );
\par \cf1   \b end
\par end\b0\cf2 ;\cf1     
\par 
\par \b function\b0  StartLoadService2\cf2 (\cf1 afname\cf2 :\cf1  \b string\b0\cf2 ):\cf1  TStringList\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  fileExists\cf2 (\cf1 ExePath\cf2 +\cf3 'examples/'\cf2 +\cf1 aFNAME\cf2 )\cf1  \b then\b0  \b begin
\par \b0     result\cf2 :=\cf1  TStringList\cf2 .\cf1 create\cf2 ;
\par \cf1     result\cf2 .\cf1 loadfromfile\cf2 (\cf1 ExePath\cf2 +\cf3 'examples/'\cf2 +\cf1 aFNAME\cf2 );
\par \cf1   \b end
\par end\b0\cf2 ;\cf1     
\par 
\par 
\par 
\par 
\par \b var
\par \b0   mycipher\cf2 ,\cf1  cipherback\cf2 :\cf1  \b string\b0\cf2 ;
\par \cf1   hashback\cf2 :\cf1  byte\cf2 ;
\par \cf1\b begin
\par \b0   hashback\cf2 :=\cf1  hash2\cf2 (\cf3 'maxland'\cf2 )
\par \cf1   writeln\cf2 (\cf1 inttoStr\cf2 (\cf1 hashback\cf2 ));
\par \cf1   \cf0\i //first encrypt loaded file and store it
\par \i0\cf1   \b try\b0  
\par     \cf0\i //mycipher:= encryptDecrypt(StartLoadService.text, MYKEY, 'E')
\par \i0\cf1     mycipher\cf2 :=\cf1  encryptDecrypt\cf2 (\cf1 StartLoadService2\cf2 (\cf1 fname\cf2 ).\cf1 text\cf2 ,\cf1  MYKEY\cf2 ,\cf1  \cf3 'E'\cf2 )
\par 
\par \cf1     StringToFile\cf2 (\cf1 mycipher\cf2 ,\cf1  CIPHERNAME\cf2 )
\par \cf1     \cf0\i //assert(4 = 5, 'not true');
\par \i0\cf1     assert\cf2 (\cf4 4\cf1  \cf2 =\cf1  \cf4 4\cf2 ,\cf1  \cf3 'true'\cf2 );
\par \cf1     \cf0\i //second decrypt file and store it back
\par \i0\cf1     cipherback\cf2 :=\cf1  FileToString\cf2 (\cf1 CIPHERNAME\cf2 );
\par \cf1     \b if\b0  length\cf2 (\cf1 mycipher\cf2 )\cf1  \cf2 =\cf1  length\cf2 (\cf1 cipherback\cf2 )\cf1  \b then\b0  \b begin
\par \b0       writeln\cf2 (\cf1 encryptDecrypt\cf2 (\cf1 cipherback\cf2 ,\cf1  MYKEY\cf2 ,\cf1  \cf3 'D'\cf2 ))
\par \cf1       StringToFile\cf2 (\cf1 encryptDecrypt\cf2 (\cf1 cipherback\cf2 ,\cf1  MYKEY\cf2 ,\cf1  \cf3 'D'\cf2 ),\cf1  FNAME\cf2 )
\par \cf1     \b end\b0\cf2 ;\cf1   
\par   \b finally\b0  
\par     \cf0\i //fileList.free; is just missing!!
\par \i0\cf1     \cf0\i //beep2(444, 400)
\par \i0\cf1   \b end
\par \b0    write\cf2 (\cf3 'this one liner'\cf2 )\cf1  
\par    write\cf2 (\cf3 'this one liner'\cf2 )
\par \cf1    write\cf2 (\cf3 'this one liner'\cf2 )
\par \cf1    
\par    \cf0\i //from C++ DLL
\par \i0\cf1    \b if\b0  _SayHello2 \b then
\par \b0      writeln\cf2 (\cf3 'dll invocation smashed'\cf2 );
\par \cf1    \cf0\i //from include file
\par \i0\cf1    intToFloat\cf2 (\cf4 234\cf2 );
\par \cf1    intToHex\cf2 (\cf4 123\cf2 ,\cf4 3\cf2 )
\par \cf1    \cf0\i //write('this one liner')  
\par \i0\cf1    writeln\cf2 (\cf1 AddThousandSeparator\cf2 (\cf3 '400500210'\cf2 ,\cf1  \cf3 ''''\cf2 ));\cf1  
\par    \cf0\i //showAboutBox;\}   
\par 
\par \i0\cf1\b end\b0\cf2 .
\par }