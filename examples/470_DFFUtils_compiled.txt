Program DFFUtils_Compilde; //just a testlist  on progress!

//http://www.delphiforfun.org/Programs/Library/Default.htm
//#locs:288
//#sign:Administrator: PC08: 27/04/2014 12:30:10 PM 
//http://www.delphiforfun.org/Programs/

procedure Testit;
begin
  //reformatMemo( const m : TCustomMemo)');
  //SetMemoMargins( m : TCustomMemo; const L, T, R, B : integer)');
  //MoveToTop( memo : TMemo)');
  //ScrollToTop( memo : TMemo)');
  //LineNumberClicked( memo : TMemo) : integer');
  //MemoClickedLine( memo : TMemo) : integer');
  //ClickedMemoLine( memo : TMemo) : integer');
  //MemoLineClicked( memo : TMemo) : integer');
  //LinePositionClicked( Memo : TMemo) : integer');
  //ClickedMemoPosition( memo : TMemo) : integer');
  //MemoPositionClicked( memo : TMemo) : integer');
  //AdjustGridSize( grid : TDrawGrid)');
  //DeleteGridRow( Grid : TStringGrid; const ARow : integer)');
  //InsertgridRow( Grid : TStringGrid; const ARow : integer)');
  //Sortgrid( Grid : TStringGrid; const SortCol : integer);');
  //Sortgrid1( Grid : TStringGrid; const SortCol : integer; sortascending : boolean);');
  //sortstrDown( var s : string)');
  //sortstrUp( var s : string)');
  //rotatestrleft( var s : string)');
  //dffstrtofloatdef( s : string; default : extended) : extended');
  //deblank( s : string) : string');
  //IntToBinaryString( const n : integer; MinLength : integer) : string');
  //FreeAndClearListBox( C : TListBox);');
  //FreeAndClearMemo( C : TMemo);');
  //FreeAndClearStringList( C : TStringList);');
  //dffgetfilesize( f : TSearchrec) : int64');
  //TPrimes
  //minmark
    //GetNextPandigital( size : integer; var Digits : array of integer) : boolean');
  //IsPolygonal( T : int64; var rank : array of integer) : boolean');
  //GeneratePentagon( n : integer) : integer');
  //IsPentagon( p : integer) : boolean');
  //isSquare( const N : int64) : boolean');
  //isCube( const N : int64) : boolean');
  //isPalindrome( const n : int64) : boolean;');
  //isPalindrome1( const n : int64; var len : integer) : boolean;');
  //GetEulerPhi( n : int64) : int64');
  //dffIntPower( a, b : int64) : int64;');
  //IntPower1( a : extended; b : int64) : extended;');
  ///gcd2( a, b : int64) : int64');
  //GCDMany( A : array of integer) : integer');
  //LCMMany( A : array of integer) : integer');
 //ContinuedFraction( A : array of int64; const wholepart : integer; var numerator, denominator : int64)');
  //dffFactorial( n : int64) : int64');
  //digitcount( n : int64) : integer');
  //nextpermute( var a : array of integer) : boolean');
  //convertfloattofractionstring(N:extended; maxdenom : integer; multipleof : boolean) : string');
  //convertStringToDecimal( s : string; var n : extended) : Boolean');
  //InttoBinaryStr( nn : integer) : string');
  //StrtoAngle( const s : string; var angle : extended) : boolean');
  //AngleToStr( angle : extended) : string');
  //deg2rad( deg : extended) : extended');
  //rad2deg( rad : extended) : extended');
  //GetLongToMercProjection( const long : extended) : extended');
  //GetLatToMercProjection( const Lat : Extended) : Extended');
  //GetMercProjectionToLong( const ProjLong : extended) : extended');
  //GetMercProjectionToLat( const ProjLat : extended) : extended');
    //TIntList
    
   // maxlistsize
     //TPlanet
       //TCoordType
         //TRPoint
           //TMoonRec
           
 //TrealPoint', 'record x : extended; y : extended; end');
  //Tline', 'record p1 : TPoint; p2 : TPoint; end');
  //TRealLine', 'record p1 : TRealPoint; p2 : TRealPoint; end');
  //TCircle', 'record cx : integer; cy : integer; r : integer; end');
  //TRealCircle', 'record cx : extended; cy : extended; r : extended; end');
  //PPResult', '( PPoutside, PPInside, PPVertex, PPEdge, PPError )');
 //realpoint( x, y : extended) : TRealPoint');
 //dist( const p1, p2 : TrealPoint) : extended');
 //intdist( const p1, p2 : TPoint) : integer');
 //dffLine( const p1, p2 : TPoint) : Tline;');
 //Line1( const p1, p2 : TRealPoint) : TRealline;');
 //dffCircle( const cx, cy, R : integer) : TCircle;');
 //Circle1( const cx, cy, R : extended) : TRealCircle;');
 //GetTheta( const L : TLine) : extended;');
 //GetTheta1( const p1, p2 : TPoint) : extended;');
 //GetTheta2( const p1, p2 : TRealPoint) : extended;');
 //Extendline( var L : TLine; dist : integer);');
 //Extendline1( var L : TRealLine; dist : extended);');
 //Linesintersect( line1, line2 : TLine) : boolean');
 //ExtendedLinesIntersect( Line1, Line2 : TLine; const extendlines : boolean; var IP : TPoint) : boolean;');
 //ExtendedLinesIntersect1( const Line1, Line2 : TLine; const extendlines : boolean; var IP : TRealPoint) : boolean;');
 //Intersect( L1, L2 : TLine; var pointonborder : boolean; var IP : TPoint) : boolean');
 //PointPerpendicularLine( L : TLine; P : TPoint) : TLine');
 //PerpDistance( L : TLine; P : TPoint) : Integer');
 //AngledLineFromLine( L : TLine; P : TPoint; Dist : extended; alpha : extended) : TLine;');
 //AngledLineFromLine1( L : TLine; P : TPoint; Dist : extended; alpha : extended; useScreenCoordinates : boolean) : TLine;');
 //PointInPoly( const p : TPoint; Points : array of TPoint) : PPResult');
 //PolygonArea( const points : array of TPoint; const screencoordinates : boolean; var Clockwise : boolean) : integer');
 //InflatePolygon( const points : array of Tpoint; var points2 : array of TPoint; var area : integer; const screenCoordinates : boolean; const inflateby : integer)');
 //PolyBuiltClockwise(const points:array of TPoint;const screencoordinates : boolean) : boolean');
 //DegtoRad( d : extended) : extended');
 //RadtoDeg( r : extended) : extended');
 //TranslateLeftTo( var L : TLine; newend : TPoint);');
 //TranslateLeftTo1( var L : TrealLine; newend : TrealPoint);');
 //RotateRightEndBy( var L : TLine; alpha : extended)');
 //RotateRightEndTo( var L : TLine; alpha : extended);');
 //RotateRightEndTo1( var p1, p2 : Trealpoint; alpha : extended);');
 //CircleCircleIntersect( c1, c2 : TCircle; var IP1, Ip2 : TPoint) : boolean;');
 //CircleCircleIntersect1( c1, c2 : TRealCircle; var IP1, Ip2 : TRealPoint) : boolean;');
 //PointCircleTangentLines( const C : TCircle; const P : TPoint; var L1, L2 : TLine) : boolean');
 //CircleCircleExtTangentLines( C1, C2 : TCircle; var C3 : TCircle; var L1, L2, PL1, PL2, TL1, Tl2 : TLine) : Boolean');
 
 //TCard
   //TDeck     
     //TCardSuit
     //TEdge
     //TNode
     //tMethodCall
     //tVerboseCall
     //TIntList
     
  //ParserFloat', 'extended');
  //7PParserFloat', '^ParserFloat // will not work');
  //TDFFToken', '( variab, constant, minus, sum, diff, prod, divis, mod'
   //+'ulo, IntDiv, IntDIVZ, integerpower, realpower, square, third, fourth, Func'
   //+'OneVar, FuncTwoVar )');
  //POperation', '^TOperation // will not work');
   //TMathProcedure
  {TDFFOperation', 'record Arg1 : PParserFloat; Arg2 : PParserFloat; D'
   +'est : PParserFloat; NextOperation : POperation; Operation : TMathProcedure'
   +'; Token : TToken; end');  }
   
   with TDrawGrid.create(self) do begin
     //setbounds
      Free;
     end;
  
end;

(*typedef struct tagNONCLIENTMETRICS {
  UINT    cbSize;
  int     iBorderWidth;
  int     iScrollWidth;
  int     iScrollHeight;
  int     iCaptionWidth;
  int     iCaptionHeight;
  LOGFONT lfCaptionFont;
  int     iSmCaptionWidth;
  int     iSmCaptionHeight;
  LOGFONT lfSmCaptionFont;
  int     iMenuWidth;
  int     iMenuHeight;
  LOGFONT lfMenuFont;
  LOGFONT lfStatusFont;
  LOGFONT lfMessageFont;
#if (WINVER >= 0x0600)
  int     iPaddedBorderWidth;
#endif *)

type nonclientmetrics = record
      //statis: Logfont;
          iMenuWidth: integer;
      iMenuHeight: integer;
      cbsize: integer;
     end; 

procedure makecaption(leftSide, Rightside:string; form:TForm);
var
  Metrics: nonClientMetrics;
  captionarea,spacewidth,nbrspaces:integer;
  b:TBitmap;
begin
  b:=TBitmap.create;  {to get a canvas}
  metrics.cbsize:=sizeof(Metrics);
  (*if SystemParametersInfo(SPI_GetNonCLientMetrics, sizeof(Metrics),@metrics,0)
  then  with metrics   do
  begin
    b.canvas.font.name:=Pchar(@metrics.LFCaptionFont.LfFaceName);
    with metrics.LFCaptionFont, b.canvas.font do
    begin
      height:=LFHeight;
      if lfweight=700 then style:=[fsbold];
      if lfitalic<>0 then style:=style+[fsitalic];
    end;
    {subtract 3 buttons + Icon + some border space}
    captionarea:=form.clientwidth-4*iCaptionwidth-4*iBorderWidth;;
    {n = # of spaces to insert}
    spacewidth:=b.canvas.textwidth(' ');
    nbrspaces:=(captionarea-b.canvas.textwidth(Leftside + Rightside)) div spacewidth;
    if nbrspaces>3 then form.caption:=LeftSide+stringofchar(' ',nbrspaces)+RightSide
    else form.caption:=LeftSide+' '+RightSide;
  end;  *)
  b.free;
//end;
end;


{**************** AngleToStr ***************}
function AngleToStr(angle:extended):string;
       var
         D:integer;
         M,S:extended;
       begin
         d:=Trunc(angle);
         m:=abs(frac(angle)*60);
         s:=frac(M)*60;
         m:=int(M);
         if s>=60-1e-10 then begin
           s:=s-60;
           m:=m+1;
end;
         if M=60 then begin
           m:=0;
           if d>=0 then inc(d) else dec(d);
end;
         result:=format('%3d %2d %5.2f',[d,trunc(m),s]);
end;

{****************** StrToAngle ******************}
function StrToAngle(s:string; var angle:extended):boolean;
       var
         n, sign:integer;
         w,ds,ms,ss:string;
       begin
         result:=true;
         ds:='0';
         ms:='0';
         ss:='0.0';
         w:=trim(s);
         if w[1]='-' then begin
           sign:=-1;
           delete(w,1,1);
end
else sign:=1;
         n:=pos(' ',w);
         if n>0 then begin
           ds:=copy(w,1,n-1);
           delete(w,1,n);
           w:=trim(w);
           n:=pos(' ',w);
           if n>0 then begin
             ms:=copy(w,1,n-1);
             delete(w,1,n);
             ss:=trim(w);
end
else ms:=w;
end
else ds:=w;
         try
           angle:=sign*(strtoint(ds)+strtoint(ms)/60+strtofloat(ss)/3600);
         except
           result:=false;
           angle:=0;
end;
end;

{Day of year function}
function JulianDay(d:TDateTime):integer;
      var
        y,m,day:word;
      begin
        decodedate(d,y,m,day);
        result:=trunc(d-encodedate(y-1,12,31));
end;




var mstring: string;

begin

  mstring:= 'this is sort of box';
  sortstrDown(mstring);
  writeln(mstring)
  mstring:= 'this is sort of box';
  sortstrUp(mstring);
  writeln(mstring)
  writeln(InttoBinaryStr(4711)) 
  writeln(InttoBinaryStr(9)) 

  //GeneratePentagon( n : integer) : integer');
 
end.

  maXbox converted by mX
  

