{***************************************************************
 * Project  : Console Expressions and Strips Routines with REGEX
 * App Name : 550_Expressions.TXT, 530_3DLab.TXT, #locs=219
 * Purpose  : Demonstrates Console out to box, STExpression adding func() at runtime!
 * Date     : #sign>Administrator: PC08: 22/01/2015 10:41:48 PM 
 ****************************************************************}

 //TODO: transfer the strip to a REGEX func
 //ref: maXbox3/source/REST/uPSI_StExpr.pas
   
 Program DOSConsoleCapture;
                        
 {Formats a StripTag Position of HTML in function or REGEX match selection}

  function ReadUntil(const ReadFrom, len: Integer; const C: Char; s: string): Integer;
  var
    j: Integer;
  begin
    for j := ReadFrom to Len do
      if (s[j] = C) then begin
        Result := j;
        Exit;
      end;
    Result := Len+1;
  end;
 
function StripTags2(const S: string): string;
var
  Len: Integer;
  i, APos: Integer;
begin
  Len := Length(S);
  i := 0;
  Result := '';
  while (i <= Len) do begin
    Inc(i);
    APos := ReadUntil(i, len, '<', s);
    Result := Result + Copy(S, i, APos-i);
    i := ReadUntil(APos+1,len, '>',s);
  end;
end;

FUNCTION Strip(const SubString: String; MainString: String): String;
{ =================================================================== }
VAR i,j: Integer;

BEGIN{Strip}
    j := length(SubString);
    If j <> 0 Then Begin
       i := Pos(SubString,MainString);
       While i <> 0 Do Begin
           Delete(MainString, i, j);
           i := Pos(SubString,MainString);
       End;
   End;
   result:= MainString;
END{Strip};


FUNCTION StripAny(const SubString: String; MainString: String): String;
{ =================================================================== }
VAR i,j: Integer;
      s: char;
BEGIN{Strip}
    //j := Ord(SubString[0]);
     j := length(SubString);
    While j > 0 Do Begin
       s := SubString[j];
       i := Pos(s,MainString);
       While i <> 0 Do Begin
           Delete(MainString,i,1);
           i := Pos(s,MainString);
       End;
       Dec(j);
   End;
   result:= MainString;
END{Strip};

  
procedure AppendValueToStrings(const SL: TStrings; StartingValue: Integer);
var i: Integer;
begin
  Assert(Assigned(SL),'not assigned');  // Make sure valid TStrings has been passed in
  for i := 0 to SL.Count - 1 do begin
    SL[i] := IntToStr(StartingValue) + ' ' + SL[i];
    Inc(StartingValue);
  end;
end;

function GrabLine2(const s: string; ALine: Integer): string;
var sl: TStringList;
begin
  sl:= TStringList.Create;
  try
    sl.LoadFromFile(s);
    Result:= sl[ALine - 1]; // index off by one
  finally
    sl.Free;
  end;
end;

function GetLinesCount(sFileName : String): Integer;
var oSL : TStringlist;
begin
   oSL:= TStringlist.Create;
   oSL.LoadFromFile(sFileName);
   result:= oSL.Count;
   oSL.Free;
end; //[/DELPHI]


procedure STEXpressionPattern;
begin
    with TStExpression.create(self) do begin
      AddConstant('MPI',3.14159);
      srlist:= TStringlist.create;
      GetIdentList(srlist);
      for it:= 0 to srlist.count-1 do 
        writeln(srlist.strings[it]);
      srlist.Free;  
      Expression:= '2^10 * ln(8 +MPI)';
      writeln(floattoStr(AnalyzeExpression))
      free;
    end;  
end;   

procedure TForm1Findwindow;
var
  wnd: HWND;
  i: Integer;
  s: string;
begin
  wnd := FindWindow('notepad', '');
  if wnd <> 0 then begin
    wnd := FindWindowEx(wnd, 0, 'Edit', '');
    // Write Text in Notepad.
    // Text ins Notepad schreiben.
    s := 'Hello';
    for i := 1 to Length(s) do
      //SendMessage(wnd, WM_CHAR, word(s[i]), 0);
    // Simulate Return Key.
    PostMessage(wnd, WM_KEYDOWN, VK_RETURN, 0);
    // Simulate Space.
    PostMessage(wnd, WM_KEYDOWN, VK_SPACE, 0);
  end;
end; 

// function to add in expression at runtime

  Function superPI(Value1: TStFloat): TStFloat;
  begin
    result:= value1 * PI;
  end;  

Const FName = 'maxboxlog2.log'; //'firstdemo3.txt';
      Testtext = 'this is CODEsign to mine!..?';
var   FormLab3D: TFormLab3D;
      myfunc: TStMethod1Param;

Begin   //main

//OpenDoc(exepath+FName)
 {Memo1.Lines.LoadFromFile(YourFileNameHere);
 AppendValueToStrings(Memo1.Lines, 10);
 Memo1.Lines.SaveToFile(YourFileNameHere);}
  //maxform1.N3dlab1click(self);

  writeln(Strip('<br/>','<p>This is text.<br/>This is line 2</p>'))
  writeln(StripString('<p>This is text.<br/>This is line 2</p>','<br/>'))
  writeln(StripAny('<br/>','<p>This is text.<br/>This is line 2</p>'))
  
  writeln(Strip('!',testtext));
  writeln(StripAny('!,.?',testtext));
 
  sr:= StripTags2('<p>This is text.<br/> This is line 2</p>');
  //ShowMessage(s);   // will display 'This is text.This is line 2'
  writeln(sr);   // will display 'This is text.This is line 2'
  writeln(StripTags('<p>This is text.<br/> This is line 2</p>'));
  
  Writeln(ReplaceRegExpr ('([</pbr>])*',
                          '<p>This is text.<br/> This is line 2</p>','', True))
  Writeln(ReplaceRegExpr ('<[^>]*>',
                          '<p>This is text.<br/> This is line 2</p>','', True))
 //CL.AddDelphiFunction('Function AnalyzeExpr( const Expr : AnsiString) : Double');
    
    writeln(floattostr(AnalyzeExpr('2^10 * ln(8)')))
    
    //add a function at runtime!
    with TStExpression.create(self) do begin
      AddConstant('MPI',3.14159);
      {srlist:= TStringlist.create;
      GetIdentList(srlist);
      for it:= 0 to srlist.count-1 do 
        writeln(srlist.strings[it]);
      srlist.Free;}
      myfunc:= @superPI;
      AddMethod1Param('getsuperpi', myfunc);  
      Expression:= '2^10 * ln(8 +MPI)';
      writeln(floattoStr(AnalyzeExpression))
      Expression:= '2^10 * ln(8 +MPI)+ getsuperpi(42)';
      writeln(floattoStr(AnalyzeExpression))
      free;
    end;
    
      srlist:= TStringlist.create;
      //ConsoleCapture('C:\', 'cmd.exe', '/c dir *.* /s',srlist);
      ConsoleCapture('C:\', 'cmd.exe', '/c dir *.*',srlist);
      writeln(srlist.text)
      srlist.Free;
      
     //ExecuteShell('cmd','/c rundll32.exe url.dll,TelnetProtocolHandler 172.134.77.119')
      // ExecuteShell('cmd','/c rundll32.exe url.dll,MailToProtocolHandler max@kleiner.ch')
      //ExecuteShell('cmd','/c rundll32.exe url.dll,NewsProtocolHandler borland.public.delphi.objectpascal')
 
       //rundll32.exe url.dll,NewsProtocolHandler borland.public.delphi.objectpascal
    SendCopyMessage('this is from outer box','TMaxForm1');
    //SendCopyMessage('this is from outer box','MainForm');
    
End.  // REGEX StripUtils

Ref:

http://www.swissdelphicenter.ch/en/showcode.php?id=770

function TForm1.RunCaptured(const _dirName, _exeName, _cmdLine: string): Boolean;
var
  start: TStartupInfo;
  procInfo: TProcessInformation;
  tmpName: string;
  tmp: Windows.THandle;
  tmpSec: TSecurityAttributes;
  res: TStringList;
  return: Cardinal;
begin
  Result := False;
  try
    { Setze ein Temporäres File }
    { Set a temporary file }
    tmpName := 'Test.tmp';
    FillChar(tmpSec, SizeOf(tmpSec), #0);
    tmpSec.nLength := SizeOf(tmpSec);
    tmpSec.bInheritHandle := True;
    tmp := Windows.CreateFile(PChar(tmpName),
           Generic_Write, File_Share_Write,
           @tmpSec, Create_Always, File_Attribute_Normal, 0);
    try
      FillChar(start, SizeOf(start), #0);
      start.cb          := SizeOf(start);
      start.hStdOutput  := tmp;
      start.dwFlags     := StartF_UseStdHandles or StartF_UseShowWindow;
      start.wShowWindow := SW_Minimize;
      { Starte das Programm }
      { Start the program }
      if CreateProcess(nil, PChar(_exeName + ' ' + _cmdLine), nil, nil, True,
                       0, nil, PChar(_dirName), start, procInfo) then
      begin
        SetPriorityClass(procInfo.hProcess, Idle_Priority_Class);
        WaitForSingleObject(procInfo.hProcess, Infinite);
        GetExitCodeProcess(procInfo.hProcess, return);
        Result := (return = 0);
        CloseHandle(procInfo.hThread);
        CloseHandle(procInfo.hProcess);
        Windows.CloseHandle(tmp);
        { Die Ausgaben hinzufügen }
        { Add the output }
        res := TStringList.Create;
        try
          res.LoadFromFile(tmpName);
          Memo1.Lines.AddStrings(res);
        finally
          res.Free;
        end;
        Windows.DeleteFile(PChar(tmpName));
      end
      else
      begin
        Application.MessageBox(PChar(SysErrorMessage(GetLastError())),
          'RunCaptured Error', MB_OK);
      end;
    except
      Windows.CloseHandle(tmp);
      Windows.DeleteFile(PChar(tmpName));
      raise;
    end;
  finally
  end;
end;



function CreateDOSProcessRedirected(const CommandLine, InputFile, OutputFile: string): Boolean;
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  SecAtrrs: TSecurityAttributes;
  hInputFile, hOutputFile: THandle;
begin
  Result := False;
  hInputFile := CreateFile(PChar(InputFile), GENERIC_READ, FILE_SHARE_READ,
    CreateInheritable(SecAtrrs), OPEN_EXISTING, FILE_ATTRIBUTE_TEMPORARY, 0);
  if hInputFile <> INVALID_HANDLE_VALUE then
  begin
    hOutputFile := CreateFile(PChar(OutPutFile), GENERIC_READ or GENERIC_WRITE,
      FILE_SHARE_READ, CreateInheritable(SecAtrrs), CREATE_ALWAYS,
      FILE_ATTRIBUTE_TEMPORARY, 0);
    if hOutputFile <> INVALID_HANDLE_VALUE then
    begin
      FillChar(StartupInfo, SizeOf(StartupInfo), #0);
      StartupInfo.cb := SizeOf(StartupInfo);
      StartupInfo.dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
      StartupInfo.wShowWindow := SW_HIDE;
      StartupInfo.hStdOutput := hOutputFile;
      StartupInfo.hStdInput := hInputFile;
      Result := CreateProcess(nil, PChar(CommandLine), nil, nil, True,
        CREATE_NEW_CONSOLE or NORMAL_PRIORITY_CLASS, nil, nil, StartupInfo,
        ProcessInfo);
      if Result then
      begin
        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
      end;
      CloseHandle(hOutputFile);
    end;
    CloseHandle(hInputFile);
  end;
end;


procedure SIRegister_TStExpression(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TStComponent', 'TStExpression') do
  with CL.AddClassN(CL.FindClass('TStComponent'),'TStExpression') do
  begin
    RegisterMethod('Constructor Create( AOwner : TComponent)');
    RegisterMethod('Function AnalyzeExpression : TStFloat');
    RegisterMethod('Procedure AddConstant( const Name : AnsiString; Value : TStFloat)');
    RegisterMethod('Procedure AddFunction0Param( const Name : AnsiString; FunctionAddr : TStFunction0Param)');
    RegisterMethod('Procedure AddFunction1Param( const Name : AnsiString; FunctionAddr : TStFunction1Param)');
    RegisterMethod('Procedure AddFunction2Param( const Name : AnsiString; FunctionAddr : TStFunction2Param)');
    RegisterMethod('Procedure AddFunction3Param( const Name : AnsiString; FunctionAddr : TStFunction3Param)');
    RegisterMethod('Procedure AddInternalFunctions');
    RegisterMethod('Procedure AddMethod0Param( const Name : AnsiString; MethodAddr : TStMethod0Param)');
    RegisterMethod('Procedure AddMethod1Param( const Name : AnsiString; MethodAddr : TStMethod1Param)');
    RegisterMethod('Procedure AddMethod2Param( const Name : AnsiString; MethodAddr : TStMethod2Param)');
    RegisterMethod('Procedure AddMethod3Param( const Name : AnsiString; MethodAddr : TStMethod3Param)');
    RegisterMethod('Procedure AddVariable(const Name: AnsiString;VariableAddr: PStFloat)');
    RegisterMethod('Procedure ClearIdentifiers');
    RegisterMethod('Procedure GetIdentList( S : TStrings)');
    RegisterMethod('Procedure RemoveIdentifier( const Name : AnsiString)');
    RegisterProperty('AsInteger', 'Integer', iptr);
    RegisterProperty('AsFloat', 'TStFloat', iptr);
    RegisterProperty('AsString', 'AnsiString', iptr);
    RegisterProperty('ErrorPosition', 'Integer', iptr);
    RegisterProperty('Expression', 'AnsiString', iptrw);
    RegisterProperty('LastError', 'Integer', iptr);
    RegisterProperty('AllowEqual', 'Boolean', iptrw);
    RegisterProperty('OnAddIdentifier', 'TNotifyEvent', iptrw);
    RegisterProperty('OnGetIdentValue', 'TStGetIdentValueEvent', iptrw);
  end;
end;


//#sign:Administrator: PC08: 22/01/2015 10:41:48 PM 
//#tech:.160perf: 0:0:1.122 threads: 4 192.168.1.40 10:41:48 PM 3.9.9.160


ref:

http://stackoverflow.com/questions/11229831/regular-expression-to-remove-html-tags-from-a-string

http://www.delphipages.com/forum/showthread.php?t=201629
http://useruploadedfiles.programmersheaven.com/48584/NMEA.pas


    Program SpammersAreParasites;
    var l1,l2: Srting;
    begin
      l1:='70';
      l2:='0';
      Bxo:=l1 + l2;
      Bxo:=(Bxo)
    (*
      l1:=97;
      l2:=9
     Bxo:=(l1 + l2);
    *)
    //end.

(*? Value of Bxo:    *)

{"There is a theory which states that if ever anybody discovers
exactly what the Universe is for and why it is here, it will
instantly disappear and be replaced by something even more
bizarre and inexplicable. There is another theory which states
that this has already happened."
-- Douglas Adams }


