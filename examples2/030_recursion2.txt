//shows a recursion of fibonacci, faculty numbers _30, #locs:178
//procedure stackout is just an educational help
//teaches the simularity of recursion & iterations, TASK: test with int64

program fibonacci_recursion_compare;
//{$S+}

var i: byte;

procedure stackOut;
begin
  i:= i + 1
  //writeln('stack return call of: ' +intToStr(i));
end;

function fibo(n: byte): integer;
begin
 //process steps
  if n < 2 then 
    result:= 1 else
    result:= fibo(n-2) + fibo(n-1);
  //test return of stack
  stackOut
end;

function faculty(n: integer): integer;
begin
 //process steps of fac!
  if n < 2 then 
    result:= 1 else
    result:= n * faculty(n-1);
  //test return of stack
  stackOut
end;

 function rectestWord(ac: string; n: byte): bool;
 begin
   if n < length(ac) then
     rectestWord(ac,n+1);
   write(ac[n]);   //rec back
 end;  
 

function facultytest(n: integer): integer;
begin
 if n < 2 then 
   result:= 1 else
   result:= n * faculty(n-1);
 end;
 
 procedure ExtractDuplicates1(List1, List2: TStringList; Dupes: TStrings);
   var
     Both: TStringList;
     I: Integer;
   begin
     Both := TStringList.Create;
     try
       Both.Sorted := True;
       Both.Duplicates := dupAccept;
       Both.AddStrings(List1);
       Both.AddStrings(List2);
       for I := 0 to Both.Count - 2 do
         if (Both[I] = Both[I + 1]) then
           if (Dupes.Count = 0) or (Dupes[Dupes.Count - 1] <> Both[I]) then
             Dupes.Add(Both[I]);
     finally
       Both.Free;
     end;
   end;


 function TestDuplicates(const dataStrList: TStringList): integer;
 begin 
   with TStringlist.create do begin
     {Duplicates:= dupIgnore;}
     for it:= 0 to DataStrList.count-1 do begin
       if IndexOf(DataStrList[it])< 0 then
         Add(DataStrList[it])
       else 
         inc(result)
     end;
     Free;
   end;
 end;

 function FindDuplicates(const datastringlist: TStringList): string;
 var TestStringList: TStringlist;
 begin
   TestStringList:= TStringList.Create;
   TestStringList.Sorted:= True;
   TestStringList.Duplicates:= dupIgnore;
   TestStringList.AddStrings(DataStringList);
   result:= (Format('%d duplicates discarded',
                      [DataStringList.Count - TestStringList.Count]));
   TestStringList.Free;
 end;             
 
 procedure RemoveDuplicates(const stringList: TStringList);
 var
   buffer: TStringList;
   cnt: Integer;
 begin
   stringList.Sort;
   buffer:= TStringList.Create;
   try
     buffer.Sorted:= True;
     buffer.Duplicates:= dupIgnore;
     buffer.BeginUpdate;
     {stringlist.Duplicates:= dupIgnore;
     stringlist.beginupdate;
     for cnt:= 0 to stringList.Count - 1 do
       writeln(stringlist[cnt]);}
     for cnt:= 0 to stringList.Count - 1 do
       buffer.Add(stringList[cnt]) ;
     buffer.EndUpdate;
     stringList.Assign(buffer);
   finally
     buffer.Free;
     buffer:= NIL;
     //FreeandNil(buffer);
   end;
 end;
 
procedure listdistinct;
var i: integer;
begin  
  with TStringList.Create do begin
    try
      Sorted:= true;
      Duplicates:= dupIgnore;
      Add('Eintrag 1');
      Add('Eintrag 1');
      Add('Eintrag 2');
      Add('Eintrag 1');
      Add('Eintrag 2');
      for i:= 0 to Count-1 do showmessage(Strings[i]);
    finally
      Free;
    end; 
  end;  
end; 

 var sl : TStringList;
     cnt : integer;

begin
  //clrscr;
  i:= 0;
  writeln('fibo is: ' + inttoStr(fibo(21)))
  writeln('fibo compare is: ' + floattoStr(fibo(21)))
  writeln('fibo compare is: ' + floattoStr(fibonacci(22)))
  writeln('faculty is: ' + inttoStr(faculty(12)))
  writeln('faculty compare is: ' + floattoStr(fact(12)))
  rectestWord('nebel',1);
  
   Randomize;
   sl:= TStringList.Create;
   try
     //sl.sorted:= true;
     //sl.Duplicates:= dupIgnore;
       //sl.beginupdate; 
     for cnt:= 1 to 1000 do
       sl.Add(IntToStr(Random(4000))) ;
     {sl.sort; for cnt:= 1 to 1000 do 
     //stringlist.beginupdate;
        writeln((sl[cnt-1]));}
        
       Writeln('Test Duplicates: '+inttostr(TestDuplicates(sl))+
                                  ' duplicate items found');
       Writeln('With Duplicates: '+FindDuplicates(sl)) 
       //ShowMessage('With duplicates: ' + #13#10 + IntToStr(sl.Count));
       RemoveDuplicates(sl) ;
       Writeln('Without Duplicates: '+IntToStr(sl.Count)+' items found');
     finally
       sl.Free;
    end;
    ListDistinct;
End.