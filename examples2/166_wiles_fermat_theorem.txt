PROGRAM FermatWilesDemo_App_mX;

//http://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem
//unit uPSI_xrtl_math_Integer;


CONST 
//<Constant declarations> 
  TEXTOUT = 'hi world of fermat code rage2';

{TYPE 
<Type declarations>} 

//Var 
//<Variable declarations>
  //i: integer;

//<FUNCTION>
//<PROCEDURE> 

function GetBigIntPower2(aval, exp: integer): string;
  //unit mybigint
var mbResult: TMyBigInt;
     i: integer;
begin
  mbResult:= TMyBigInt.Create(1);
  try
    for i:= 1 to exp do 
      //mbResult.Multiply(mbresult, mbresult);
      mbResult.Multiply1(mbresult, aval);
    Result:= mbResult.ToString;
  finally 
    //FreeAndNil(mbResult);
    mbResult.Free;
  end;
end;

function GetBigAddObj(aval, aexp: integer): TMybigint;
  //unit mybigint
var mbResult: TMyBigInt;
     i: integer;
begin
  mbResult:= TMyBigInt.Create(1);
  try
    for i:= 1 to aexp do 
        //mbResult.Multiply(mbresult, mbresult);
      mbResult.Multiply1(mbresult, aval);
    Result:= mbResult;
  finally 
    //FreeAndNil(mbResult);
    //mbResult.Free;
  end;
end;

procedure bigdecimal_fermatdemo;
//var adig: TDigits;
begin
    with TStDecimal.create do begin
      AsInt(rmnormal)
      //addone;
      asstring:= '1782';
      addone;
      //RaiseToPower(12)
      writeln(asString)
      Free;
    end;  
end;

function BigAdd2(aone, atwo: string): string;
var bigint, bigint1, bigintres: TXRTLInteger;
begin
  XRTLFromString(aone, bigint, 10);
  XRTLFromString(atwo, bigint1, 10);
  XRTLAdd(bigint,bigint1,bigintres);
  result:= XRTLToString(bigintres,10,10);
end;
    



  var sumferm,sumtot: string;
      big1, big2, sum3: TMyBigInt;

BEGIN  //Main
//<Executable statements>
  for it:= 1 to 3 do 
    //if it > 1 then begin
    Writeln(TEXTOUT+CRLF);
    //Writeln(TEXTOUT+CRLF);
  //end;  
  maXcalcF('2^64 /(60*60*24*365)') 
  //opendoc('C:\maXbook\maxbox3\newtemplateifthen.psb')  
//<Definitions>  

  //2.541210259E+39    CASIO FX-880P
  maXcalcF('1782^12 + 1841^12')  //2.54121025861459E39

   writeln(powerbig(3987,12));
   writeln(powerbig(4365,12));
   writeln(powerbig(4472,12));
   writeln(bigexp('4472','12'));
   writeln(bigadd(powerbig(3987,12),powerbig(4365,12)));
   maXcalcF('3987^12 + 4365^12')  //6.39766563496986E43
   maXcalcF('4472^12')            //6.39766563484867E43
   maXcalcF('(3987^12 + 4365^12)^(1/12)')  //4472.00000000706
  
   writeln('sim proof 2:')
   
   maXcalcF('1782^12 + 1841^12')  //2.54121025861459E39
   writeln(powerbig(1782,12));
   writeln(powerbig(1841,12));
   writeln(powerbig(1922,12));
   writeln(bigexp('1922','12'));
   big1:=  GetBigAddObj(1782,12)
   big2:=  GetBigAddObj(1841,12)
   sum3:=  TMyBigInt.Create(0);
     sum3.add(big1, big2)
     writeln('sum3: ');
     writeln('A:'+sum3.ToString);   //10 positions precise!
   big1.free; 
   big2.free;
   sum3.free;  
   
   sumferm:= (powerbig(1922,12));
   //sumtot:= bigadd(powerbig(12,1782),powerbig(12,1841));
   sumtot:= bigadd(powerbig(1782,12),powerbig(1841,12));
   writeln('B:'+sumtot);
   sumtot:= bigadd2(powerbig(1782,12),powerbig(1841,12));
   writeln('C:'+sumtot);
   
   writeln('');
   writeln(inttostr(length(sumferm)))
   writeln(inttostr(length(sumtot))) 
   writeln(sumtot);
   writeln(powerbig(1922,12));
   
   bigdecimal_fermatdemo;
   writeln(getbigPI)
  
END. 


Hier die zwei Gegenbeispiele für den Wiles'schen Beweis des Fermatschen Satzes zwecks rechnerischer Nachprüfung:
1) 3987^12 + 4365^12 = 4472^12 und
2) 1782^12 + 1841^12 = 1922^12
falsch ist: 3987 12 + 4365 12 = 4472 12 . 

   writeln(getbigadd('1025397835622633634807550462948226174976','1515812422991955541481119495194202351681')))


1782^12
1025397835622633634807550462948226174976
1841^12
1515812422991955541481119495194202351681
1922^12
2541210259314801410819278649643651567616



12^1782
1261770753975303858097460823035366184036173995245701191673444869505090406373113565046862477976509467785074010180050572588962133496380348100086287700901816232809720191927780959744912941239690337964799405662430470942286833808213735244347844468505460257176484518217684401142904153102866989445538240965514764388966226766692097035292833128866717007974901606906827887591224143875405589103405706834696136518547485437921856449027236969172613600912715049333630049341432056459369746924117601242745565897710385484016791011313177932780080475984888637037563158724697894343792130500662332847587677331189839345750126888020328366191507857695515058128034352723492443652349850907818911300278868151793850652333172790721782329910765771195257300420099375502145790408738057531592887631266057474923571703068483692174086499489614569730457116137999059121923030442102676640931322451211810760368519804479871360639632003489948605155613996115342677652719468370547943066380501911959046454047147990237610781060818887191507907104750784807916403844776461266005296137400329368376223630987242265176557090571142808682863708208614119853054522041718915401857946829249241104159398264024472043213160527996979917067332028134396754278085371384293581554713089170606673324874821058518031827380736802020217035282964584578262655089763414369363069492705348781957978970084278994230874252889429659257495763422248058760907863172975432702522950962762014967505214921790298528124619633052006014747780929549620189567391026158894300626738249193935993829618789977558343852046211552162356454766918241891499507940899926352590892697022331399872540175652668590865507442576081769385416396277338576499819671394897039653988700480747335575476345632178742153639634816511648831679656246582967333120420064346525998205722582911245104911527350092088396541380225133878683844929265176769947785112053101375708396999392516915994566568317750882639580002989748915140292305305410549281036603379154944

12^1841
5924803805835792573228208095002111018150393412132853765894405497382343558504938333734910014474127536854455343232377003843330152574684860970830639884233319426776346201792803290023773814364140481863184924939938207170380323238545244911260156107647755138212913163194030236932012859094710830093103765817897537128985758268057318141005165624869146039928100353327840936855926763475841742482173406211144605888068193216135407935159707158680334112329050105776587361157568440585250495075044953477557680769333431140426623706559287111615912856867851988430259534074480814525364715546740270181619963743982008844493296552461300659151638670585699139490601845547202848670193039219890145258380846597241829671533069779159432607685650371169297383935008349775784947901418212677092152942391656459621493699246836211982067624239839318805360465273523941065996726569180518086843012721641403183120540441761139272111854862872851270111759286378577595190670759774842700115019508899366644508379829048169821217824177145893053230238836332024718771532670433387471852947789777560827570359631835487850742683720822852626063466721294817936222938726794788309223776934181541739156385664658148369511082525314120505261403414342198529527748212369535133162563351918515224889121498080659452274196665192622350610659424524202220496858162540916331055718859016163878193057233400850203857480374444792160160194609546458461894397892308397528349792059849751770834362206093721445679865330411069979723015068860442104557399197570442887947351935210397270774717914262154684510232281431354606016367076354013892010079125321958384363718181215636173387411426000104198580733071055065432205618471951373211328274790525747888512759034081913946555741412336854302712271125285527392792238253590624003856031855650384203191227359388456430576613462270204679324410633360020299085585943372888919935233217819707892637062222273385581306449675240268177465263253743940018635556884732284731887673924389323058448530970382698962705893466418383794606875264708974542323712

12^1922
15358715775832160695766686592430376845820701701243355207056264116011527659765328117251563105341511884862045857740201026504661828438231882656982726667282097276524000205331702323001752000288610738444510104167012771449228147638814976402411498835800553677025623683791544911955512025583401887046976871147202592920738313191967802156652965035495008258203882828391110823786965225676537135591880433184944417138854067645531967165080804228647753380510035382164425227810323556799930371031861921247337612809436171405751772806532566022784996771246001240012018682584968763273443023371697178641082064067328848867092574441701519807890218852686646769227912993795641704269398621475830420029697408204664478492210030610565540689193288479410538998134403162467511106364941384263830237137740902749510167136543785489224258619190292526846657047485116436142829690867177843721757460190007031317478007859072276913019702936180247117777830077179801002023231276271353799068983721380470433454866426097707792026611352918705267767045109110854274090297116304256862383294469460079849790588817235603112760479133137755537516213293356578639280646545272320581236560426116939545792507259911509510466579522993149894858152173678509616059812314381809814039850576755124157453700039080388717411024386548961255240762302945688207600696501587577646562146545486442127804620243754980621103197876116944109493836420270006858795650778819355402980109253577286046233010423522843107605821148323457717645779789310250690691706057113480996570800029873881919354233911535899041870940329130256416887445559020970531421351790252621900705723985673659544047467196864215362351135996108561265536926457606767397076942143625782066186832431255813628631124592681195353197714236092975209477782834071401450122383664786433838186996929555831469494651646729299569697741133281570476422581975937207907937533947440328887533360861482185278210339237734353898490960527428938410687876152604661571346890491472163858322448935694817903857765015668647090294144191178683526644467209847134006061426510648122081064760026915750462046944967634492555921641371045770297344

 type
  TMyBigInt = class
  private
    Len: Integer;
    Value: AnsiString;
    procedure Trim;
    procedure Shift(k: Integer);
    procedure MultiplyAtom(Multiplier1: TMyBigInt; Multiplier2: Integer);
  public
    constructor Create(iValue: Integer = 0);
    procedure Add(Addend1, Addend2: TMyBigInt);
    procedure Multiply(Multiplier1, Multiplier2: TMyBigInt); overload;
    procedure Multiply(Multiplier1: TMyBigInt; Multiplier2: Integer); overload;
    function ToString: string;
    procedure CopyFrom(mbCopy: TMyBigInt);
  end;

implementation

constructor TMyBigInt.Create(iValue: Integer = 0);
var 
  sTmp: ShortString; 
  i: Integer;
begin
  inherited Create;
  sTmp := IntToStr(abs(iValue));
  Len  := Length(sTmp);
  SetLength(Value, Len);
  for i := 1 to Len do Value[i] := Chr(StrToInt(sTmp[Len - i + 1]));
end;

procedure TMyBigInt.Add(Addend1, Addend2: TMyBigInt);
  { zwei TMyBigInt miteinander addieren }
var 
  i, iCarry, iTemp: Integer;
begin
  // Länge der Wert-Strings angleichen
  iTemp := max(Addend1.Len, Addend2.Len);
  SetLength(Value, iTemp);
  for i := Len + 1 to iTemp do Value[i] := #0; // Für den Fall Addend1/Addend2=Self
  Len := iTemp;
  // Berechnung von Übertrag und Summe
  iCarry := 0;
  for i := 1 to Len do begin
    iTemp := iCarry;
    if i <= Addend1.Len then iTemp := iTemp + Ord(Addend1.Value[i]);
    if i <= Addend2.Len then iTemp := iTemp + Ord(Addend2.Value[i]);
    Value[i] := Char(iTemp mod Base);
    iCarry   := iTemp div Base;
  end;
  if iCarry > 0 then begin
    Len := Len + 1;
    SetLength(Value, Len);
    Value[Len] := Char(iCarry);
  end;
end;

procedure TMyBigInt.Multiply(Multiplier1, Multiplier2: TMyBigInt);
  { zwei TMyBigInt miteinander multipliziren }
var 
  mbResult, mbTemp: TMyBigInt; 
  i: Integer;
begin
  mbResult := TMyBigInt.Create;
  try
    mbTemp := TMyBigInt.Create;
    try
      for i := 1 to Multiplier2.Len do begin
        // Multiplizieren nach der "Schulmethode"
        mbTemp.MultiplyAtom(Multiplier1, Ord(Multiplier2.Value[i]));
        mbTemp.Shift(i - 1);
        mbResult.Add(mbResult, mbTemp);
      end;
    finally 
      FreeAndNil(mbTemp);
    end;
    CopyFrom(mbResult);
  finally 
    FreeAndNil(mbResult);
  end;
end;

procedure SIRegister_TStDecimal(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TOBJECT', 'TStDecimal') do
  with CL.AddClassN(CL.FindClass('TOBJECT'),'TStDecimal') do
  begin
    RegisterMethod('Constructor Create');
    RegisterMethod('Function Compare( X : TStDecimal) : integer');
    RegisterMethod('Function IsNegative : boolean');
    RegisterMethod('Function IsOne : boolean');
    RegisterMethod('Function IsPositive : boolean');
    RegisterMethod('Function IsZero : boolean');
    RegisterMethod('Procedure SetToOne');
    RegisterMethod('Procedure SetToZero');
    RegisterMethod('Procedure Assign( X : TStDecimal)');
    RegisterMethod('Procedure AssignFromFloat( aValue : double)');
    RegisterMethod('Procedure AssignFromInt( aValue : integer)');
    RegisterMethod('Function AsFloat : double');
    RegisterMethod('Function AsInt( aRound : TStRoundMethod) : integer');
    RegisterMethod('Procedure Abs');
    RegisterMethod('Procedure Add( X : TStDecimal)');
    RegisterMethod('Procedure AddOne');
    RegisterMethod('Procedure ChangeSign');
    RegisterMethod('Procedure Divide( X : TStDecimal)');
    RegisterMethod('Procedure Multiply( X : TStDecimal)');
    RegisterMethod('Procedure RaiseToPower( N : integer)');
    RegisterMethod('Procedure Round( aRound : TStRoundMethod; aDecPl : integer)');
    RegisterMethod('Procedure Subtract( X : TStDecimal)');
    RegisterMethod('Procedure SubtractOne');
    RegisterProperty('AsString', 'AnsiString', iptrw);
  end;
end;

 CL.AddDelphiFunction('function BigMulu(aone, atwo: string): string;');
 function BigNumber(aone, atwo: string): string;');
 function BigExp(aone, atwo: string): string;');
 function BigMul(aone, atwo: string): string;');
 function BigAdd(aone, atwo: string): string;');
 function BigSub(aone, atwo: string): string;');
 function BigFactorial(aone: string): string;');
 function BigFact(aone: string): string;');





[PROCS]
Proc [0] Export: !MAIN -1
 [0] ASSIGN GlobalVar[13], [1]
 [15] PUSHTYPE 27(U8) // 1
 [20] COMPARE into Base[1]: GlobalVar[13] <= [3]
 [41] COND_NOT_GOTO currpos + 60 Base[1] [111]
 [51] PUSHTYPE 18(String) // 2
 [56] ASSIGN Base[2], ['hi world of code rage'#13#10]
 [94] CALL 1
 [99] POP // 1
 [100] INC GlobalVar[13]
 [106] GOTO currpos + 4294967205 [20]
 [111] POP // 0
 [112] PUSHTYPE 18(String) // 1
 [117] ASSIGN Base[1], ['2^64 /(60*60*24*365)']
 [152] CALL 2
 [157] POP // 0
 [158] RET
Proc [1]: External Decl: \00\00 WRITELN
Proc [2]: External Decl: \00\00 MAXCALCF
Proc [3] Export: !MASTERPROC -1
 [0] CALL 0
 [5] RET
Decompiled Code maXbox: newtemplateifthen.txt

Proc [0] Export: !MAIN -1
 [0] ASSIGN GlobalVar[8], [1]
 [15] PUSHTYPE 27(U8) // 1
 [20] COMPARE into Base[1]: GlobalVar[8] <= [3]
 [41] COND_NOT_GOTO currpos + 60 Base[1] [111]
 [51] PUSHTYPE 18(String) // 2
 [56] ASSIGN Base[2], ['hi world of code rage'#13#10]
 [94] CALL 1
 [99] POP // 1
 [100] INC GlobalVar[8]
 [106] GOTO currpos + 4294967205 [20]
 [111] POP // 0

----app_template_loaded_code----
----File newtemplate.txt not exists - now saved!----


Marco and I agreed to maintain in the first step the following components, maybe we will add further in the future:

1. Orpheus (Win32 and Win64)
2. Abbrevia (Win32, Win64, MacOSX, iOS and Android)
3. Virtual Tree (Win32 and Win64)
4. SynEdit (Win32 and Win64)
5. LockBox (Win32, Win64, MacOSX, iOS and Android)
6. Async Professional (Win32)
7. PowerPDF (Win32 and Win64)