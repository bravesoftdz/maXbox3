Program PasParse;

//---<This file is auto generated by GoldParser>-------------------------------
// Pascal_Engine.pgt, Version 1.1, Aug 2006
// (c) Rob F.M. van den Brink, the Netherlands, R.F.M.vandenBrink@hccnet.nl
//-----------------------------------------------------------------------------
  {$UNDEF  IsDELPHI       //define to compile with Delphi specific needs}
  {$UNDEF  IsNESTED       //define to nest comment blocks within comments}
//-----------------------------------------------------------------------------
  {$UNDEF  Debug_LEXER    //define if lexer  (DFA) are to be dumped to screen} 
  {$UNDEF  Debug_LEXEMES  //define if lexemes are to be dumped, before they are tokenized}
  {$DEFINE Debug_TOKENS   //define if tokenized lexemes are to be dumped} 
  {$UNDEF  Debug_PARSER   //define if parser (LALR) states are to be dumped} 
  {$DEFINE Debug_ACTIONS  //define if called actions are to be dumped } 
  {$DEFINE Debug_ERRORS   //undefine if not used} 
  {$UNDEF  Debug_HEAPMEM  //define if status of memory heap is to be reported} 
//-----------------------------------------------------------------------------


{$IFDEF IsDELPHI} {$APPTYPE CONSOLE} {$ENDIF}

const Tab=chr(9); LF=Chr(10); CR=Chr(13);  FF=Chr(12); EOF=Chr(26);

//-----------------------------------------------------------------------------
// ERROR TAGS
//-----------------------------------------------------------------------------
const Err_Lexeme        = 1;
      Err_Skipped       = 2; 
      Err_Halted	= 3;
      Err_Overflow      = 4;
      Err_StackOverflow = 5;

//-----------------------------------------------------------------------------
// TOKEN TAGS
//-----------------------------------------------------------------------------
const TagCount = 114;
      Tag_EOF                    =   0;   // Kind=3;  Lex='(EOF)';  
      Tag_ERROR                  =   1;   // Kind=7;  Lex='(Error)';  
      Tag_WHITESPACE             =   2;   // Kind=2;  Lex='(Whitespace)';  
      Tag_COMMENTEND             =   3;   // Kind=5;  Lex='(Comment End)';  
      Tag_COMMENTLINE            =   4;   // Kind=6;  Lex='(Comment Line)';  
      Tag_COMMENTSTART           =   5;   // Kind=4;  Lex='(Comment Start)';  
      Tag_MINUS                  =   6;   // Kind=1;  Lex='-';  
      Tag_LPARAN                 =   7;   // Kind=1;  Lex='(';  
      Tag_RPARAN                 =   8;   // Kind=1;  Lex=')';  
      Tag_TIMES                  =   9;   // Kind=1;  Lex='*';  
      Tag_COMMA                  =  10;   // Kind=1;  Lex=',';  
      Tag_DOT                    =  11;   // Kind=1;  Lex='.';  
      Tag_DOTDOT                 =  12;   // Kind=1;  Lex='..';  
      Tag_DIV                    =  13;   // Kind=1;  Lex='/';  
      Tag_COLON                  =  14;   // Kind=1;  Lex=':';  
      Tag_COLONEQ                =  15;   // Kind=1;  Lex=':=';  
      Tag_SEMI                   =  16;   // Kind=1;  Lex=';';  
      Tag_LBRACKET               =  17;   // Kind=1;  Lex='[';  
      Tag_RBRACKET               =  18;   // Kind=1;  Lex=']';  
      Tag_CARET                  =  19;   // Kind=1;  Lex='^';  
      Tag_PLUS                   =  20;   // Kind=1;  Lex='+';  
      Tag_LT                     =  21;   // Kind=1;  Lex='<';  
      Tag_LTEQ                   =  22;   // Kind=1;  Lex='<=';  
      Tag_LTGT                   =  23;   // Kind=1;  Lex='<>';  
      Tag_EQ                     =  24;   // Kind=1;  Lex='=';  
      Tag_GT                     =  25;   // Kind=1;  Lex='>';  
      Tag_GTEQ                   =  26;   // Kind=1;  Lex='>=';  
      Tag_AND                    =  27;   // Kind=1;  Lex='AND';  
      Tag_ARRAY                  =  28;   // Kind=1;  Lex='ARRAY';  
      Tag_BEGIN                  =  29;   // Kind=1;  Lex='BEGIN';  
      Tag_CASE                   =  30;   // Kind=1;  Lex='CASE';  
      Tag_CHARLITERAL            =  31;   // Kind=1;  Lex='CharLiteral';  
      Tag_COMMENTEND1            =  32;   // Kind=1;  Lex='CommentEnd1';  
      Tag_COMMENTEND2            =  33;   // Kind=1;  Lex='CommentEnd2';  
      Tag_COMMENTSTART1          =  34;   // Kind=1;  Lex='CommentStart1';  
      Tag_COMMENTSTART2          =  35;   // Kind=1;  Lex='CommentStart2';  
      Tag_CONST                  =  36;   // Kind=1;  Lex='CONST';  
      Tag_DECLITERAL             =  37;   // Kind=1;  Lex='DecLiteral';  
      Tag_DIV2                   =  38;   // Kind=1;  Lex='DIV';  
      Tag_DO                     =  39;   // Kind=1;  Lex='DO';  
      Tag_DOWNTO                 =  40;   // Kind=1;  Lex='DOWNTO';  
      Tag_ELSE                   =  41;   // Kind=1;  Lex='ELSE';  
      Tag_END                    =  42;   // Kind=1;  Lex='END';  
      Tag_FILE                   =  43;   // Kind=1;  Lex='FILE';  
      Tag_FLOATLITERAL           =  44;   // Kind=1;  Lex='FloatLiteral';  
      Tag_FOR                    =  45;   // Kind=1;  Lex='FOR';  
      Tag_FORWARD                =  46;   // Kind=1;  Lex='FORWARD';  
      Tag_FUNCTION               =  47;   // Kind=1;  Lex='FUNCTION';  
      Tag_HEXLITERAL             =  48;   // Kind=1;  Lex='HexLiteral';  
      Tag_ID                     =  49;   // Kind=1;  Lex='id';  
      Tag_IF                     =  50;   // Kind=1;  Lex='IF';  
      Tag_MOD                    =  51;   // Kind=1;  Lex='MOD';  
      Tag_NOT                    =  52;   // Kind=1;  Lex='NOT';  
      Tag_OF                     =  53;   // Kind=1;  Lex='OF';  
      Tag_OR                     =  54;   // Kind=1;  Lex='OR';  
      Tag_PROCEDURE              =  55;   // Kind=1;  Lex='PROCEDURE';  
      Tag_PROGRAM                =  56;   // Kind=1;  Lex='PROGRAM';  
      Tag_RECORD                 =  57;   // Kind=1;  Lex='RECORD';  
      Tag_REPEAT                 =  58;   // Kind=1;  Lex='REPEAT';  
      Tag_STRINGLITERAL          =  59;   // Kind=1;  Lex='StringLiteral';  
      Tag_SYNERROR               =  60;   // Kind=1;  Lex='SynError';  
      Tag_THEN                   =  61;   // Kind=1;  Lex='THEN';  
      Tag_TO                     =  62;   // Kind=1;  Lex='TO';  
      Tag_TYPE                   =  63;   // Kind=1;  Lex='TYPE';  
      Tag_UNTIL                  =  64;   // Kind=1;  Lex='UNTIL';  
      Tag_VAR                    =  65;   // Kind=1;  Lex='VAR';  
      Tag_WHILE                  =  66;   // Kind=1;  Lex='WHILE';  
      Tag_ACTUALS                =  67;   // Kind=0;  Lex='<Actuals>';  
      Tag_ARG                    =  68;   // Kind=0;  Lex='<Arg>';  
      Tag_ARGUMENTLIST           =  69;   // Kind=0;  Lex='<ArgumentList>';  
      Tag_ARGUMENTS              =  70;   // Kind=0;  Lex='<Arguments>';  
      Tag_ASSIGNMENTSTATEMENT    =  71;   // Kind=0;  Lex='<AssignmentStatement>';  
      Tag_CASE2                  =  72;   // Kind=0;  Lex='<Case>';  
      Tag_CASELIST               =  73;   // Kind=0;  Lex='<CaseList>';  
      Tag_CASESTATEMENT          =  74;   // Kind=0;  Lex='<CaseStatement>';  
      Tag_COMPOUNDSTATEMENT      =  75;   // Kind=0;  Lex='<CompoundStatement>';  
      Tag_CONSTANT               =  76;   // Kind=0;  Lex='<constant>';  
      Tag_CONSTANTDEF            =  77;   // Kind=0;  Lex='<ConstantDef>';  
      Tag_CONSTANTDEFINITIONLIST =  78;   // Kind=0;  Lex='<ConstantDefinitionList>';  
      Tag_CONSTANTDEFINITIONS    =  79;   // Kind=0;  Lex='<ConstantDefinitions>';  
      Tag_CONSTANTLIST           =  80;   // Kind=0;  Lex='<ConstantList>';  
      Tag_DECLARATIONS           =  81;   // Kind=0;  Lex='<Declarations>';  
      Tag_DIMENSION              =  82;   // Kind=0;  Lex='<Dimension>';  
      Tag_DIMENSIONLIST          =  83;   // Kind=0;  Lex='<DimensionList>';  
      Tag_EXPRESSION             =  84;   // Kind=0;  Lex='<Expression>';  
      Tag_EXPRESSIONLIST         =  85;   // Kind=0;  Lex='<ExpressionList>';  
      Tag_FACTOR                 =  86;   // Kind=0;  Lex='<Factor>';  
      Tag_FIELD                  =  87;   // Kind=0;  Lex='<Field>';  
      Tag_FIELDLIST              =  88;   // Kind=0;  Lex='<FieldList>';  
      Tag_FORSTATEMENT           =  89;   // Kind=0;  Lex='<ForStatement>';  
      Tag_FUNCTIONCALL           =  90;   // Kind=0;  Lex='<FunctionCall>';  
      Tag_FUNCTIONHEADER         =  91;   // Kind=0;  Lex='<FunctionHeader>';  
      Tag_IDLIST                 =  92;   // Kind=0;  Lex='<IdList>';  
      Tag_IFSTATEMENT            =  93;   // Kind=0;  Lex='<IfStatement>';  
      Tag_PROCEDURECALL          =  94;   // Kind=0;  Lex='<ProcedureCall>';  
      Tag_PROCEDUREDEC           =  95;   // Kind=0;  Lex='<ProcedureDec>';  
      Tag_PROCEDUREDECLARATIONS  =  96;   // Kind=0;  Lex='<ProcedureDeclarations>';  
      Tag_PROCEDUREHEADER        =  97;   // Kind=0;  Lex='<ProcedureHeader>';  
      Tag_PROGRAM2               =  98;   // Kind=0;  Lex='<Program>';  
      Tag_PROGRAMHEADER          =  99;   // Kind=0;  Lex='<ProgramHeader>';  
      Tag_REPEATSTATEMENT        = 100;   // Kind=0;  Lex='<RepeatStatement>';  
      Tag_SIMPLEEXPRESSION       = 101;   // Kind=0;  Lex='<SimpleExpression>';  
      Tag_STATEMENT              = 102;   // Kind=0;  Lex='<Statement>';  
      Tag_STATEMENTLIST          = 103;   // Kind=0;  Lex='<StatementList>';  
      Tag_TERM                   = 104;   // Kind=0;  Lex='<Term>';  
      Tag_TYPEDEF                = 105;   // Kind=0;  Lex='<TypeDef>';  
      Tag_TYPEDEFINITIONLIST     = 106;   // Kind=0;  Lex='<TypeDefinitionList>';  
      Tag_TYPEDEFINITIONS        = 107;   // Kind=0;  Lex='<TypeDefinitions>';  
      Tag_TYPESPECIFIER          = 108;   // Kind=0;  Lex='<TypeSpecifier>';  
      Tag_VARIABLE               = 109;   // Kind=0;  Lex='<Variable>';  
      Tag_VARIABLEDEC            = 110;   // Kind=0;  Lex='<VariableDec>';  
      Tag_VARIABLEDECLARATIONLIST= 111;   // Kind=0;  Lex='<VariableDeclarationList>';  
      Tag_VARIABLEDECLARATIONS   = 112;   // Kind=0;  Lex='<VariableDeclarations>';  
      Tag_WHILESTATEMENT         = 113;   // Kind=0;  Lex='<WhileStatement>';  
      TagAny = 114;

      //the length evaluation is a bit clumsy, but GoldParser offers no alternative
      Lex_0: string[length('(EOF)')] ='(EOF)';
      Lex_1: string[length('(Error)')] ='(Error)';
      Lex_2: string[length('(Whitespace)')] ='(Whitespace)';
      Lex_3: string[length('(Comment End)')] ='(Comment End)';
      Lex_4: string[length('(Comment Line)')] ='(Comment Line)';
      Lex_5: string[length('(Comment Start)')] ='(Comment Start)';
      Lex_6: string[length('-')] ='-';
      Lex_7: string[length('(')] ='(';
      Lex_8: string[length(')')] =')';
      Lex_9: string[length('*')] ='*';
      Lex_10: string[length(',')] =',';
      Lex_11: string[length('.')] ='.';
      Lex_12: string[length('..')] ='..';
      Lex_13: string[length('/')] ='/';
      Lex_14: string[length(':')] =':';
      Lex_15: string[length(':=')] =':=';
      Lex_16: string[length(';')] =';';
      Lex_17: string[length('[')] ='[';
      Lex_18: string[length(']')] =']';
      Lex_19: string[length('^')] ='^';
      Lex_20: string[length('+')] ='+';
      Lex_21: string[length('<')] ='<';
      Lex_22: string[length('<=')] ='<=';
      Lex_23: string[length('<>')] ='<>';
      Lex_24: string[length('=')] ='=';
      Lex_25: string[length('>')] ='>';
      Lex_26: string[length('>=')] ='>=';
      Lex_27: string[length('AND')] ='AND';
      Lex_28: string[length('ARRAY')] ='ARRAY';
      Lex_29: string[length('BEGIN')] ='BEGIN';
      Lex_30: string[length('CASE')] ='CASE';
      Lex_31: string[length('CharLiteral')] ='CharLiteral';
      Lex_32: string[length('CommentEnd1')] ='CommentEnd1';
      Lex_33: string[length('CommentEnd2')] ='CommentEnd2';
      Lex_34: string[length('CommentStart1')] ='CommentStart1';
      Lex_35: string[length('CommentStart2')] ='CommentStart2';
      Lex_36: string[length('CONST')] ='CONST';
      Lex_37: string[length('DecLiteral')] ='DecLiteral';
      Lex_38: string[length('DIV')] ='DIV';
      Lex_39: string[length('DO')] ='DO';
      Lex_40: string[length('DOWNTO')] ='DOWNTO';
      Lex_41: string[length('ELSE')] ='ELSE';
      Lex_42: string[length('END')] ='END';
      Lex_43: string[length('FILE')] ='FILE';
      Lex_44: string[length('FloatLiteral')] ='FloatLiteral';
      Lex_45: string[length('FOR')] ='FOR';
      Lex_46: string[length('FORWARD')] ='FORWARD';
      Lex_47: string[length('FUNCTION')] ='FUNCTION';
      Lex_48: string[length('HexLiteral')] ='HexLiteral';
      Lex_49: string[length('id')] ='id';
      Lex_50: string[length('IF')] ='IF';
      Lex_51: string[length('MOD')] ='MOD';
      Lex_52: string[length('NOT')] ='NOT';
      Lex_53: string[length('OF')] ='OF';
      Lex_54: string[length('OR')] ='OR';
      Lex_55: string[length('PROCEDURE')] ='PROCEDURE';
      Lex_56: string[length('PROGRAM')] ='PROGRAM';
      Lex_57: string[length('RECORD')] ='RECORD';
      Lex_58: string[length('REPEAT')] ='REPEAT';
      Lex_59: string[length('StringLiteral')] ='StringLiteral';
      Lex_60: string[length('SynError')] ='SynError';
      Lex_61: string[length('THEN')] ='THEN';
      Lex_62: string[length('TO')] ='TO';
      Lex_63: string[length('TYPE')] ='TYPE';
      Lex_64: string[length('UNTIL')] ='UNTIL';
      Lex_65: string[length('VAR')] ='VAR';
      Lex_66: string[length('WHILE')] ='WHILE';
      Lex_67: string[length('<Actuals>')] ='<Actuals>';
      Lex_68: string[length('<Arg>')] ='<Arg>';
      Lex_69: string[length('<ArgumentList>')] ='<ArgumentList>';
      Lex_70: string[length('<Arguments>')] ='<Arguments>';
      Lex_71: string[length('<AssignmentStatement>')] ='<AssignmentStatement>';
      Lex_72: string[length('<Case>')] ='<Case>';
      Lex_73: string[length('<CaseList>')] ='<CaseList>';
      Lex_74: string[length('<CaseStatement>')] ='<CaseStatement>';
      Lex_75: string[length('<CompoundStatement>')] ='<CompoundStatement>';
      Lex_76: string[length('<constant>')] ='<constant>';
      Lex_77: string[length('<ConstantDef>')] ='<ConstantDef>';
      Lex_78: string[length('<ConstantDefinitionList>')] ='<ConstantDefinitionList>';
      Lex_79: string[length('<ConstantDefinitions>')] ='<ConstantDefinitions>';
      Lex_80: string[length('<ConstantList>')] ='<ConstantList>';
      Lex_81: string[length('<Declarations>')] ='<Declarations>';
      Lex_82: string[length('<Dimension>')] ='<Dimension>';
      Lex_83: string[length('<DimensionList>')] ='<DimensionList>';
      Lex_84: string[length('<Expression>')] ='<Expression>';
      Lex_85: string[length('<ExpressionList>')] ='<ExpressionList>';
      Lex_86: string[length('<Factor>')] ='<Factor>';
      Lex_87: string[length('<Field>')] ='<Field>';
      Lex_88: string[length('<FieldList>')] ='<FieldList>';
      Lex_89: string[length('<ForStatement>')] ='<ForStatement>';
      Lex_90: string[length('<FunctionCall>')] ='<FunctionCall>';
      Lex_91: string[length('<FunctionHeader>')] ='<FunctionHeader>';
      Lex_92: string[length('<IdList>')] ='<IdList>';
      Lex_93: string[length('<IfStatement>')] ='<IfStatement>';
      Lex_94: string[length('<ProcedureCall>')] ='<ProcedureCall>';
      Lex_95: string[length('<ProcedureDec>')] ='<ProcedureDec>';
      Lex_96: string[length('<ProcedureDeclarations>')] ='<ProcedureDeclarations>';
      Lex_97: string[length('<ProcedureHeader>')] ='<ProcedureHeader>';
      Lex_98: string[length('<Program>')] ='<Program>';
      Lex_99: string[length('<ProgramHeader>')] ='<ProgramHeader>';
      Lex_100: string[length('<RepeatStatement>')] ='<RepeatStatement>';
      Lex_101: string[length('<SimpleExpression>')] ='<SimpleExpression>';
      Lex_102: string[length('<Statement>')] ='<Statement>';
      Lex_103: string[length('<StatementList>')] ='<StatementList>';
      Lex_104: string[length('<Term>')] ='<Term>';
      Lex_105: string[length('<TypeDef>')] ='<TypeDef>';
      Lex_106: string[length('<TypeDefinitionList>')] ='<TypeDefinitionList>';
      Lex_107: string[length('<TypeDefinitions>')] ='<TypeDefinitions>';
      Lex_108: string[length('<TypeSpecifier>')] ='<TypeSpecifier>';
      Lex_109: string[length('<Variable>')] ='<Variable>';
      Lex_110: string[length('<VariableDec>')] ='<VariableDec>';
      Lex_111: string[length('<VariableDeclarationList>')] ='<VariableDeclarationList>';
      Lex_112: string[length('<VariableDeclarations>')] ='<VariableDeclarations>';
      Lex_113: string[length('<WhileStatement>')] ='<WhileStatement>';
      Lex_114: string[7] ='<:ANY:>';
        

      LexTable : array[0..114] of ^String = (
      @Lex_0,
      @Lex_1,
      @Lex_2,
      @Lex_3,
      @Lex_4,
      @Lex_5,
      @Lex_6,
      @Lex_7,
      @Lex_8,
      @Lex_9,
      @Lex_10,
      @Lex_11,
      @Lex_12,
      @Lex_13,
      @Lex_14,
      @Lex_15,
      @Lex_16,
      @Lex_17,
      @Lex_18,
      @Lex_19,
      @Lex_20,
      @Lex_21,
      @Lex_22,
      @Lex_23,
      @Lex_24,
      @Lex_25,
      @Lex_26,
      @Lex_27,
      @Lex_28,
      @Lex_29,
      @Lex_30,
      @Lex_31,
      @Lex_32,
      @Lex_33,
      @Lex_34,
      @Lex_35,
      @Lex_36,
      @Lex_37,
      @Lex_38,
      @Lex_39,
      @Lex_40,
      @Lex_41,
      @Lex_42,
      @Lex_43,
      @Lex_44,
      @Lex_45,
      @Lex_46,
      @Lex_47,
      @Lex_48,
      @Lex_49,
      @Lex_50,
      @Lex_51,
      @Lex_52,
      @Lex_53,
      @Lex_54,
      @Lex_55,
      @Lex_56,
      @Lex_57,
      @Lex_58,
      @Lex_59,
      @Lex_60,
      @Lex_61,
      @Lex_62,
      @Lex_63,
      @Lex_64,
      @Lex_65,
      @Lex_66,
      @Lex_67,
      @Lex_68,
      @Lex_69,
      @Lex_70,
      @Lex_71,
      @Lex_72,
      @Lex_73,
      @Lex_74,
      @Lex_75,
      @Lex_76,
      @Lex_77,
      @Lex_78,
      @Lex_79,
      @Lex_80,
      @Lex_81,
      @Lex_82,
      @Lex_83,
      @Lex_84,
      @Lex_85,
      @Lex_86,
      @Lex_87,
      @Lex_88,
      @Lex_89,
      @Lex_90,
      @Lex_91,
      @Lex_92,
      @Lex_93,
      @Lex_94,
      @Lex_95,
      @Lex_96,
      @Lex_97,
      @Lex_98,
      @Lex_99,
      @Lex_100,
      @Lex_101,
      @Lex_102,
      @Lex_103,
      @Lex_104,
      @Lex_105,
      @Lex_106,
      @Lex_107,
      @Lex_108,
      @Lex_109,
      @Lex_110,
      @Lex_111,
      @Lex_112,
      @Lex_113,
      @Lex_114);

type  TTokenTag    = 0..TagCount;
      TToken       = record 
                       Tag:TTokenTag; 
                       LinePos, CharPos: Integer; 
                       Kind:0..5; 
                     end;
      PToken       = ^TToken;
      TTokenList   = array [1..100] of TToken;
      PTokenList   = ^TTokenList;
      PText        = ^Text;
var   Fo,Fe:PText;

//-----------------------------------------------------------------------------
// OBJECTS (SCANNER,LEXER,PARSER)
//-----------------------------------------------------------------------------
Type
  TScanner = object
    Fi:Text;
    CurChar:    Char;
    NextChar:   Char;
    procedure   Get; virtual;
    constructor Init(FileName:String); 
    destructor  Done; Virtual;
  end;  

  
  TLexer=object(TScanner)
    ErrorMax:   Integer;
    ErrorCnt:   Integer;
    LinePos:	Integer;
    CharPos:	Integer;
    LexemeLen:  Integer;
    LexemeStr:  String;
    Token:      TToken;
    constructor Init(FileName:String); 
    procedure   GetChar; 
    procedure   GetLine; 
    procedure   GetToken; virtual;
    procedure   GetComment(TagCommentStart,TagCommentEnd:Integer);
    function    GetLexeme (SkipMode:Boolean):Integer; 
    procedure   DoError   (ErrorNr:Integer; TokenPtr: PToken);
  end;

  
  PParser = ^TParser;
  TParser = object(TLexer)
    constructor Init(InFile:String);
    destructor  Done; virtual;
    Procedure   DoAction (T:PTokenList; RuleNr,TokenCnt:Integer);
    procedure   DoAccept (TokenPtr: PToken);
    Procedure   DoCleanup(TokenPtr: PToken);
    function    DoParse  (StackSize:Integer):Integer;
    // the rules below are auto-generated from the grammar: 'Pascal' 
    procedure   Action_CONSTANT_DECLITERAL                        (T:PTokenList);
    procedure   Action_CONSTANT_STRINGLITERAL                     (T:PTokenList);
    procedure   Action_CONSTANT_FLOATLITERAL                      (T:PTokenList);
    procedure   Action_CONSTANT_HEXLITERAL                        (T:PTokenList);
    procedure   Action_CONSTANT_CHARLITERAL                       (T:PTokenList);
    procedure   Action_PROGRAM_DOT                                (T:PTokenList);
    procedure   Action_PROGRAMHEADER_PROGRAM_ID_SEMI              (T:PTokenList);
    procedure   Action_PROGRAMHEADER_PROGRAM_ID_LPARAN_RPARAN_SEMI(T:PTokenList);
    procedure   Action_DECLARATIONS                               (T:PTokenList);
    procedure   Action_CONSTANTDEFINITIONS_CONST                  (T:PTokenList);
    procedure   Action_CONSTANTDEFINITIONS                        (T:PTokenList);
    procedure   Action_CONSTANTDEFINITIONLIST                     (T:PTokenList);
    procedure   Action_CONSTANTDEFINITIONLIST2                    (T:PTokenList);
    procedure   Action_CONSTANTDEF_ID_EQ_SEMI                     (T:PTokenList);
    procedure   Action_TYPEDEFINITIONS_TYPE                       (T:PTokenList);
    procedure   Action_TYPEDEFINITIONS                            (T:PTokenList);
    procedure   Action_TYPEDEFINITIONLIST                         (T:PTokenList);
    procedure   Action_TYPEDEFINITIONLIST2                        (T:PTokenList);
    procedure   Action_TYPEDEF_ID_EQ_SEMI                         (T:PTokenList);
    procedure   Action_VARIABLEDECLARATIONS_VAR                   (T:PTokenList);
    procedure   Action_VARIABLEDECLARATIONS                       (T:PTokenList);
    procedure   Action_VARIABLEDECLARATIONLIST                    (T:PTokenList);
    procedure   Action_VARIABLEDECLARATIONLIST2                   (T:PTokenList);
    procedure   Action_VARIABLEDEC_COLON_SEMI                     (T:PTokenList);
    procedure   Action_PROCEDUREDECLARATIONS                      (T:PTokenList);
    procedure   Action_PROCEDUREDECLARATIONS2                     (T:PTokenList);
    procedure   Action_PROCEDUREDEC_FORWARD_SEMI                  (T:PTokenList);
    procedure   Action_PROCEDUREDEC_SEMI                          (T:PTokenList);
    procedure   Action_PROCEDUREDEC_FORWARD_SEMI2                 (T:PTokenList);
    procedure   Action_PROCEDUREDEC_SEMI2                         (T:PTokenList);
    procedure   Action_PROCEDUREHEADER_PROCEDURE_ID_SEMI          (T:PTokenList);
    procedure   Action_FUNCTIONHEADER_FUNCTION_ID_COLON_SEMI      (T:PTokenList);
    procedure   Action_ARGUMENTS_LPARAN_RPARAN                    (T:PTokenList);
    procedure   Action_ARGUMENTS                                  (T:PTokenList);
    procedure   Action_ARGUMENTLIST                               (T:PTokenList);
    procedure   Action_ARGUMENTLIST_SEMI                          (T:PTokenList);
    procedure   Action_ARG_COLON                                  (T:PTokenList);
    procedure   Action_ARG_VAR_COLON                              (T:PTokenList);
    procedure   Action_COMPOUNDSTATEMENT_BEGIN_END                (T:PTokenList);
    procedure   Action_STATEMENTLIST                              (T:PTokenList);
    procedure   Action_STATEMENTLIST_SEMI                         (T:PTokenList);
    procedure   Action_STATEMENT                                  (T:PTokenList);
    procedure   Action_STATEMENT2                                 (T:PTokenList);
    procedure   Action_STATEMENT3                                 (T:PTokenList);
    procedure   Action_STATEMENT4                                 (T:PTokenList);
    procedure   Action_STATEMENT5                                 (T:PTokenList);
    procedure   Action_STATEMENT6                                 (T:PTokenList);
    procedure   Action_STATEMENT7                                 (T:PTokenList);
    procedure   Action_STATEMENT8                                 (T:PTokenList);
    procedure   Action_STATEMENT9                                 (T:PTokenList);
    procedure   Action_ASSIGNMENTSTATEMENT_COLONEQ                (T:PTokenList);
    procedure   Action_PROCEDURECALL_ID                           (T:PTokenList);
    procedure   Action_FORSTATEMENT_FOR_ID_COLONEQ_TO_DO          (T:PTokenList);
    procedure   Action_FORSTATEMENT_FOR_ID_COLONEQ_DOWNTO_DO      (T:PTokenList);
    procedure   Action_WHILESTATEMENT_WHILE_DO                    (T:PTokenList);
    procedure   Action_IFSTATEMENT_IF_THEN_ELSE                   (T:PTokenList);
    procedure   Action_REPEATSTATEMENT_REPEAT_UNTIL               (T:PTokenList);
    procedure   Action_CASESTATEMENT_CASE_OF_END                  (T:PTokenList);
    procedure   Action_CASELIST                                   (T:PTokenList);
    procedure   Action_CASELIST_SEMI                              (T:PTokenList);
    procedure   Action_CASE_COLON                                 (T:PTokenList);
    procedure   Action_CONSTANTLIST                               (T:PTokenList);
    procedure   Action_CONSTANTLIST_COMMA                         (T:PTokenList);
    procedure   Action_EXPRESSION                                 (T:PTokenList);
    procedure   Action_EXPRESSION_EQ                              (T:PTokenList);
    procedure   Action_EXPRESSION_LTGT                            (T:PTokenList);
    procedure   Action_EXPRESSION_LT                              (T:PTokenList);
    procedure   Action_EXPRESSION_LTEQ                            (T:PTokenList);
    procedure   Action_EXPRESSION_GT                              (T:PTokenList);
    procedure   Action_EXPRESSION_GTEQ                            (T:PTokenList);
    procedure   Action_SIMPLEEXPRESSION                           (T:PTokenList);
    procedure   Action_SIMPLEEXPRESSION_PLUS                      (T:PTokenList);
    procedure   Action_SIMPLEEXPRESSION_MINUS                     (T:PTokenList);
    procedure   Action_SIMPLEEXPRESSION_OR                        (T:PTokenList);
    procedure   Action_TERM                                       (T:PTokenList);
    procedure   Action_TERM_TIMES                                 (T:PTokenList);
    procedure   Action_TERM_DIV                                   (T:PTokenList);
    procedure   Action_TERM_DIV2                                  (T:PTokenList);
    procedure   Action_TERM_MOD                                   (T:PTokenList);
    procedure   Action_TERM_AND                                   (T:PTokenList);
    procedure   Action_FACTOR_LPARAN_RPARAN                       (T:PTokenList);
    procedure   Action_FACTOR_PLUS                                (T:PTokenList);
    procedure   Action_FACTOR_MINUS                               (T:PTokenList);
    procedure   Action_FACTOR_NOT                                 (T:PTokenList);
    procedure   Action_FACTOR                                     (T:PTokenList);
    procedure   Action_FACTOR2                                    (T:PTokenList);
    procedure   Action_FACTOR3                                    (T:PTokenList);
    procedure   Action_FUNCTIONCALL_ID_LPARAN_RPARAN              (T:PTokenList);
    procedure   Action_ACTUALS_LPARAN_RPARAN                      (T:PTokenList);
    procedure   Action_ACTUALS                                    (T:PTokenList);
    procedure   Action_EXPRESSIONLIST                             (T:PTokenList);
    procedure   Action_EXPRESSIONLIST_COMMA                       (T:PTokenList);
    procedure   Action_VARIABLE_ID                                (T:PTokenList);
    procedure   Action_VARIABLE_DOT_ID                            (T:PTokenList);
    procedure   Action_VARIABLE_CARET                             (T:PTokenList);
    procedure   Action_VARIABLE_LBRACKET_RBRACKET                 (T:PTokenList);
    procedure   Action_TYPESPECIFIER_ID                           (T:PTokenList);
    procedure   Action_TYPESPECIFIER_CARET                        (T:PTokenList);
    procedure   Action_TYPESPECIFIER_LPARAN_RPARAN                (T:PTokenList);
    procedure   Action_TYPESPECIFIER_DOTDOT                       (T:PTokenList);
    procedure   Action_TYPESPECIFIER_ARRAY_LBRACKET_RBRACKET_OF   (T:PTokenList);
    procedure   Action_TYPESPECIFIER_RECORD_END                   (T:PTokenList);
    procedure   Action_TYPESPECIFIER_FILE_OF                      (T:PTokenList);
    procedure   Action_DIMENSIONLIST                              (T:PTokenList);
    procedure   Action_DIMENSIONLIST_COMMA                        (T:PTokenList);
    procedure   Action_DIMENSION_DOTDOT                           (T:PTokenList);
    procedure   Action_DIMENSION_ID                               (T:PTokenList);
    procedure   Action_FIELDLIST                                  (T:PTokenList);
    procedure   Action_FIELDLIST_SEMI                             (T:PTokenList);
    procedure   Action_FIELD_COLON                                (T:PTokenList);
    procedure   Action_IDLIST_ID                                  (T:PTokenList);
    procedure   Action_IDLIST_ID_COMMA                            (T:PTokenList);
  end {TParser};



{$IFDEF Debug_HEAPMEM} 
{-----------------------------------------------------------------------------}
procedure ShowMem(Prefix:String);
{-----------------------------------------------------------------------------}
var Status:theapstatus;
begin
  Status:=GetHeapStatus;
  Writeln(Fo^, Prefix,': ',Status.TotalAllocated:1, ' bytes'); // [',HeapCount:1,':',HeapSize,']');
end;
{$ENDIF}


{-----------------------------------------------------------------------------}
constructor TScanner.Init(FileName:String);
{-----------------------------------------------------------------------------}
begin
  assign(Fi,FileName);
  reset(Fi);
  CurChar:=#0;
  NextChar:=#0;
  Get;
end;


{-----------------------------------------------------------------------------}
destructor TScanner.Done;
{-----------------------------------------------------------------------------}
begin
  close(Fi);
end;


{-----------------------------------------------------------------------------}
Procedure TScanner.Get; //replace this one with your own reader
{-----------------------------------------------------------------------------}
begin
  CurChar:=NextChar;
  if NextChar<>EOF then Read(Fi,NextChar); 
end;


{-----------------------------------------------------------------------------}
constructor TLexer.Init(FileName:String);
{-----------------------------------------------------------------------------}
begin
  inherited init(FileName);
  LexemeLen:=0;
  LexemeStr:='';
  LinePos:=1;
  CharPos:=0;
  ErrorMax:=100;
  ErrorCnt:=0;
  Token.Tag:=0;
  Token.LinePos:=LinePos;
  Token.CharPos:=CharPos;
  GetChar;
end;


{-----------------------------------------------------------------------------}
Procedure TLexer.GetChar; 
{-----------------------------------------------------------------------------}
begin  
  case CurChar of
    LF:    begin CharPos:=0; inc(LinePos);      end;
    CR,FF: begin CharPos:=0;                    end;
    TAB:   begin CharPos:= (CharPos div 8)*8+8; end;
  end; {case} 
  inc(LexemeLen); inc(CharPos);
  if LexemeLen<256 then begin
    setlength(LexemeStr,LexemeLen);
    LexemeStr[LexemeLen]:=CurChar;
  end {else overflow};
  Get;
end;


{-----------------------------------------------------------------------------}
Procedure TLexer.GetLine;
{-----------------------------------------------------------------------------}
begin
  repeat
    case CurChar of
      CR,FF,LF: Break;
      else      Get;
    end; {case}
  until false;
  repeat
    case CurChar of
      LF:    begin CharPos:=0; inc(LinePos);      end;
      CR,FF: begin CharPos:=0;                    end;
      else   Break;
    end;
    Get;
  until false;
  inc(CharPos);
  LexemeStr:='';
  LexemeLen:=0;
end;


{-----------------------------------------------------------------------------}
procedure TLexer.GetToken;
{-----------------------------------------------------------------------------}
// Reads a "token", being a representation of a lexeme.
// This means, reading a lexeme string and bind it to a token
// Extend or change this function according to your application needs
//
// A token is a record, usually containing information like
//   - a tag being unique for each lexeme, 
//   - a pointer to a string to that lexeme, 
//   - the location of that lexeme
//   - and everything that is needed for your application
{-----------------------------------------------------------------------------}
var Tag:Integer;
begin
  repeat
    Tag:=GetLexeme(False);
    case Tag of
      TAG_WHITESPACE:      {$IFDEF Debug_LEXER} WriteLn(Fo^,'  ---WhiteSpace---') {$ENDIF};
      TAG_COMMENTLINE:     GetLine;
      TAG_COMMENTSTART:    GetComment(TAG_COMMENTSTART,  TAG_COMMENTEND );
      TAG_COMMENTSTART1:   GetComment(TAG_COMMENTSTART1, TAG_COMMENTEND1);
      TAG_COMMENTSTART2:   GetComment(TAG_COMMENTSTART2, TAG_COMMENTEND2);
      TAG_COMMENTEND, TAG_COMMENTEND1, TAG_COMMENTEND2, -1{unknown lexeme}:      
                           begin inc(ErrorCnt); DoError(Err_Lexeme, Nil); GetChar;   end;
      else                 break;
    end;
  until False;
  Token.Tag :=Tag;
  Token.Kind:=1; //flag this token as an "terminal" token
  {$IFDEF Debug_TOKENS} writeln(Fo^,'Token(',Token.LinePos:1,':',Token.CharPos:1,'):',Tab,'Tag=',Token.Tag,Tab,': "',LexemeStr,'"'); {$ENDIF}
end;


{-----------------------------------------------------------------------------}
procedure TLexer.GetComment(TagCommentStart,TagCommentEnd:Integer);
{-----------------------------------------------------------------------------}
var Tag:Integer;
begin
  repeat
    Tag:=GetLexeme(True);
    if (Tag=TagCommentEnd)   then break;
    if (Tag=TAG_EOF)         then break;
    {$ifdef IsNESTED} 
    if (Tag=TagCommentStart) then GetComment(TagCommentStart, TagCommentEnd);
    {$endif}
  until false;    
end;      


{-----------------------------------------------------------------------------}
Procedure TLexer.DoError(ErrorNr:Integer; TokenPtr:PToken);
{-----------------------------------------------------------------------------}
//Augment this with you own code, to handle errors
begin
  case ErrorNr of
    Err_StackOverflow:  
         begin
           writeln(Fe^,'Syntax Error: Overflow of parse stack at');
           writeln(Fe^,'  Pos(',Token.LinePos:1,':',Token.CharPos:1,')=',Tab,Token.Tag,Tab,'"',LexemeStr,'"');
         end;
    Err_Overflow:  
         begin
           writeln(Fe^,'--> too many errors (',ErrorMax,'), parsing stopped');
         end;
    Err_Skipped:
         begin
           dec(TokenPtr);
           write(Fe^,'--> Invalidating all input between ');
           write(Fe^,  '(',TokenPtr^.LinePos,':',TokenPtr^.CharPos,') and ');
           inc(TokenPtr);
           write(Fe^,  '(',TokenPtr^.LinePos,':',TokenPtr^.CharPos,')');
           writeln(Fe^, ' into a single <error>');
         end;
    Err_Halted:
         begin
           write(Fe^,'--> Parsing prematurely halted due to unsolveable error at');
           writeln(Fe^,' (',Token.LinePos:1,':',Token.CharPos:1,')');
         end;
    Err_Lexeme:
         begin
           write(Fe^,'Pos(',Token.LinePos:1,':',Token.CharPos:1,') ');
           write(Fe^,'Pos(',Token.LinePos:1,':',Token.CharPos:1,') ');
           write(Fe^,'Lexical Error: character ');
           if ord(CurChar)>=32 
             then writeln(Fe^,'"',CurChar,'" is skipped')
             else writeln(Fe^,'<',ord(CurChar),'> is skipped');
         end;
    else begin
           write(Fe^,'Pos(',Token.LinePos:1,':',Token.CharPos:1,') ');
           write(Fe^,'Syntax Error(',ErrorNr,'): "',LexemeStr,'" found');
           if Token.Tag<>TokenPtr^.Tag then
//           write(Fe^,' but <',TokenPtr^.Tag:1,'> expected');
           write(Fe^,' but [',LexTable[TokenPtr^.Tag]^,'] expected');
           writeln(Fe^);
         end;
  end;
end;


{-----------------------------------------------------------------------------}
constructor TParser.Init(InFile:String);
{-----------------------------------------------------------------------------}
begin
  {$IFDEF Debug_HEAPMEM} ShowMem('MemUsage, at Parse start '); {$ENDIF}
  inherited init(InFile);
end;


{-----------------------------------------------------------------------------}
destructor TParser.Done;
{-----------------------------------------------------------------------------}
begin
  inherited done;
  {$IFDEF Debug_HEAPMEM} ShowMem('MemUsage, at Parse Done '); {$ENDIF}
end;


{-----------------------------------------------------------------------------}
Procedure TParser.DoAccept(TokenPtr:PToken);
{-----------------------------------------------------------------------------}
begin
  //replace this with you own code, to process for instance a parse tree tha has
  //been build during the parsing process
  writeln('input has been parsed succesfuly');
end;


{-----------------------------------------------------------------------------}
Procedure TParser.DoCleanup(TokenPtr:PToken);
{-----------------------------------------------------------------------------}
//replace this with you own code, to free memory from the heap (when applicable)
begin
end;  





{-----------------------------------------------------------------------------}
Procedure TParser.DoAction(T:PTokenList; RuleNr,TokenCnt:Integer);
{-----------------------------------------------------------------------------}
// Then call associated action routine, with a pointer to the first 
// left-hand item of the involved rule.
// When finished, replace first left hand token tag with a new non-terminal,
// and return the number of left-hand items
{-----------------------------------------------------------------------------}
Type  TParseEdge= procedure(T:PTokenList; S:PParser);
const ActionTable: array [0..112] of Pointer  = (
    {  0} (@TParser.Action_CONSTANT_DECLITERAL),	
    {  1} (@TParser.Action_CONSTANT_STRINGLITERAL),	
    {  2} (@TParser.Action_CONSTANT_FLOATLITERAL),	
    {  3} (@TParser.Action_CONSTANT_HEXLITERAL),	
    {  4} (@TParser.Action_CONSTANT_CHARLITERAL),	
    {  5} (@TParser.Action_PROGRAM_DOT),	
    {  6} (@TParser.Action_PROGRAMHEADER_PROGRAM_ID_SEMI),	
    {  7} (@TParser.Action_PROGRAMHEADER_PROGRAM_ID_LPARAN_RPARAN_SEMI),	
    {  8} (@TParser.Action_DECLARATIONS),	
    {  9} (@TParser.Action_CONSTANTDEFINITIONS_CONST),	
    { 10} (@TParser.Action_CONSTANTDEFINITIONS),	
    { 11} (@TParser.Action_CONSTANTDEFINITIONLIST),	
    { 12} (@TParser.Action_CONSTANTDEFINITIONLIST2),	
    { 13} (@TParser.Action_CONSTANTDEF_ID_EQ_SEMI),	
    { 14} (@TParser.Action_TYPEDEFINITIONS_TYPE),	
    { 15} (@TParser.Action_TYPEDEFINITIONS),	
    { 16} (@TParser.Action_TYPEDEFINITIONLIST),	
    { 17} (@TParser.Action_TYPEDEFINITIONLIST2),	
    { 18} (@TParser.Action_TYPEDEF_ID_EQ_SEMI),	
    { 19} (@TParser.Action_VARIABLEDECLARATIONS_VAR),	
    { 20} (@TParser.Action_VARIABLEDECLARATIONS),	
    { 21} (@TParser.Action_VARIABLEDECLARATIONLIST),	
    { 22} (@TParser.Action_VARIABLEDECLARATIONLIST2),	
    { 23} (@TParser.Action_VARIABLEDEC_COLON_SEMI),	
    { 24} (@TParser.Action_PROCEDUREDECLARATIONS),	
    { 25} (@TParser.Action_PROCEDUREDECLARATIONS2),	
    { 26} (@TParser.Action_PROCEDUREDEC_FORWARD_SEMI),	
    { 27} (@TParser.Action_PROCEDUREDEC_SEMI),	
    { 28} (@TParser.Action_PROCEDUREDEC_FORWARD_SEMI2),	
    { 29} (@TParser.Action_PROCEDUREDEC_SEMI2),	
    { 30} (@TParser.Action_PROCEDUREHEADER_PROCEDURE_ID_SEMI),	
    { 31} (@TParser.Action_FUNCTIONHEADER_FUNCTION_ID_COLON_SEMI),	
    { 32} (@TParser.Action_ARGUMENTS_LPARAN_RPARAN),	
    { 33} (@TParser.Action_ARGUMENTS),	
    { 34} (@TParser.Action_ARGUMENTLIST),	
    { 35} (@TParser.Action_ARGUMENTLIST_SEMI),	
    { 36} (@TParser.Action_ARG_COLON),	
    { 37} (@TParser.Action_ARG_VAR_COLON),	
    { 38} (@TParser.Action_COMPOUNDSTATEMENT_BEGIN_END),	
    { 39} (@TParser.Action_STATEMENTLIST),	
    { 40} (@TParser.Action_STATEMENTLIST_SEMI),	
    { 41} (@TParser.Action_STATEMENT),	
    { 42} (@TParser.Action_STATEMENT2),	
    { 43} (@TParser.Action_STATEMENT3),	
    { 44} (@TParser.Action_STATEMENT4),	
    { 45} (@TParser.Action_STATEMENT5),	
    { 46} (@TParser.Action_STATEMENT6),	
    { 47} (@TParser.Action_STATEMENT7),	
    { 48} (@TParser.Action_STATEMENT8),	
    { 49} (@TParser.Action_STATEMENT9),	
    { 50} (@TParser.Action_ASSIGNMENTSTATEMENT_COLONEQ),	
    { 51} (@TParser.Action_PROCEDURECALL_ID),	
    { 52} (@TParser.Action_FORSTATEMENT_FOR_ID_COLONEQ_TO_DO),	
    { 53} (@TParser.Action_FORSTATEMENT_FOR_ID_COLONEQ_DOWNTO_DO),	
    { 54} (@TParser.Action_WHILESTATEMENT_WHILE_DO),	
    { 55} (@TParser.Action_IFSTATEMENT_IF_THEN_ELSE),	
    { 56} (@TParser.Action_REPEATSTATEMENT_REPEAT_UNTIL),	
    { 57} (@TParser.Action_CASESTATEMENT_CASE_OF_END),	
    { 58} (@TParser.Action_CASELIST),	
    { 59} (@TParser.Action_CASELIST_SEMI),	
    { 60} (@TParser.Action_CASE_COLON),	
    { 61} (@TParser.Action_CONSTANTLIST),	
    { 62} (@TParser.Action_CONSTANTLIST_COMMA),	
    { 63} (@TParser.Action_EXPRESSION),	
    { 64} (@TParser.Action_EXPRESSION_EQ),	
    { 65} (@TParser.Action_EXPRESSION_LTGT),	
    { 66} (@TParser.Action_EXPRESSION_LT),	
    { 67} (@TParser.Action_EXPRESSION_LTEQ),	
    { 68} (@TParser.Action_EXPRESSION_GT),	
    { 69} (@TParser.Action_EXPRESSION_GTEQ),	
    { 70} (@TParser.Action_SIMPLEEXPRESSION),	
    { 71} (@TParser.Action_SIMPLEEXPRESSION_PLUS),	
    { 72} (@TParser.Action_SIMPLEEXPRESSION_MINUS),	
    { 73} (@TParser.Action_SIMPLEEXPRESSION_OR),	
    { 74} (@TParser.Action_TERM),	
    { 75} (@TParser.Action_TERM_TIMES),	
    { 76} (@TParser.Action_TERM_DIV),	
    { 77} (@TParser.Action_TERM_DIV2),	
    { 78} (@TParser.Action_TERM_MOD),	
    { 79} (@TParser.Action_TERM_AND),	
    { 80} (@TParser.Action_FACTOR_LPARAN_RPARAN),	
    { 81} (@TParser.Action_FACTOR_PLUS),	
    { 82} (@TParser.Action_FACTOR_MINUS),	
    { 83} (@TParser.Action_FACTOR_NOT),	
    { 84} (@TParser.Action_FACTOR),	
    { 85} (@TParser.Action_FACTOR2),	
    { 86} (@TParser.Action_FACTOR3),	
    { 87} (@TParser.Action_FUNCTIONCALL_ID_LPARAN_RPARAN),	
    { 88} (@TParser.Action_ACTUALS_LPARAN_RPARAN),	
    { 89} (@TParser.Action_ACTUALS),	
    { 90} (@TParser.Action_EXPRESSIONLIST),	
    { 91} (@TParser.Action_EXPRESSIONLIST_COMMA),	
    { 92} (@TParser.Action_VARIABLE_ID),	
    { 93} (@TParser.Action_VARIABLE_DOT_ID),	
    { 94} (@TParser.Action_VARIABLE_CARET),	
    { 95} (@TParser.Action_VARIABLE_LBRACKET_RBRACKET),	
    { 96} (@TParser.Action_TYPESPECIFIER_ID),	
    { 97} (@TParser.Action_TYPESPECIFIER_CARET),	
    { 98} (@TParser.Action_TYPESPECIFIER_LPARAN_RPARAN),	
    { 99} (@TParser.Action_TYPESPECIFIER_DOTDOT),	
    {100} (@TParser.Action_TYPESPECIFIER_ARRAY_LBRACKET_RBRACKET_OF),	
    {101} (@TParser.Action_TYPESPECIFIER_RECORD_END),	
    {102} (@TParser.Action_TYPESPECIFIER_FILE_OF),	
    {103} (@TParser.Action_DIMENSIONLIST),	
    {104} (@TParser.Action_DIMENSIONLIST_COMMA),	
    {105} (@TParser.Action_DIMENSION_DOTDOT),	
    {106} (@TParser.Action_DIMENSION_ID),	
    {107} (@TParser.Action_FIELDLIST),	
    {108} (@TParser.Action_FIELDLIST_SEMI),	
    {109} (@TParser.Action_FIELD_COLON),	
    {110} (@TParser.Action_IDLIST_ID),	
    {111} (@TParser.Action_IDLIST_ID_COMMA),	
    {112} (Nil)
  );
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFNDEF Debug_PARSER} if TokenCnt>0 then {$ENDIF}
  TParseEdge(ActionTable[RuleNr])(T, @Self);
end {DoAction}; 



{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANT_DECLITERAL(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(0) =   <constant> ::= DecLiteral
// COUNT:  1     ^---(Tag=76)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[0]=CONSTANT_DECLITERAL(T,1)'); {$ENDIF}
end {CONSTANT_DECLITERAL};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANT_STRINGLITERAL(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(1) =   <constant> ::= StringLiteral
// COUNT:  1     ^---(Tag=76)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[1]=CONSTANT_STRINGLITERAL(T,1)'); {$ENDIF}
end {CONSTANT_STRINGLITERAL};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANT_FLOATLITERAL(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(2) =   <constant> ::= FloatLiteral
// COUNT:  1     ^---(Tag=76)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[2]=CONSTANT_FLOATLITERAL(T,1)'); {$ENDIF}
end {CONSTANT_FLOATLITERAL};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANT_HEXLITERAL(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(3) =   <constant> ::= HexLiteral
// COUNT:  1     ^---(Tag=76)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[3]=CONSTANT_HEXLITERAL(T,1)'); {$ENDIF}
end {CONSTANT_HEXLITERAL};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANT_CHARLITERAL(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(4) =   <constant> ::= CharLiteral
// COUNT:  1     ^---(Tag=76)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[4]=CONSTANT_CHARLITERAL(T,1)'); {$ENDIF}
end {CONSTANT_CHARLITERAL};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROGRAM_DOT(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(5) =   <Program> ::= <ProgramHeader> <Declarations> <CompoundStatement> .
// COUNT:  4     ^---(Tag=98)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[5]=PROGRAM_DOT(T,4)'); {$ENDIF}
end {PROGRAM_DOT};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROGRAMHEADER_PROGRAM_ID_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(6) =   <ProgramHeader> ::= PROGRAM id ;
// COUNT:  3     ^---(Tag=99)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[6]=PROGRAMHEADER_PROGRAM_ID_SEMI(T,3)'); {$ENDIF}
end {PROGRAMHEADER_PROGRAM_ID_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROGRAMHEADER_PROGRAM_ID_LPARAN_RPARAN_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(7) =   <ProgramHeader> ::= PROGRAM id ( <IdList> ) ;
// COUNT:  6     ^---(Tag=99)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[7]=PROGRAMHEADER_PROGRAM_ID_LPARAN_RPARAN_SEMI(T,6)'); {$ENDIF}
end {PROGRAMHEADER_PROGRAM_ID_LPARAN_RPARAN_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_DECLARATIONS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(8) =   <Declarations> ::= <ConstantDefinitions> <TypeDefinitions> <VariableDeclarations> <ProcedureDeclarations>
// COUNT:  4     ^---(Tag=81)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[8]=DECLARATIONS(T,4)'); {$ENDIF}
end {DECLARATIONS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANTDEFINITIONS_CONST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(9) =   <ConstantDefinitions> ::= CONST <ConstantDefinitionList>
// COUNT:  2     ^---(Tag=79)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[9]=CONSTANTDEFINITIONS_CONST(T,2)'); {$ENDIF}
end {CONSTANTDEFINITIONS_CONST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANTDEFINITIONS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(10) =   <ConstantDefinitions> ::= 
// COUNT:  0     ^---(Tag=79)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[10]=CONSTANTDEFINITIONS(T,0)'); {$ENDIF}
end {CONSTANTDEFINITIONS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANTDEFINITIONLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(11) =   <ConstantDefinitionList> ::= <ConstantDef>
// COUNT:  1     ^---(Tag=78)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[11]=CONSTANTDEFINITIONLIST(T,1)'); {$ENDIF}
end {CONSTANTDEFINITIONLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANTDEFINITIONLIST2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(12) =   <ConstantDefinitionList> ::= <ConstantDef> <ConstantDefinitionList>
// COUNT:  2     ^---(Tag=78)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[12]=CONSTANTDEFINITIONLIST2(T,2)'); {$ENDIF}
end {CONSTANTDEFINITIONLIST2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANTDEF_ID_EQ_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(13) =   <ConstantDef> ::= id = <constant> ;
// COUNT:  4     ^---(Tag=77)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[13]=CONSTANTDEF_ID_EQ_SEMI(T,4)'); {$ENDIF}
end {CONSTANTDEF_ID_EQ_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPEDEFINITIONS_TYPE(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(14) =   <TypeDefinitions> ::= TYPE <TypeDefinitionList>
// COUNT:  2     ^---(Tag=107)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[14]=TYPEDEFINITIONS_TYPE(T,2)'); {$ENDIF}
end {TYPEDEFINITIONS_TYPE};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPEDEFINITIONS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(15) =   <TypeDefinitions> ::= 
// COUNT:  0     ^---(Tag=107)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[15]=TYPEDEFINITIONS(T,0)'); {$ENDIF}
end {TYPEDEFINITIONS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPEDEFINITIONLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(16) =   <TypeDefinitionList> ::= <TypeDef>
// COUNT:  1     ^---(Tag=106)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[16]=TYPEDEFINITIONLIST(T,1)'); {$ENDIF}
end {TYPEDEFINITIONLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPEDEFINITIONLIST2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(17) =   <TypeDefinitionList> ::= <TypeDef> <TypeDefinitionList>
// COUNT:  2     ^---(Tag=106)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[17]=TYPEDEFINITIONLIST2(T,2)'); {$ENDIF}
end {TYPEDEFINITIONLIST2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPEDEF_ID_EQ_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(18) =   <TypeDef> ::= id = <TypeSpecifier> ;
// COUNT:  4     ^---(Tag=105)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[18]=TYPEDEF_ID_EQ_SEMI(T,4)'); {$ENDIF}
end {TYPEDEF_ID_EQ_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLEDECLARATIONS_VAR(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(19) =   <VariableDeclarations> ::= VAR <VariableDeclarationList>
// COUNT:  2     ^---(Tag=112)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[19]=VARIABLEDECLARATIONS_VAR(T,2)'); {$ENDIF}
end {VARIABLEDECLARATIONS_VAR};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLEDECLARATIONS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(20) =   <VariableDeclarations> ::= 
// COUNT:  0     ^---(Tag=112)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[20]=VARIABLEDECLARATIONS(T,0)'); {$ENDIF}
end {VARIABLEDECLARATIONS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLEDECLARATIONLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(21) =   <VariableDeclarationList> ::= <VariableDec>
// COUNT:  1     ^---(Tag=111)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[21]=VARIABLEDECLARATIONLIST(T,1)'); {$ENDIF}
end {VARIABLEDECLARATIONLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLEDECLARATIONLIST2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(22) =   <VariableDeclarationList> ::= <VariableDec> <VariableDeclarationList>
// COUNT:  2     ^---(Tag=111)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[22]=VARIABLEDECLARATIONLIST2(T,2)'); {$ENDIF}
end {VARIABLEDECLARATIONLIST2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLEDEC_COLON_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(23) =   <VariableDec> ::= <IdList> : <TypeSpecifier> ;
// COUNT:  4     ^---(Tag=110)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[23]=VARIABLEDEC_COLON_SEMI(T,4)'); {$ENDIF}
end {VARIABLEDEC_COLON_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROCEDUREDECLARATIONS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(24) =   <ProcedureDeclarations> ::= <ProcedureDec> <ProcedureDeclarations>
// COUNT:  2     ^---(Tag=96)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[24]=PROCEDUREDECLARATIONS(T,2)'); {$ENDIF}
end {PROCEDUREDECLARATIONS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROCEDUREDECLARATIONS2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(25) =   <ProcedureDeclarations> ::= 
// COUNT:  0     ^---(Tag=96)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[25]=PROCEDUREDECLARATIONS2(T,0)'); {$ENDIF}
end {PROCEDUREDECLARATIONS2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROCEDUREDEC_FORWARD_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(26) =   <ProcedureDec> ::= <ProcedureHeader> FORWARD ;
// COUNT:  3     ^---(Tag=95)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[26]=PROCEDUREDEC_FORWARD_SEMI(T,3)'); {$ENDIF}
end {PROCEDUREDEC_FORWARD_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROCEDUREDEC_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(27) =   <ProcedureDec> ::= <ProcedureHeader> <Declarations> <CompoundStatement> ;
// COUNT:  4     ^---(Tag=95)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[27]=PROCEDUREDEC_SEMI(T,4)'); {$ENDIF}
end {PROCEDUREDEC_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROCEDUREDEC_FORWARD_SEMI2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(28) =   <ProcedureDec> ::= <FunctionHeader> FORWARD ;
// COUNT:  3     ^---(Tag=95)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[28]=PROCEDUREDEC_FORWARD_SEMI2(T,3)'); {$ENDIF}
end {PROCEDUREDEC_FORWARD_SEMI2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROCEDUREDEC_SEMI2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(29) =   <ProcedureDec> ::= <FunctionHeader> <Declarations> <CompoundStatement> ;
// COUNT:  4     ^---(Tag=95)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[29]=PROCEDUREDEC_SEMI2(T,4)'); {$ENDIF}
end {PROCEDUREDEC_SEMI2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROCEDUREHEADER_PROCEDURE_ID_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(30) =   <ProcedureHeader> ::= PROCEDURE id <Arguments> ;
// COUNT:  4     ^---(Tag=97)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[30]=PROCEDUREHEADER_PROCEDURE_ID_SEMI(T,4)'); {$ENDIF}
end {PROCEDUREHEADER_PROCEDURE_ID_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FUNCTIONHEADER_FUNCTION_ID_COLON_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(31) =   <FunctionHeader> ::= FUNCTION id <Arguments> : <TypeSpecifier> ;
// COUNT:  6     ^---(Tag=91)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[31]=FUNCTIONHEADER_FUNCTION_ID_COLON_SEMI(T,6)'); {$ENDIF}
end {FUNCTIONHEADER_FUNCTION_ID_COLON_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ARGUMENTS_LPARAN_RPARAN(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(32) =   <Arguments> ::= ( <ArgumentList> )
// COUNT:  3     ^---(Tag=70)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[32]=ARGUMENTS_LPARAN_RPARAN(T,3)'); {$ENDIF}
end {ARGUMENTS_LPARAN_RPARAN};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ARGUMENTS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(33) =   <Arguments> ::= 
// COUNT:  0     ^---(Tag=70)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[33]=ARGUMENTS(T,0)'); {$ENDIF}
end {ARGUMENTS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ARGUMENTLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(34) =   <ArgumentList> ::= <Arg>
// COUNT:  1     ^---(Tag=69)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[34]=ARGUMENTLIST(T,1)'); {$ENDIF}
end {ARGUMENTLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ARGUMENTLIST_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(35) =   <ArgumentList> ::= <Arg> ; <ArgumentList>
// COUNT:  3     ^---(Tag=69)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[35]=ARGUMENTLIST_SEMI(T,3)'); {$ENDIF}
end {ARGUMENTLIST_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ARG_COLON(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(36) =   <Arg> ::= <IdList> : <TypeSpecifier>
// COUNT:  3     ^---(Tag=68)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[36]=ARG_COLON(T,3)'); {$ENDIF}
end {ARG_COLON};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ARG_VAR_COLON(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(37) =   <Arg> ::= VAR <IdList> : <TypeSpecifier>
// COUNT:  4     ^---(Tag=68)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[37]=ARG_VAR_COLON(T,4)'); {$ENDIF}
end {ARG_VAR_COLON};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_COMPOUNDSTATEMENT_BEGIN_END(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(38) =   <CompoundStatement> ::= BEGIN <StatementList> END
// COUNT:  3     ^---(Tag=75)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[38]=COMPOUNDSTATEMENT_BEGIN_END(T,3)'); {$ENDIF}
end {COMPOUNDSTATEMENT_BEGIN_END};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENTLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(39) =   <StatementList> ::= <Statement>
// COUNT:  1     ^---(Tag=103)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[39]=STATEMENTLIST(T,1)'); {$ENDIF}
end {STATEMENTLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENTLIST_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(40) =   <StatementList> ::= <Statement> ; <StatementList>
// COUNT:  3     ^---(Tag=103)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[40]=STATEMENTLIST_SEMI(T,3)'); {$ENDIF}
end {STATEMENTLIST_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(41) =   <Statement> ::= <CompoundStatement>
// COUNT:  1     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[41]=STATEMENT(T,1)'); {$ENDIF}
end {STATEMENT};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(42) =   <Statement> ::= <AssignmentStatement>
// COUNT:  1     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[42]=STATEMENT2(T,1)'); {$ENDIF}
end {STATEMENT2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT3(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(43) =   <Statement> ::= <ProcedureCall>
// COUNT:  1     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[43]=STATEMENT3(T,1)'); {$ENDIF}
end {STATEMENT3};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT4(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(44) =   <Statement> ::= <ForStatement>
// COUNT:  1     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[44]=STATEMENT4(T,1)'); {$ENDIF}
end {STATEMENT4};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT5(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(45) =   <Statement> ::= <WhileStatement>
// COUNT:  1     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[45]=STATEMENT5(T,1)'); {$ENDIF}
end {STATEMENT5};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT6(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(46) =   <Statement> ::= <IfStatement>
// COUNT:  1     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[46]=STATEMENT6(T,1)'); {$ENDIF}
end {STATEMENT6};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT7(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(47) =   <Statement> ::= <CaseStatement>
// COUNT:  1     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[47]=STATEMENT7(T,1)'); {$ENDIF}
end {STATEMENT7};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT8(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(48) =   <Statement> ::= <RepeatStatement>
// COUNT:  1     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[48]=STATEMENT8(T,1)'); {$ENDIF}
end {STATEMENT8};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_STATEMENT9(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(49) =   <Statement> ::= 
// COUNT:  0     ^---(Tag=102)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[49]=STATEMENT9(T,0)'); {$ENDIF}
end {STATEMENT9};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ASSIGNMENTSTATEMENT_COLONEQ(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(50) =   <AssignmentStatement> ::= <Variable> := <Expression>
// COUNT:  3     ^---(Tag=71)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[50]=ASSIGNMENTSTATEMENT_COLONEQ(T,3)'); {$ENDIF}
end {ASSIGNMENTSTATEMENT_COLONEQ};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_PROCEDURECALL_ID(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(51) =   <ProcedureCall> ::= id <Actuals>
// COUNT:  2     ^---(Tag=94)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[51]=PROCEDURECALL_ID(T,2)'); {$ENDIF}
end {PROCEDURECALL_ID};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FORSTATEMENT_FOR_ID_COLONEQ_TO_DO(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(52) =   <ForStatement> ::= FOR id := <Expression> TO <Expression> DO <Statement>
// COUNT:  8     ^---(Tag=89)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[52]=FORSTATEMENT_FOR_ID_COLONEQ_TO_DO(T,8)'); {$ENDIF}
end {FORSTATEMENT_FOR_ID_COLONEQ_TO_DO};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FORSTATEMENT_FOR_ID_COLONEQ_DOWNTO_DO(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(53) =   <ForStatement> ::= FOR id := <Expression> DOWNTO <Expression> DO <Statement>
// COUNT:  8     ^---(Tag=89)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[53]=FORSTATEMENT_FOR_ID_COLONEQ_DOWNTO_DO(T,8)'); {$ENDIF}
end {FORSTATEMENT_FOR_ID_COLONEQ_DOWNTO_DO};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_WHILESTATEMENT_WHILE_DO(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(54) =   <WhileStatement> ::= WHILE <Expression> DO <Statement>
// COUNT:  4     ^---(Tag=113)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[54]=WHILESTATEMENT_WHILE_DO(T,4)'); {$ENDIF}
end {WHILESTATEMENT_WHILE_DO};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_IFSTATEMENT_IF_THEN_ELSE(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(55) =   <IfStatement> ::= IF <Expression> THEN <Statement> ELSE <Statement>
// COUNT:  6     ^---(Tag=93)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[55]=IFSTATEMENT_IF_THEN_ELSE(T,6)'); {$ENDIF}
end {IFSTATEMENT_IF_THEN_ELSE};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_REPEATSTATEMENT_REPEAT_UNTIL(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(56) =   <RepeatStatement> ::= REPEAT <StatementList> UNTIL <Expression>
// COUNT:  4     ^---(Tag=100)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[56]=REPEATSTATEMENT_REPEAT_UNTIL(T,4)'); {$ENDIF}
end {REPEATSTATEMENT_REPEAT_UNTIL};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CASESTATEMENT_CASE_OF_END(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(57) =   <CaseStatement> ::= CASE <Expression> OF <CaseList> END
// COUNT:  5     ^---(Tag=74)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[57]=CASESTATEMENT_CASE_OF_END(T,5)'); {$ENDIF}
end {CASESTATEMENT_CASE_OF_END};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CASELIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(58) =   <CaseList> ::= <Case>
// COUNT:  1     ^---(Tag=73)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[58]=CASELIST(T,1)'); {$ENDIF}
end {CASELIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CASELIST_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(59) =   <CaseList> ::= <Case> ; <CaseList>
// COUNT:  3     ^---(Tag=73)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[59]=CASELIST_SEMI(T,3)'); {$ENDIF}
end {CASELIST_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CASE_COLON(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(60) =   <Case> ::= <ConstantList> : <Statement>
// COUNT:  3     ^---(Tag=72)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[60]=CASE_COLON(T,3)'); {$ENDIF}
end {CASE_COLON};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANTLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(61) =   <ConstantList> ::= <constant>
// COUNT:  1     ^---(Tag=80)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[61]=CONSTANTLIST(T,1)'); {$ENDIF}
end {CONSTANTLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_CONSTANTLIST_COMMA(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(62) =   <ConstantList> ::= <constant> , <ConstantList>
// COUNT:  3     ^---(Tag=80)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[62]=CONSTANTLIST_COMMA(T,3)'); {$ENDIF}
end {CONSTANTLIST_COMMA};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSION(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(63) =   <Expression> ::= <SimpleExpression>
// COUNT:  1     ^---(Tag=84)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[63]=EXPRESSION(T,1)'); {$ENDIF}
end {EXPRESSION};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSION_EQ(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(64) =   <Expression> ::= <SimpleExpression> = <SimpleExpression>
// COUNT:  3     ^---(Tag=84)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[64]=EXPRESSION_EQ(T,3)'); {$ENDIF}
end {EXPRESSION_EQ};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSION_LTGT(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(65) =   <Expression> ::= <SimpleExpression> <> <SimpleExpression>
// COUNT:  3     ^---(Tag=84)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[65]=EXPRESSION_LTGT(T,3)'); {$ENDIF}
end {EXPRESSION_LTGT};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSION_LT(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(66) =   <Expression> ::= <SimpleExpression> < <SimpleExpression>
// COUNT:  3     ^---(Tag=84)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[66]=EXPRESSION_LT(T,3)'); {$ENDIF}
end {EXPRESSION_LT};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSION_LTEQ(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(67) =   <Expression> ::= <SimpleExpression> <= <SimpleExpression>
// COUNT:  3     ^---(Tag=84)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[67]=EXPRESSION_LTEQ(T,3)'); {$ENDIF}
end {EXPRESSION_LTEQ};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSION_GT(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(68) =   <Expression> ::= <SimpleExpression> > <SimpleExpression>
// COUNT:  3     ^---(Tag=84)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[68]=EXPRESSION_GT(T,3)'); {$ENDIF}
end {EXPRESSION_GT};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSION_GTEQ(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(69) =   <Expression> ::= <SimpleExpression> >= <SimpleExpression>
// COUNT:  3     ^---(Tag=84)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[69]=EXPRESSION_GTEQ(T,3)'); {$ENDIF}
end {EXPRESSION_GTEQ};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_SIMPLEEXPRESSION(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(70) =   <SimpleExpression> ::= <Term>
// COUNT:  1     ^---(Tag=101)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[70]=SIMPLEEXPRESSION(T,1)'); {$ENDIF}
end {SIMPLEEXPRESSION};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_SIMPLEEXPRESSION_PLUS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(71) =   <SimpleExpression> ::= <SimpleExpression> + <Term>
// COUNT:  3     ^---(Tag=101)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[71]=SIMPLEEXPRESSION_PLUS(T,3)'); {$ENDIF}
end {SIMPLEEXPRESSION_PLUS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_SIMPLEEXPRESSION_MINUS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(72) =   <SimpleExpression> ::= <SimpleExpression> - <Term>
// COUNT:  3     ^---(Tag=101)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[72]=SIMPLEEXPRESSION_MINUS(T,3)'); {$ENDIF}
end {SIMPLEEXPRESSION_MINUS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_SIMPLEEXPRESSION_OR(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(73) =   <SimpleExpression> ::= <SimpleExpression> OR <Term>
// COUNT:  3     ^---(Tag=101)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[73]=SIMPLEEXPRESSION_OR(T,3)'); {$ENDIF}
end {SIMPLEEXPRESSION_OR};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TERM(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(74) =   <Term> ::= <Factor>
// COUNT:  1     ^---(Tag=104)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[74]=TERM(T,1)'); {$ENDIF}
end {TERM};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TERM_TIMES(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(75) =   <Term> ::= <Term> * <Factor>
// COUNT:  3     ^---(Tag=104)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[75]=TERM_TIMES(T,3)'); {$ENDIF}
end {TERM_TIMES};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TERM_DIV(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(76) =   <Term> ::= <Term> / <Factor>
// COUNT:  3     ^---(Tag=104)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[76]=TERM_DIV(T,3)'); {$ENDIF}
end {TERM_DIV};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TERM_DIV2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(77) =   <Term> ::= <Term> DIV <Factor>
// COUNT:  3     ^---(Tag=104)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[77]=TERM_DIV2(T,3)'); {$ENDIF}
end {TERM_DIV2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TERM_MOD(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(78) =   <Term> ::= <Term> MOD <Factor>
// COUNT:  3     ^---(Tag=104)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[78]=TERM_MOD(T,3)'); {$ENDIF}
end {TERM_MOD};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TERM_AND(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(79) =   <Term> ::= <Term> AND <Factor>
// COUNT:  3     ^---(Tag=104)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[79]=TERM_AND(T,3)'); {$ENDIF}
end {TERM_AND};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FACTOR_LPARAN_RPARAN(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(80) =   <Factor> ::= ( <Expression> )
// COUNT:  3     ^---(Tag=86)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[80]=FACTOR_LPARAN_RPARAN(T,3)'); {$ENDIF}
end {FACTOR_LPARAN_RPARAN};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FACTOR_PLUS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(81) =   <Factor> ::= + <Factor>
// COUNT:  2     ^---(Tag=86)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[81]=FACTOR_PLUS(T,2)'); {$ENDIF}
end {FACTOR_PLUS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FACTOR_MINUS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(82) =   <Factor> ::= - <Factor>
// COUNT:  2     ^---(Tag=86)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[82]=FACTOR_MINUS(T,2)'); {$ENDIF}
end {FACTOR_MINUS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FACTOR_NOT(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(83) =   <Factor> ::= NOT <Factor>
// COUNT:  2     ^---(Tag=86)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[83]=FACTOR_NOT(T,2)'); {$ENDIF}
end {FACTOR_NOT};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FACTOR(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(84) =   <Factor> ::= <constant>
// COUNT:  1     ^---(Tag=86)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[84]=FACTOR(T,1)'); {$ENDIF}
end {FACTOR};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FACTOR2(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(85) =   <Factor> ::= <Variable>
// COUNT:  1     ^---(Tag=86)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[85]=FACTOR2(T,1)'); {$ENDIF}
end {FACTOR2};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FACTOR3(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(86) =   <Factor> ::= <FunctionCall>
// COUNT:  1     ^---(Tag=86)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[86]=FACTOR3(T,1)'); {$ENDIF}
end {FACTOR3};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FUNCTIONCALL_ID_LPARAN_RPARAN(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(87) =   <FunctionCall> ::= id ( <ExpressionList> )
// COUNT:  4     ^---(Tag=90)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[87]=FUNCTIONCALL_ID_LPARAN_RPARAN(T,4)'); {$ENDIF}
end {FUNCTIONCALL_ID_LPARAN_RPARAN};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ACTUALS_LPARAN_RPARAN(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(88) =   <Actuals> ::= ( <ExpressionList> )
// COUNT:  3     ^---(Tag=67)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[88]=ACTUALS_LPARAN_RPARAN(T,3)'); {$ENDIF}
end {ACTUALS_LPARAN_RPARAN};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_ACTUALS(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(89) =   <Actuals> ::= 
// COUNT:  0     ^---(Tag=67)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[89]=ACTUALS(T,0)'); {$ENDIF}
end {ACTUALS};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSIONLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(90) =   <ExpressionList> ::= <Expression>
// COUNT:  1     ^---(Tag=85)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[90]=EXPRESSIONLIST(T,1)'); {$ENDIF}
end {EXPRESSIONLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_EXPRESSIONLIST_COMMA(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(91) =   <ExpressionList> ::= <Expression> , <ExpressionList>
// COUNT:  3     ^---(Tag=85)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[91]=EXPRESSIONLIST_COMMA(T,3)'); {$ENDIF}
end {EXPRESSIONLIST_COMMA};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLE_ID(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(92) =   <Variable> ::= id
// COUNT:  1     ^---(Tag=109)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[92]=VARIABLE_ID(T,1)'); {$ENDIF}
end {VARIABLE_ID};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLE_DOT_ID(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(93) =   <Variable> ::= <Variable> . id
// COUNT:  3     ^---(Tag=109)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[93]=VARIABLE_DOT_ID(T,3)'); {$ENDIF}
end {VARIABLE_DOT_ID};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLE_CARET(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(94) =   <Variable> ::= <Variable> ^
// COUNT:  2     ^---(Tag=109)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[94]=VARIABLE_CARET(T,2)'); {$ENDIF}
end {VARIABLE_CARET};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_VARIABLE_LBRACKET_RBRACKET(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(95) =   <Variable> ::= <Variable> [ <ExpressionList> ]
// COUNT:  4     ^---(Tag=109)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[95]=VARIABLE_LBRACKET_RBRACKET(T,4)'); {$ENDIF}
end {VARIABLE_LBRACKET_RBRACKET};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPESPECIFIER_ID(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(96) =   <TypeSpecifier> ::= id
// COUNT:  1     ^---(Tag=108)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[96]=TYPESPECIFIER_ID(T,1)'); {$ENDIF}
end {TYPESPECIFIER_ID};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPESPECIFIER_CARET(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(97) =   <TypeSpecifier> ::= ^ <TypeSpecifier>
// COUNT:  2     ^---(Tag=108)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[97]=TYPESPECIFIER_CARET(T,2)'); {$ENDIF}
end {TYPESPECIFIER_CARET};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPESPECIFIER_LPARAN_RPARAN(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(98) =   <TypeSpecifier> ::= ( <IdList> )
// COUNT:  3     ^---(Tag=108)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[98]=TYPESPECIFIER_LPARAN_RPARAN(T,3)'); {$ENDIF}
end {TYPESPECIFIER_LPARAN_RPARAN};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPESPECIFIER_DOTDOT(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(99) =   <TypeSpecifier> ::= <constant> .. <constant>
// COUNT:  3     ^---(Tag=108)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[99]=TYPESPECIFIER_DOTDOT(T,3)'); {$ENDIF}
end {TYPESPECIFIER_DOTDOT};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPESPECIFIER_ARRAY_LBRACKET_RBRACKET_OF(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(100) =   <TypeSpecifier> ::= ARRAY [ <DimensionList> ] OF <TypeSpecifier>
// COUNT:  6     ^---(Tag=108)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[100]=TYPESPECIFIER_ARRAY_LBRACKET_RBRACKET_OF(T,6)'); {$ENDIF}
end {TYPESPECIFIER_ARRAY_LBRACKET_RBRACKET_OF};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPESPECIFIER_RECORD_END(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(101) =   <TypeSpecifier> ::= RECORD <FieldList> END
// COUNT:  3     ^---(Tag=108)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[101]=TYPESPECIFIER_RECORD_END(T,3)'); {$ENDIF}
end {TYPESPECIFIER_RECORD_END};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_TYPESPECIFIER_FILE_OF(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(102) =   <TypeSpecifier> ::= FILE OF <TypeSpecifier>
// COUNT:  3     ^---(Tag=108)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[102]=TYPESPECIFIER_FILE_OF(T,3)'); {$ENDIF}
end {TYPESPECIFIER_FILE_OF};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_DIMENSIONLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(103) =   <DimensionList> ::= <Dimension>
// COUNT:  1     ^---(Tag=83)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[103]=DIMENSIONLIST(T,1)'); {$ENDIF}
end {DIMENSIONLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_DIMENSIONLIST_COMMA(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(104) =   <DimensionList> ::= <Dimension> , <DimensionList>
// COUNT:  3     ^---(Tag=83)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[104]=DIMENSIONLIST_COMMA(T,3)'); {$ENDIF}
end {DIMENSIONLIST_COMMA};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_DIMENSION_DOTDOT(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(105) =   <Dimension> ::= <constant> .. <constant>
// COUNT:  3     ^---(Tag=82)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[105]=DIMENSION_DOTDOT(T,3)'); {$ENDIF}
end {DIMENSION_DOTDOT};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_DIMENSION_ID(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(106) =   <Dimension> ::= id
// COUNT:  1     ^---(Tag=82)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[106]=DIMENSION_ID(T,1)'); {$ENDIF}
end {DIMENSION_ID};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FIELDLIST(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(107) =   <FieldList> ::= <Field>
// COUNT:  1     ^---(Tag=88)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[107]=FIELDLIST(T,1)'); {$ENDIF}
end {FIELDLIST};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FIELDLIST_SEMI(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(108) =   <FieldList> ::= <Field> ; <FieldList>
// COUNT:  3     ^---(Tag=88)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[108]=FIELDLIST_SEMI(T,3)'); {$ENDIF}
end {FIELDLIST_SEMI};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_FIELD_COLON(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(109) =   <Field> ::= <IdList> : <TypeSpecifier>
// COUNT:  3     ^---(Tag=87)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[109]=FIELD_COLON(T,3)'); {$ENDIF}
end {FIELD_COLON};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_IDLIST_ID(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(110) =   <IdList> ::= id
// COUNT:  1     ^---(Tag=92)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[110]=IDLIST_ID(T,1)'); {$ENDIF}
end {IDLIST_ID};


{-----------------------------------------------------------------------------}
PROCEDURE TParser.Action_IDLIST_ID_COMMA(T:PTokenList); 
{-----------------------------------------------------------------------------}
// RULE(111) =   <IdList> ::= id , <IdList>
// COUNT:  3     ^---(Tag=92)
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  {$IFDEF Debug_ACTIONS} WriteLn(Fo^, 'Call Rule[111]=IDLIST_ID_COMMA(T,3)'); {$ENDIF}
end {IDLIST_ID_COMMA};





{-----------------------------------------------------------------------------}
function TLexer.GetLexeme(SkipMode:Boolean):Integer;
{-----------------------------------------------------------------------------}
TYPE TLexEdge = record SetNr:Byte; L:Integer; end;
     PLexEdge = ^TLexEdge;
     TByteSet = set of Byte;  //32bytes long
     PByteSet = ^TByteSet;
CONST
  Empty=79;
  CharSet : array [0..79] of TByteSet = (
    {#0} [9..13,32,160],
    {#1} [125],
    {#2} [123],
    {#3} [45],
    {#4} [41],
    {#5} [44],
    {#6} [59],
    {#7} [91],
    {#8} [93],
    {#9} [94],
    {#10} [43],
    {#11} [61],
    {#12} [48],
    {#13} [36],
    {#14} [71..72,74..76,81,83,88..90,95,103..104,106..108,113,115,120..122],
    {#15} [39],
    {#16} [40],
    {#17} [42],
    {#18} [46],
    {#19} [47],
    {#20} [49..57],
    {#21} [58],
    {#22} [60],
    {#23} [62],
    {#24} [65,97],
    {#25} [66,98],
    {#26} [67,99],
    {#27} [68,100],
    {#28} [69,101],
    {#29} [70,102],
    {#30} [73,105],
    {#31} [77,109],
    {#32} [78,110],
    {#33} [79,111],
    {#34} [80,112],
    {#35} [82,114],
    {#36} [84,116],
    {#37} [85,117],
    {#38} [86,118],
    {#39} [87,119],
    {#40} [48..57],
    {#41} [48..57,65..70,97..102],
    {#42} [48..57,65..90,95,97..122],
    {#43} [32..38,40..91,93..126,160],
    {#44} [92],
    {#45} [48..57,65..77,79..81,83..90,95,97..109,111..113,115..122],
    {#46} [48..57,65..67,69..90,95,97..99,101..122],
    {#47} [48..57,65..81,83..90,95,97..113,115..122],
    {#48} [48..57,66..90,95,98..122],
    {#49} [48..57,65..88,90,95,97..120,122],
    {#50} [89,121],
    {#51} [48..57,65..68,70..90,95,97..100,102..122],
    {#52} [48..57,65..70,72..90,95,97..102,104..122],
    {#53} [71,103],
    {#54} [48..57,65..72,74..90,95,97..104,106..122],
    {#55} [48..57,65..77,79..90,95,97..109,111..122],
    {#56} [48..57,66..78,80..90,95,98..110,112..122],
    {#57} [48..57,65..82,84..90,95,97..114,116..122],
    {#58} [83,115],
    {#59} [48..57,65..83,85..90,95,97..115,117..122],
    {#60} [48..57,65..72,74..78,80..90,95,97..104,106..110,112..122],
    {#61} [48..57,65..85,87..90,95,97..117,119..122],
    {#62} [48..57,65..86,88..90,95,97..118,120..122],
    {#63} [48..57,65..78,80..90,95,97..110,112..122],
    {#64} [48..57,65..75,77,79..90,95,97..107,109,111..122],
    {#65} [76,108],
    {#66} [48..57,65..72,74..78,80..84,86..90,95,97..104,106..110,112..116,118..122],
    {#67} [48..57,65..75,77..90,95,97..107,109..122],
    {#68} [48..57,65..66,68..90,95,97..98,100..122],
    {#69} [48..57,65..69,71..90,95,97..101,103..122],
    {#70} [48..57,65..69,71..81,83..90,95,97..101,103..113,115..122],
    {#71} [48..57,65..66,68..70,72..90,95,97..98,100..102,104..122],
    {#72} [48..57,65..84,86..90,95,97..116,118..122],
    {#73} [48..57,65..76,78..90,95,97..108,110..122],
    {#74} [48..57,65..66,68..79,81..90,95,97..98,100..111,113..122],
    {#75} [48..57,65..71,73..78,80..88,90,95,97..103,105..110,112..120,122],
    {#76} [72,104],
    {#77} [48..57,65..79,81..90,95,97..111,113..122],
    {#78} [48..57,65..71,73..90,95,97..103,105..122],
    []
  );
  LexState0: array [0..40] of TLexEdge = ( 
    (SetNr:0;        L:1), 
    (SetNr:1;        L:2), 
    (SetNr:2;        L:3), 
    (SetNr:3;        L:4), 
    (SetNr:4;        L:5), 
    (SetNr:5;        L:6), 
    (SetNr:6;        L:7), 
    (SetNr:7;        L:8), 
    (SetNr:8;        L:9), 
    (SetNr:9;        L:10), 
    (SetNr:10;        L:11), 
    (SetNr:11;        L:12), 
    (SetNr:12;        L:13), 
    (SetNr:13;        L:16), 
    (SetNr:14;        L:18), 
    (SetNr:15;        L:20), 
    (SetNr:16;        L:34), 
    (SetNr:17;        L:36), 
    (SetNr:18;        L:38), 
    (SetNr:19;        L:40), 
    (SetNr:20;        L:42), 
    (SetNr:21;        L:44), 
    (SetNr:22;        L:46), 
    (SetNr:23;        L:49), 
    (SetNr:24;        L:51), 
    (SetNr:25;        L:58), 
    (SetNr:26;        L:63), 
    (SetNr:27;        L:71), 
    (SetNr:28;        L:79), 
    (SetNr:29;        L:85), 
    (SetNr:30;        L:102), 
    (SetNr:31;        L:104), 
    (SetNr:32;        L:107), 
    (SetNr:33;        L:110), 
    (SetNr:34;        L:113), 
    (SetNr:35;        L:126), 
    (SetNr:36;        L:136), 
    (SetNr:37;        L:144), 
    (SetNr:38;        L:149), 
    (SetNr:39;        L:152), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState1: array [0..1] of TLexEdge = ( 
    (SetNr:0;        L:1), 
    (SetNr:Empty; L:2)); //Tag:=2
  LexState2: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:3)); //Tag:=3
  LexState3: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:5)); //Tag:=5
  LexState4: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:6)); //Tag:=6
  LexState5: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:8)); //Tag:=8
  LexState6: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:10)); //Tag:=10
  LexState7: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:16)); //Tag:=16
  LexState8: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:17)); //Tag:=17
  LexState9: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:18)); //Tag:=18
  LexState10: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:19)); //Tag:=19
  LexState11: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:20)); //Tag:=20
  LexState12: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:24)); //Tag:=24
  LexState13: array [0..2] of TLexEdge = ( 
    (SetNr:40;        L:13), 
    (SetNr:18;        L:14), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState14: array [0..1] of TLexEdge = ( 
    (SetNr:40;        L:15), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState15: array [0..1] of TLexEdge = ( 
    (SetNr:40;        L:15), 
    (SetNr:Empty; L:44)); //Tag:=44
  LexState16: array [0..1] of TLexEdge = ( 
    (SetNr:41;        L:17), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState17: array [0..1] of TLexEdge = ( 
    (SetNr:41;        L:17), 
    (SetNr:Empty; L:48)); //Tag:=48
  LexState18: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState19: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState20: array [0..3] of TLexEdge = ( 
    (SetNr:15;        L:21), 
    (SetNr:43;        L:22), 
    (SetNr:44;        L:29), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState21: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:59)); //Tag:=59
  LexState22: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:23), 
    (SetNr:15;        L:28), 
    (SetNr:44;        L:24), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState23: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:23), 
    (SetNr:15;        L:21), 
    (SetNr:44;        L:24), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState24: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:25), 
    (SetNr:15;        L:26), 
    (SetNr:44;        L:27), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState25: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:23), 
    (SetNr:15;        L:21), 
    (SetNr:44;        L:24), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState26: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:23), 
    (SetNr:15;        L:21), 
    (SetNr:44;        L:24), 
    (SetNr:Empty; L:59)); //Tag:=59
  LexState27: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:25), 
    (SetNr:15;        L:26), 
    (SetNr:44;        L:27), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState28: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:31)); //Tag:=31
  LexState29: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:30), 
    (SetNr:15;        L:31), 
    (SetNr:44;        L:32), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState30: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:23), 
    (SetNr:15;        L:28), 
    (SetNr:44;        L:24), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState31: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:23), 
    (SetNr:15;        L:28), 
    (SetNr:44;        L:24), 
    (SetNr:Empty; L:31)); //Tag:=31
  LexState32: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:25), 
    (SetNr:15;        L:33), 
    (SetNr:44;        L:27), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState33: array [0..3] of TLexEdge = ( 
    (SetNr:43;        L:23), 
    (SetNr:15;        L:21), 
    (SetNr:44;        L:24), 
    (SetNr:Empty; L:31)); //Tag:=31
  LexState34: array [0..1] of TLexEdge = ( 
    (SetNr:17;        L:35), 
    (SetNr:Empty; L:7)); //Tag:=7
  LexState35: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:34)); //Tag:=34
  LexState36: array [0..1] of TLexEdge = ( 
    (SetNr:4;        L:37), 
    (SetNr:Empty; L:9)); //Tag:=9
  LexState37: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:32)); //Tag:=32
  LexState38: array [0..2] of TLexEdge = ( 
    (SetNr:18;        L:39), 
    (SetNr:40;        L:15), 
    (SetNr:Empty; L:11)); //Tag:=11
  LexState39: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:12)); //Tag:=12
  LexState40: array [0..1] of TLexEdge = ( 
    (SetNr:19;        L:41), 
    (SetNr:Empty; L:13)); //Tag:=13
  LexState41: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:4)); //Tag:=4
  LexState42: array [0..2] of TLexEdge = ( 
    (SetNr:18;        L:14), 
    (SetNr:40;        L:43), 
    (SetNr:Empty; L:37)); //Tag:=37
  LexState43: array [0..2] of TLexEdge = ( 
    (SetNr:18;        L:14), 
    (SetNr:40;        L:43), 
    (SetNr:Empty; L:37)); //Tag:=37
  LexState44: array [0..1] of TLexEdge = ( 
    (SetNr:11;        L:45), 
    (SetNr:Empty; L:14)); //Tag:=14
  LexState45: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:15)); //Tag:=15
  LexState46: array [0..2] of TLexEdge = ( 
    (SetNr:11;        L:47), 
    (SetNr:23;        L:48), 
    (SetNr:Empty; L:21)); //Tag:=21
  LexState47: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:22)); //Tag:=22
  LexState48: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:23)); //Tag:=23
  LexState49: array [0..1] of TLexEdge = ( 
    (SetNr:11;        L:50), 
    (SetNr:Empty; L:25)); //Tag:=25
  LexState50: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:26)); //Tag:=26
  LexState51: array [0..3] of TLexEdge = ( 
    (SetNr:45;        L:19), 
    (SetNr:32;        L:52), 
    (SetNr:35;        L:54), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState52: array [0..2] of TLexEdge = ( 
    (SetNr:46;        L:19), 
    (SetNr:27;        L:53), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState53: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:27)); //Tag:=27
  LexState54: array [0..2] of TLexEdge = ( 
    (SetNr:47;        L:19), 
    (SetNr:35;        L:55), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState55: array [0..2] of TLexEdge = ( 
    (SetNr:48;        L:19), 
    (SetNr:24;        L:56), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState56: array [0..2] of TLexEdge = ( 
    (SetNr:49;        L:19), 
    (SetNr:50;        L:57), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState57: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:28)); //Tag:=28
  LexState58: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:59), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState59: array [0..2] of TLexEdge = ( 
    (SetNr:52;        L:19), 
    (SetNr:53;        L:60), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState60: array [0..2] of TLexEdge = ( 
    (SetNr:54;        L:19), 
    (SetNr:30;        L:61), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState61: array [0..2] of TLexEdge = ( 
    (SetNr:55;        L:19), 
    (SetNr:32;        L:62), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState62: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:29)); //Tag:=29
  LexState63: array [0..3] of TLexEdge = ( 
    (SetNr:56;        L:19), 
    (SetNr:24;        L:64), 
    (SetNr:33;        L:67), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState64: array [0..2] of TLexEdge = ( 
    (SetNr:57;        L:19), 
    (SetNr:58;        L:65), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState65: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:66), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState66: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:30)); //Tag:=30
  LexState67: array [0..2] of TLexEdge = ( 
    (SetNr:55;        L:19), 
    (SetNr:32;        L:68), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState68: array [0..2] of TLexEdge = ( 
    (SetNr:57;        L:19), 
    (SetNr:58;        L:69), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState69: array [0..2] of TLexEdge = ( 
    (SetNr:59;        L:19), 
    (SetNr:36;        L:70), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState70: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:36)); //Tag:=36
  LexState71: array [0..3] of TLexEdge = ( 
    (SetNr:60;        L:19), 
    (SetNr:30;        L:72), 
    (SetNr:33;        L:74), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState72: array [0..2] of TLexEdge = ( 
    (SetNr:61;        L:19), 
    (SetNr:38;        L:73), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState73: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:38)); //Tag:=38
  LexState74: array [0..2] of TLexEdge = ( 
    (SetNr:62;        L:19), 
    (SetNr:39;        L:75), 
    (SetNr:Empty; L:39)); //Tag:=39
  LexState75: array [0..2] of TLexEdge = ( 
    (SetNr:55;        L:19), 
    (SetNr:32;        L:76), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState76: array [0..2] of TLexEdge = ( 
    (SetNr:59;        L:19), 
    (SetNr:36;        L:77), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState77: array [0..2] of TLexEdge = ( 
    (SetNr:63;        L:19), 
    (SetNr:33;        L:78), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState78: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:40)); //Tag:=40
  LexState79: array [0..3] of TLexEdge = ( 
    (SetNr:64;        L:19), 
    (SetNr:65;        L:80), 
    (SetNr:32;        L:83), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState80: array [0..2] of TLexEdge = ( 
    (SetNr:57;        L:19), 
    (SetNr:58;        L:81), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState81: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:82), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState82: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:41)); //Tag:=41
  LexState83: array [0..2] of TLexEdge = ( 
    (SetNr:46;        L:19), 
    (SetNr:27;        L:84), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState84: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:42)); //Tag:=42
  LexState85: array [0..4] of TLexEdge = ( 
    (SetNr:66;        L:19), 
    (SetNr:30;        L:86), 
    (SetNr:33;        L:89), 
    (SetNr:37;        L:95), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState86: array [0..2] of TLexEdge = ( 
    (SetNr:67;        L:19), 
    (SetNr:65;        L:87), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState87: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:88), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState88: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:43)); //Tag:=43
  LexState89: array [0..2] of TLexEdge = ( 
    (SetNr:47;        L:19), 
    (SetNr:35;        L:90), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState90: array [0..2] of TLexEdge = ( 
    (SetNr:62;        L:19), 
    (SetNr:39;        L:91), 
    (SetNr:Empty; L:45)); //Tag:=45
  LexState91: array [0..2] of TLexEdge = ( 
    (SetNr:48;        L:19), 
    (SetNr:24;        L:92), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState92: array [0..2] of TLexEdge = ( 
    (SetNr:47;        L:19), 
    (SetNr:35;        L:93), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState93: array [0..2] of TLexEdge = ( 
    (SetNr:46;        L:19), 
    (SetNr:27;        L:94), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState94: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:46)); //Tag:=46
  LexState95: array [0..2] of TLexEdge = ( 
    (SetNr:55;        L:19), 
    (SetNr:32;        L:96), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState96: array [0..2] of TLexEdge = ( 
    (SetNr:68;        L:19), 
    (SetNr:26;        L:97), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState97: array [0..2] of TLexEdge = ( 
    (SetNr:59;        L:19), 
    (SetNr:36;        L:98), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState98: array [0..2] of TLexEdge = ( 
    (SetNr:54;        L:19), 
    (SetNr:30;        L:99), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState99: array [0..2] of TLexEdge = ( 
    (SetNr:63;        L:19), 
    (SetNr:33;        L:100), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState100: array [0..2] of TLexEdge = ( 
    (SetNr:55;        L:19), 
    (SetNr:32;        L:101), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState101: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:47)); //Tag:=47
  LexState102: array [0..2] of TLexEdge = ( 
    (SetNr:69;        L:19), 
    (SetNr:29;        L:103), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState103: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:50)); //Tag:=50
  LexState104: array [0..2] of TLexEdge = ( 
    (SetNr:63;        L:19), 
    (SetNr:33;        L:105), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState105: array [0..2] of TLexEdge = ( 
    (SetNr:46;        L:19), 
    (SetNr:27;        L:106), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState106: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:51)); //Tag:=51
  LexState107: array [0..2] of TLexEdge = ( 
    (SetNr:63;        L:19), 
    (SetNr:33;        L:108), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState108: array [0..2] of TLexEdge = ( 
    (SetNr:59;        L:19), 
    (SetNr:36;        L:109), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState109: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:52)); //Tag:=52
  LexState110: array [0..3] of TLexEdge = ( 
    (SetNr:70;        L:19), 
    (SetNr:29;        L:111), 
    (SetNr:35;        L:112), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState111: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:53)); //Tag:=53
  LexState112: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:54)); //Tag:=54
  LexState113: array [0..2] of TLexEdge = ( 
    (SetNr:47;        L:19), 
    (SetNr:35;        L:114), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState114: array [0..2] of TLexEdge = ( 
    (SetNr:63;        L:19), 
    (SetNr:33;        L:115), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState115: array [0..3] of TLexEdge = ( 
    (SetNr:71;        L:19), 
    (SetNr:26;        L:116), 
    (SetNr:53;        L:122), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState116: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:117), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState117: array [0..2] of TLexEdge = ( 
    (SetNr:46;        L:19), 
    (SetNr:27;        L:118), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState118: array [0..2] of TLexEdge = ( 
    (SetNr:72;        L:19), 
    (SetNr:37;        L:119), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState119: array [0..2] of TLexEdge = ( 
    (SetNr:47;        L:19), 
    (SetNr:35;        L:120), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState120: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:121), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState121: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:55)); //Tag:=55
  LexState122: array [0..2] of TLexEdge = ( 
    (SetNr:47;        L:19), 
    (SetNr:35;        L:123), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState123: array [0..2] of TLexEdge = ( 
    (SetNr:48;        L:19), 
    (SetNr:24;        L:124), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState124: array [0..2] of TLexEdge = ( 
    (SetNr:73;        L:19), 
    (SetNr:31;        L:125), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState125: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:56)); //Tag:=56
  LexState126: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:127), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState127: array [0..3] of TLexEdge = ( 
    (SetNr:74;        L:19), 
    (SetNr:26;        L:128), 
    (SetNr:34;        L:132), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState128: array [0..2] of TLexEdge = ( 
    (SetNr:63;        L:19), 
    (SetNr:33;        L:129), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState129: array [0..2] of TLexEdge = ( 
    (SetNr:47;        L:19), 
    (SetNr:35;        L:130), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState130: array [0..2] of TLexEdge = ( 
    (SetNr:46;        L:19), 
    (SetNr:27;        L:131), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState131: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:57)); //Tag:=57
  LexState132: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:133), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState133: array [0..2] of TLexEdge = ( 
    (SetNr:48;        L:19), 
    (SetNr:24;        L:134), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState134: array [0..2] of TLexEdge = ( 
    (SetNr:59;        L:19), 
    (SetNr:36;        L:135), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState135: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:58)); //Tag:=58
  LexState136: array [0..4] of TLexEdge = ( 
    (SetNr:75;        L:19), 
    (SetNr:76;        L:137), 
    (SetNr:33;        L:140), 
    (SetNr:50;        L:141), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState137: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:138), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState138: array [0..2] of TLexEdge = ( 
    (SetNr:55;        L:19), 
    (SetNr:32;        L:139), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState139: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:61)); //Tag:=61
  LexState140: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:62)); //Tag:=62
  LexState141: array [0..2] of TLexEdge = ( 
    (SetNr:77;        L:19), 
    (SetNr:34;        L:142), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState142: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:143), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState143: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:63)); //Tag:=63
  LexState144: array [0..2] of TLexEdge = ( 
    (SetNr:55;        L:19), 
    (SetNr:32;        L:145), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState145: array [0..2] of TLexEdge = ( 
    (SetNr:59;        L:19), 
    (SetNr:36;        L:146), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState146: array [0..2] of TLexEdge = ( 
    (SetNr:54;        L:19), 
    (SetNr:30;        L:147), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState147: array [0..2] of TLexEdge = ( 
    (SetNr:67;        L:19), 
    (SetNr:65;        L:148), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState148: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:64)); //Tag:=64
  LexState149: array [0..2] of TLexEdge = ( 
    (SetNr:48;        L:19), 
    (SetNr:24;        L:150), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState150: array [0..2] of TLexEdge = ( 
    (SetNr:47;        L:19), 
    (SetNr:35;        L:151), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState151: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:65)); //Tag:=65
  LexState152: array [0..2] of TLexEdge = ( 
    (SetNr:78;        L:19), 
    (SetNr:76;        L:153), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState153: array [0..2] of TLexEdge = ( 
    (SetNr:54;        L:19), 
    (SetNr:30;        L:154), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState154: array [0..2] of TLexEdge = ( 
    (SetNr:67;        L:19), 
    (SetNr:65;        L:155), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState155: array [0..2] of TLexEdge = ( 
    (SetNr:51;        L:19), 
    (SetNr:28;        L:156), 
    (SetNr:Empty; L:49)); //Tag:=49
  LexState156: array [0..1] of TLexEdge = ( 
    (SetNr:42;        L:19), 
    (SetNr:Empty; L:66)); //Tag:=66
  LexStateList: array [0..157] of PLexEdge = (
    @LexState0,
    @LexState1,
    @LexState2,
    @LexState3,
    @LexState4,
    @LexState5,
    @LexState6,
    @LexState7,
    @LexState8,
    @LexState9,
    @LexState10,
    @LexState11,
    @LexState12,
    @LexState13,
    @LexState14,
    @LexState15,
    @LexState16,
    @LexState17,
    @LexState18,
    @LexState19,
    @LexState20,
    @LexState21,
    @LexState22,
    @LexState23,
    @LexState24,
    @LexState25,
    @LexState26,
    @LexState27,
    @LexState28,
    @LexState29,
    @LexState30,
    @LexState31,
    @LexState32,
    @LexState33,
    @LexState34,
    @LexState35,
    @LexState36,
    @LexState37,
    @LexState38,
    @LexState39,
    @LexState40,
    @LexState41,
    @LexState42,
    @LexState43,
    @LexState44,
    @LexState45,
    @LexState46,
    @LexState47,
    @LexState48,
    @LexState49,
    @LexState50,
    @LexState51,
    @LexState52,
    @LexState53,
    @LexState54,
    @LexState55,
    @LexState56,
    @LexState57,
    @LexState58,
    @LexState59,
    @LexState60,
    @LexState61,
    @LexState62,
    @LexState63,
    @LexState64,
    @LexState65,
    @LexState66,
    @LexState67,
    @LexState68,
    @LexState69,
    @LexState70,
    @LexState71,
    @LexState72,
    @LexState73,
    @LexState74,
    @LexState75,
    @LexState76,
    @LexState77,
    @LexState78,
    @LexState79,
    @LexState80,
    @LexState81,
    @LexState82,
    @LexState83,
    @LexState84,
    @LexState85,
    @LexState86,
    @LexState87,
    @LexState88,
    @LexState89,
    @LexState90,
    @LexState91,
    @LexState92,
    @LexState93,
    @LexState94,
    @LexState95,
    @LexState96,
    @LexState97,
    @LexState98,
    @LexState99,
    @LexState100,
    @LexState101,
    @LexState102,
    @LexState103,
    @LexState104,
    @LexState105,
    @LexState106,
    @LexState107,
    @LexState108,
    @LexState109,
    @LexState110,
    @LexState111,
    @LexState112,
    @LexState113,
    @LexState114,
    @LexState115,
    @LexState116,
    @LexState117,
    @LexState118,
    @LexState119,
    @LexState120,
    @LexState121,
    @LexState122,
    @LexState123,
    @LexState124,
    @LexState125,
    @LexState126,
    @LexState127,
    @LexState128,
    @LexState129,
    @LexState130,
    @LexState131,
    @LexState132,
    @LexState133,
    @LexState134,
    @LexState135,
    @LexState136,
    @LexState137,
    @LexState138,
    @LexState139,
    @LexState140,
    @LexState141,
    @LexState142,
    @LexState143,
    @LexState144,
    @LexState145,
    @LexState146,
    @LexState147,
    @LexState148,
    @LexState149,
    @LexState150,
    @LexState151,
    @LexState152,
    @LexState153,
    @LexState154,
    @LexState155,
    @LexState156,
    Nil
  );
  InitialState=0;
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// Reads a "lexeme", being a logical cohesive sequence of characters 
//
// if SkipMode is true, the reader becomes verry tolerant to errors
// It will consume all characters unless a lexeme of one or two
// characters is found. This enables you to skip block comments until a closing
// lexeme is found, like '}' or '*)'
//
// This lexeme reader can read one character ahead. The result is that it will read
// only a character, if the ahead character is not in conflict with a valid lexeme.
// This enables you to tokenize an input stream like('13..37') into a valid
// ('13'+'..'+'378') and not as ('13.') followed by an error.
// This mechanism uses the flag LexAccept, to delays acceptance of a char, until 
// its ahead char has proven not to be in conflict with a valid lexeme
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
label LexBegin, LexNextState, LexNextSet, LexDone;
var LexEdgePtr:PLexEdge;
    LexSetNr:Integer;
    LexChar:Char;
    LexAccept:Boolean; //reads one character ahead, to enable 123..456
    LexTag, State, OldState:Integer;
    LexTagStr: string[5];
begin
LexBegin:
  Token.LinePos:=LinePos;
  Token.CharPos:=CharPos;
  Token.Tag:=1; {Tag_ERROR};
  LexemeLen:=0;
  LexemeStr:='';
  State:=InitialState;
  OldState:=InitialState;
  LexChar:=CurChar;
  LexAccept:=False;
LexNextState:
  {$IFDEF Debug_LEXER}
  Write(Fo^,'  LexState=',State:3, ',  ord(Char)=',ord(LexChar):3,',  Char=');
  if ord(LexChar)>31 then write(Fo^,'"',LexChar,'"') else write(Fo^,'***');
  {$ENDIF Debug_LEXER}
  LexEdgePtr:=LexStateList[State];
  LexSetNr:=LexEdgePtr^.SetNr;
  {}
LexNextSet: {Loop}
  if (LexSetNr=Empty) then begin
    LexTag:=LexEdgePtr^.L;
    if (LexTag>=0) or (SkipMode and (LexemeLen=0)) then GetChar else begin
      {$IFDEF Debug_LEXER} Write(Fo^,'   (not found, set back)'); {$ENDIF}
      //try to repair error by falling back to previous state;
      LexEdgePtr:=LexStateList[OldState];
      while (LexEdgePtr^.SetNr<>Empty) do inc(LexEdgePtr);
      LexTag:=LexEdgePtr^.L;
    end;
    goto LexDone;
  end;
  if (ord(LexChar) in CharSet[LexSetNr]) then begin
    {$IFDEF Debug_LEXER} WriteLn(Fo^,',  (Found in CharSet[',LexSetNr,'])'); {$ENDIF}
    OldState:=State;
    State:=LexEdgePtr^.L;
    if SkipMode and (LexemeLen=1) then goto LexBegin;
    if LexAccept then GetChar;
    LexChar:=NextChar; LexAccept:=True;
    goto LexNextState;
  end;
  inc(LexEdgePtr);
  LexSetNr:=LexEdgePtr^.SetNr;
  goto LexNextSet;  {next}
  {}
LexDone:
  if (LexTag<0) and (CurChar=EOF) then LexTag:=0; {TAG_EOF}
  {$IFDEF Debug_LEXER} WriteLn(Fo^,',  ==> Tag:=',LexTag); {$ENDIF}
  GetLexeme:=LexTag;
  {$IFDEF Debug_LEXEMES}
  case LexTag of
    TAG_WHITESPACE:    LexTagStr:='<WS>';
    TAG_COMMENTLINE:   LexTagStr:='<CL>';
    TAG_COMMENTSTART:  LexTagStr:='<CS>';
    TAG_COMMENTEND:    LexTagStr:='<CE>';
    TAG_EOF:           LexTagStr:='<EOF>';
    else               LexTagStr:='';
  end;
  write(Fo^,'Lexeme(',Token.LinePos:1,':',Token.CharPos:1,').Tag=',Tab);
  if LexTagStr=''
    then WriteLn(Fo^, LexTag,    Tab,'"',LexemeStr,'"')
    else WriteLn(Fo^, LexTagStr, Tab,'"',LexemeStr,'"');
  {$ENDIF}  
end;


{-----------------------------------------------------------------------------}
function TParser.DoParse(StackSize:Integer):Integer;
{-----------------------------------------------------------------------------}
const Any  =TagAny;
      ActError=0; ActShift=1; ActReduce=2; ActNext=3; ActAccept=4;
      StartState=0;       
type  TState =0..238; 
      PState =^TState; 
      TParseEdge= packed record Tag:TTokenTag; Q:TState; Act:Byte; end;
      PParseEdge=^TParseEdge;
      TEntry = packed record EntryPtr:PParseEdge; EdgeCnt:Byte; end; 
var   StateStack, StateStackTop, StateStackEnd: PState;
      TokenStack, TokenStackTop:                PToken;
      ErrorState:    TState;
      ErrorStatePtr: PState;
      HasShifted:    Boolean;
const ParseState0: packed array[0..3] of TParseEdge= (
        (Tag:56; Q:1; Act:1), //Shift; 
        (Tag:98; Q:2; Act:3), //Goto; 
        (Tag:99; Q:3; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState1: packed array[0..1] of TParseEdge= (
        (Tag:49; Q:4; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState2: packed array[0..1] of TParseEdge= (
        (Tag:0; Q:0; Act:4), //Accept; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState3: packed array[0..8] of TParseEdge= (
        (Tag:36; Q:5; Act:1), //Shift; 
        (Tag:79; Q:6; Act:3), //Goto; 
        (Tag:81; Q:7; Act:3), //Goto; 
        (Tag:29; Q:10; Act:2), //Reduce Rule; 
        (Tag:47; Q:10; Act:2), //Reduce Rule; 
        (Tag:55; Q:10; Act:2), //Reduce Rule; 
        (Tag:63; Q:10; Act:2), //Reduce Rule; 
        (Tag:65; Q:10; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState4: packed array[0..2] of TParseEdge= (
        (Tag:7; Q:8; Act:1), //Shift; 
        (Tag:16; Q:9; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState5: packed array[0..3] of TParseEdge= (
        (Tag:49; Q:10; Act:1), //Shift; 
        (Tag:77; Q:11; Act:3), //Goto; 
        (Tag:78; Q:12; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState6: packed array[0..6] of TParseEdge= (
        (Tag:63; Q:13; Act:1), //Shift; 
        (Tag:107; Q:14; Act:3), //Goto; 
        (Tag:29; Q:15; Act:2), //Reduce Rule; 
        (Tag:47; Q:15; Act:2), //Reduce Rule; 
        (Tag:55; Q:15; Act:2), //Reduce Rule; 
        (Tag:65; Q:15; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState7: packed array[0..2] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:75; Q:16; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState8: packed array[0..2] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:92; Q:18; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState9: packed array[0..6] of TParseEdge= (
        (Tag:29; Q:6; Act:2), //Reduce Rule; 
        (Tag:36; Q:6; Act:2), //Reduce Rule; 
        (Tag:47; Q:6; Act:2), //Reduce Rule; 
        (Tag:55; Q:6; Act:2), //Reduce Rule; 
        (Tag:63; Q:6; Act:2), //Reduce Rule; 
        (Tag:65; Q:6; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState10: packed array[0..1] of TParseEdge= (
        (Tag:24; Q:19; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState11: packed array[0..8] of TParseEdge= (
        (Tag:49; Q:10; Act:1), //Shift; 
        (Tag:77; Q:11; Act:3), //Goto; 
        (Tag:78; Q:20; Act:3), //Goto; 
        (Tag:29; Q:11; Act:2), //Reduce Rule; 
        (Tag:47; Q:11; Act:2), //Reduce Rule; 
        (Tag:55; Q:11; Act:2), //Reduce Rule; 
        (Tag:63; Q:11; Act:2), //Reduce Rule; 
        (Tag:65; Q:11; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState12: packed array[0..5] of TParseEdge= (
        (Tag:29; Q:9; Act:2), //Reduce Rule; 
        (Tag:47; Q:9; Act:2), //Reduce Rule; 
        (Tag:55; Q:9; Act:2), //Reduce Rule; 
        (Tag:63; Q:9; Act:2), //Reduce Rule; 
        (Tag:65; Q:9; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState13: packed array[0..3] of TParseEdge= (
        (Tag:49; Q:21; Act:1), //Shift; 
        (Tag:105; Q:22; Act:3), //Goto; 
        (Tag:106; Q:23; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState14: packed array[0..5] of TParseEdge= (
        (Tag:65; Q:24; Act:1), //Shift; 
        (Tag:112; Q:25; Act:3), //Goto; 
        (Tag:29; Q:20; Act:2), //Reduce Rule; 
        (Tag:47; Q:20; Act:2), //Reduce Rule; 
        (Tag:55; Q:20; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState15: packed array[0..20] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:39; Act:3), //Goto; 
        (Tag:103; Q:40; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:16; Q:49; Act:2), //Reduce Rule; 
        (Tag:42; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState16: packed array[0..1] of TParseEdge= (
        (Tag:11; Q:43; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState17: packed array[0..3] of TParseEdge= (
        (Tag:10; Q:44; Act:1), //Shift; 
        (Tag:8; Q:110; Act:2), //Reduce Rule; 
        (Tag:14; Q:110; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState18: packed array[0..1] of TParseEdge= (
        (Tag:8; Q:45; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState19: packed array[0..6] of TParseEdge= (
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:51; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState20: packed array[0..5] of TParseEdge= (
        (Tag:29; Q:12; Act:2), //Reduce Rule; 
        (Tag:47; Q:12; Act:2), //Reduce Rule; 
        (Tag:55; Q:12; Act:2), //Reduce Rule; 
        (Tag:63; Q:12; Act:2), //Reduce Rule; 
        (Tag:65; Q:12; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState21: packed array[0..1] of TParseEdge= (
        (Tag:24; Q:52; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState22: packed array[0..7] of TParseEdge= (
        (Tag:49; Q:21; Act:1), //Shift; 
        (Tag:105; Q:22; Act:3), //Goto; 
        (Tag:106; Q:53; Act:3), //Goto; 
        (Tag:29; Q:16; Act:2), //Reduce Rule; 
        (Tag:47; Q:16; Act:2), //Reduce Rule; 
        (Tag:55; Q:16; Act:2), //Reduce Rule; 
        (Tag:65; Q:16; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState23: packed array[0..4] of TParseEdge= (
        (Tag:29; Q:14; Act:2), //Reduce Rule; 
        (Tag:47; Q:14; Act:2), //Reduce Rule; 
        (Tag:55; Q:14; Act:2), //Reduce Rule; 
        (Tag:65; Q:14; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState24: packed array[0..4] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:92; Q:54; Act:3), //Goto; 
        (Tag:110; Q:55; Act:3), //Goto; 
        (Tag:111; Q:56; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState25: packed array[0..7] of TParseEdge= (
        (Tag:47; Q:57; Act:1), //Shift; 
        (Tag:55; Q:58; Act:1), //Shift; 
        (Tag:91; Q:59; Act:3), //Goto; 
        (Tag:95; Q:60; Act:3), //Goto; 
        (Tag:96; Q:61; Act:3), //Goto; 
        (Tag:97; Q:62; Act:3), //Goto; 
        (Tag:29; Q:25; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState26: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:69; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState27: packed array[0..1] of TParseEdge= (
        (Tag:49; Q:75; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState28: packed array[0..10] of TParseEdge= (
        (Tag:7; Q:76; Act:1), //Shift; 
        (Tag:67; Q:77; Act:3), //Goto; 
        (Tag:11; Q:92; Act:2), //Reduce Rule; 
        (Tag:15; Q:92; Act:2), //Reduce Rule; 
        (Tag:17; Q:92; Act:2), //Reduce Rule; 
        (Tag:19; Q:92; Act:2), //Reduce Rule; 
        (Tag:16; Q:89; Act:2), //Reduce Rule; 
        (Tag:41; Q:89; Act:2), //Reduce Rule; 
        (Tag:42; Q:89; Act:2), //Reduce Rule; 
        (Tag:64; Q:89; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState29: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:78; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState30: packed array[0..20] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:39; Act:3), //Goto; 
        (Tag:103; Q:79; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:16; Q:49; Act:2), //Reduce Rule; 
        (Tag:64; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState31: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:80; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState32: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:42; Act:2), //Reduce Rule; 
        (Tag:41; Q:42; Act:2), //Reduce Rule; 
        (Tag:42; Q:42; Act:2), //Reduce Rule; 
        (Tag:64; Q:42; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState33: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:47; Act:2), //Reduce Rule; 
        (Tag:41; Q:47; Act:2), //Reduce Rule; 
        (Tag:42; Q:47; Act:2), //Reduce Rule; 
        (Tag:64; Q:47; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState34: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:41; Act:2), //Reduce Rule; 
        (Tag:41; Q:41; Act:2), //Reduce Rule; 
        (Tag:42; Q:41; Act:2), //Reduce Rule; 
        (Tag:64; Q:41; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState35: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:44; Act:2), //Reduce Rule; 
        (Tag:41; Q:44; Act:2), //Reduce Rule; 
        (Tag:42; Q:44; Act:2), //Reduce Rule; 
        (Tag:64; Q:44; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState36: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:46; Act:2), //Reduce Rule; 
        (Tag:41; Q:46; Act:2), //Reduce Rule; 
        (Tag:42; Q:46; Act:2), //Reduce Rule; 
        (Tag:64; Q:46; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState37: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:43; Act:2), //Reduce Rule; 
        (Tag:41; Q:43; Act:2), //Reduce Rule; 
        (Tag:42; Q:43; Act:2), //Reduce Rule; 
        (Tag:64; Q:43; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState38: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:48; Act:2), //Reduce Rule; 
        (Tag:41; Q:48; Act:2), //Reduce Rule; 
        (Tag:42; Q:48; Act:2), //Reduce Rule; 
        (Tag:64; Q:48; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState39: packed array[0..3] of TParseEdge= (
        (Tag:16; Q:81; Act:1), //Shift; 
        (Tag:42; Q:39; Act:2), //Reduce Rule; 
        (Tag:64; Q:39; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState40: packed array[0..1] of TParseEdge= (
        (Tag:42; Q:82; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState41: packed array[0..4] of TParseEdge= (
        (Tag:11; Q:83; Act:1), //Shift; 
        (Tag:15; Q:84; Act:1), //Shift; 
        (Tag:17; Q:85; Act:1), //Shift; 
        (Tag:19; Q:86; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState42: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:45; Act:2), //Reduce Rule; 
        (Tag:41; Q:45; Act:2), //Reduce Rule; 
        (Tag:42; Q:45; Act:2), //Reduce Rule; 
        (Tag:64; Q:45; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState43: packed array[0..1] of TParseEdge= (
        (Tag:0; Q:5; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState44: packed array[0..2] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:92; Q:87; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState45: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:88; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState46: packed array[0..28] of TParseEdge= (
        (Tag:6; Q:4; Act:2), //Reduce Rule; 
        (Tag:8; Q:4; Act:2), //Reduce Rule; 
        (Tag:9; Q:4; Act:2), //Reduce Rule; 
        (Tag:10; Q:4; Act:2), //Reduce Rule; 
        (Tag:12; Q:4; Act:2), //Reduce Rule; 
        (Tag:13; Q:4; Act:2), //Reduce Rule; 
        (Tag:14; Q:4; Act:2), //Reduce Rule; 
        (Tag:16; Q:4; Act:2), //Reduce Rule; 
        (Tag:18; Q:4; Act:2), //Reduce Rule; 
        (Tag:20; Q:4; Act:2), //Reduce Rule; 
        (Tag:21; Q:4; Act:2), //Reduce Rule; 
        (Tag:22; Q:4; Act:2), //Reduce Rule; 
        (Tag:23; Q:4; Act:2), //Reduce Rule; 
        (Tag:24; Q:4; Act:2), //Reduce Rule; 
        (Tag:25; Q:4; Act:2), //Reduce Rule; 
        (Tag:26; Q:4; Act:2), //Reduce Rule; 
        (Tag:27; Q:4; Act:2), //Reduce Rule; 
        (Tag:38; Q:4; Act:2), //Reduce Rule; 
        (Tag:39; Q:4; Act:2), //Reduce Rule; 
        (Tag:40; Q:4; Act:2), //Reduce Rule; 
        (Tag:41; Q:4; Act:2), //Reduce Rule; 
        (Tag:42; Q:4; Act:2), //Reduce Rule; 
        (Tag:51; Q:4; Act:2), //Reduce Rule; 
        (Tag:53; Q:4; Act:2), //Reduce Rule; 
        (Tag:54; Q:4; Act:2), //Reduce Rule; 
        (Tag:61; Q:4; Act:2), //Reduce Rule; 
        (Tag:62; Q:4; Act:2), //Reduce Rule; 
        (Tag:64; Q:4; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState47: packed array[0..28] of TParseEdge= (
        (Tag:6; Q:0; Act:2), //Reduce Rule; 
        (Tag:8; Q:0; Act:2), //Reduce Rule; 
        (Tag:9; Q:0; Act:2), //Reduce Rule; 
        (Tag:10; Q:0; Act:2), //Reduce Rule; 
        (Tag:12; Q:0; Act:2), //Reduce Rule; 
        (Tag:13; Q:0; Act:2), //Reduce Rule; 
        (Tag:14; Q:0; Act:2), //Reduce Rule; 
        (Tag:16; Q:0; Act:2), //Reduce Rule; 
        (Tag:18; Q:0; Act:2), //Reduce Rule; 
        (Tag:20; Q:0; Act:2), //Reduce Rule; 
        (Tag:21; Q:0; Act:2), //Reduce Rule; 
        (Tag:22; Q:0; Act:2), //Reduce Rule; 
        (Tag:23; Q:0; Act:2), //Reduce Rule; 
        (Tag:24; Q:0; Act:2), //Reduce Rule; 
        (Tag:25; Q:0; Act:2), //Reduce Rule; 
        (Tag:26; Q:0; Act:2), //Reduce Rule; 
        (Tag:27; Q:0; Act:2), //Reduce Rule; 
        (Tag:38; Q:0; Act:2), //Reduce Rule; 
        (Tag:39; Q:0; Act:2), //Reduce Rule; 
        (Tag:40; Q:0; Act:2), //Reduce Rule; 
        (Tag:41; Q:0; Act:2), //Reduce Rule; 
        (Tag:42; Q:0; Act:2), //Reduce Rule; 
        (Tag:51; Q:0; Act:2), //Reduce Rule; 
        (Tag:53; Q:0; Act:2), //Reduce Rule; 
        (Tag:54; Q:0; Act:2), //Reduce Rule; 
        (Tag:61; Q:0; Act:2), //Reduce Rule; 
        (Tag:62; Q:0; Act:2), //Reduce Rule; 
        (Tag:64; Q:0; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState48: packed array[0..28] of TParseEdge= (
        (Tag:6; Q:2; Act:2), //Reduce Rule; 
        (Tag:8; Q:2; Act:2), //Reduce Rule; 
        (Tag:9; Q:2; Act:2), //Reduce Rule; 
        (Tag:10; Q:2; Act:2), //Reduce Rule; 
        (Tag:12; Q:2; Act:2), //Reduce Rule; 
        (Tag:13; Q:2; Act:2), //Reduce Rule; 
        (Tag:14; Q:2; Act:2), //Reduce Rule; 
        (Tag:16; Q:2; Act:2), //Reduce Rule; 
        (Tag:18; Q:2; Act:2), //Reduce Rule; 
        (Tag:20; Q:2; Act:2), //Reduce Rule; 
        (Tag:21; Q:2; Act:2), //Reduce Rule; 
        (Tag:22; Q:2; Act:2), //Reduce Rule; 
        (Tag:23; Q:2; Act:2), //Reduce Rule; 
        (Tag:24; Q:2; Act:2), //Reduce Rule; 
        (Tag:25; Q:2; Act:2), //Reduce Rule; 
        (Tag:26; Q:2; Act:2), //Reduce Rule; 
        (Tag:27; Q:2; Act:2), //Reduce Rule; 
        (Tag:38; Q:2; Act:2), //Reduce Rule; 
        (Tag:39; Q:2; Act:2), //Reduce Rule; 
        (Tag:40; Q:2; Act:2), //Reduce Rule; 
        (Tag:41; Q:2; Act:2), //Reduce Rule; 
        (Tag:42; Q:2; Act:2), //Reduce Rule; 
        (Tag:51; Q:2; Act:2), //Reduce Rule; 
        (Tag:53; Q:2; Act:2), //Reduce Rule; 
        (Tag:54; Q:2; Act:2), //Reduce Rule; 
        (Tag:61; Q:2; Act:2), //Reduce Rule; 
        (Tag:62; Q:2; Act:2), //Reduce Rule; 
        (Tag:64; Q:2; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState49: packed array[0..28] of TParseEdge= (
        (Tag:6; Q:3; Act:2), //Reduce Rule; 
        (Tag:8; Q:3; Act:2), //Reduce Rule; 
        (Tag:9; Q:3; Act:2), //Reduce Rule; 
        (Tag:10; Q:3; Act:2), //Reduce Rule; 
        (Tag:12; Q:3; Act:2), //Reduce Rule; 
        (Tag:13; Q:3; Act:2), //Reduce Rule; 
        (Tag:14; Q:3; Act:2), //Reduce Rule; 
        (Tag:16; Q:3; Act:2), //Reduce Rule; 
        (Tag:18; Q:3; Act:2), //Reduce Rule; 
        (Tag:20; Q:3; Act:2), //Reduce Rule; 
        (Tag:21; Q:3; Act:2), //Reduce Rule; 
        (Tag:22; Q:3; Act:2), //Reduce Rule; 
        (Tag:23; Q:3; Act:2), //Reduce Rule; 
        (Tag:24; Q:3; Act:2), //Reduce Rule; 
        (Tag:25; Q:3; Act:2), //Reduce Rule; 
        (Tag:26; Q:3; Act:2), //Reduce Rule; 
        (Tag:27; Q:3; Act:2), //Reduce Rule; 
        (Tag:38; Q:3; Act:2), //Reduce Rule; 
        (Tag:39; Q:3; Act:2), //Reduce Rule; 
        (Tag:40; Q:3; Act:2), //Reduce Rule; 
        (Tag:41; Q:3; Act:2), //Reduce Rule; 
        (Tag:42; Q:3; Act:2), //Reduce Rule; 
        (Tag:51; Q:3; Act:2), //Reduce Rule; 
        (Tag:53; Q:3; Act:2), //Reduce Rule; 
        (Tag:54; Q:3; Act:2), //Reduce Rule; 
        (Tag:61; Q:3; Act:2), //Reduce Rule; 
        (Tag:62; Q:3; Act:2), //Reduce Rule; 
        (Tag:64; Q:3; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState50: packed array[0..28] of TParseEdge= (
        (Tag:6; Q:1; Act:2), //Reduce Rule; 
        (Tag:8; Q:1; Act:2), //Reduce Rule; 
        (Tag:9; Q:1; Act:2), //Reduce Rule; 
        (Tag:10; Q:1; Act:2), //Reduce Rule; 
        (Tag:12; Q:1; Act:2), //Reduce Rule; 
        (Tag:13; Q:1; Act:2), //Reduce Rule; 
        (Tag:14; Q:1; Act:2), //Reduce Rule; 
        (Tag:16; Q:1; Act:2), //Reduce Rule; 
        (Tag:18; Q:1; Act:2), //Reduce Rule; 
        (Tag:20; Q:1; Act:2), //Reduce Rule; 
        (Tag:21; Q:1; Act:2), //Reduce Rule; 
        (Tag:22; Q:1; Act:2), //Reduce Rule; 
        (Tag:23; Q:1; Act:2), //Reduce Rule; 
        (Tag:24; Q:1; Act:2), //Reduce Rule; 
        (Tag:25; Q:1; Act:2), //Reduce Rule; 
        (Tag:26; Q:1; Act:2), //Reduce Rule; 
        (Tag:27; Q:1; Act:2), //Reduce Rule; 
        (Tag:38; Q:1; Act:2), //Reduce Rule; 
        (Tag:39; Q:1; Act:2), //Reduce Rule; 
        (Tag:40; Q:1; Act:2), //Reduce Rule; 
        (Tag:41; Q:1; Act:2), //Reduce Rule; 
        (Tag:42; Q:1; Act:2), //Reduce Rule; 
        (Tag:51; Q:1; Act:2), //Reduce Rule; 
        (Tag:53; Q:1; Act:2), //Reduce Rule; 
        (Tag:54; Q:1; Act:2), //Reduce Rule; 
        (Tag:61; Q:1; Act:2), //Reduce Rule; 
        (Tag:62; Q:1; Act:2), //Reduce Rule; 
        (Tag:64; Q:1; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState51: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:89; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState52: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:97; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState53: packed array[0..4] of TParseEdge= (
        (Tag:29; Q:17; Act:2), //Reduce Rule; 
        (Tag:47; Q:17; Act:2), //Reduce Rule; 
        (Tag:55; Q:17; Act:2), //Reduce Rule; 
        (Tag:65; Q:17; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState54: packed array[0..1] of TParseEdge= (
        (Tag:14; Q:98; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState55: packed array[0..7] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:92; Q:54; Act:3), //Goto; 
        (Tag:110; Q:55; Act:3), //Goto; 
        (Tag:111; Q:99; Act:3), //Goto; 
        (Tag:29; Q:21; Act:2), //Reduce Rule; 
        (Tag:47; Q:21; Act:2), //Reduce Rule; 
        (Tag:55; Q:21; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState56: packed array[0..3] of TParseEdge= (
        (Tag:29; Q:19; Act:2), //Reduce Rule; 
        (Tag:47; Q:19; Act:2), //Reduce Rule; 
        (Tag:55; Q:19; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState57: packed array[0..1] of TParseEdge= (
        (Tag:49; Q:100; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState58: packed array[0..1] of TParseEdge= (
        (Tag:49; Q:101; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState59: packed array[0..9] of TParseEdge= (
        (Tag:36; Q:5; Act:1), //Shift; 
        (Tag:46; Q:102; Act:1), //Shift; 
        (Tag:79; Q:6; Act:3), //Goto; 
        (Tag:81; Q:103; Act:3), //Goto; 
        (Tag:29; Q:10; Act:2), //Reduce Rule; 
        (Tag:47; Q:10; Act:2), //Reduce Rule; 
        (Tag:55; Q:10; Act:2), //Reduce Rule; 
        (Tag:63; Q:10; Act:2), //Reduce Rule; 
        (Tag:65; Q:10; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState60: packed array[0..7] of TParseEdge= (
        (Tag:47; Q:57; Act:1), //Shift; 
        (Tag:55; Q:58; Act:1), //Shift; 
        (Tag:91; Q:59; Act:3), //Goto; 
        (Tag:95; Q:60; Act:3), //Goto; 
        (Tag:96; Q:104; Act:3), //Goto; 
        (Tag:97; Q:62; Act:3), //Goto; 
        (Tag:29; Q:25; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState61: packed array[0..1] of TParseEdge= (
        (Tag:29; Q:8; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState62: packed array[0..9] of TParseEdge= (
        (Tag:36; Q:5; Act:1), //Shift; 
        (Tag:46; Q:105; Act:1), //Shift; 
        (Tag:79; Q:6; Act:3), //Goto; 
        (Tag:81; Q:106; Act:3), //Goto; 
        (Tag:29; Q:10; Act:2), //Reduce Rule; 
        (Tag:47; Q:10; Act:2), //Reduce Rule; 
        (Tag:55; Q:10; Act:2), //Reduce Rule; 
        (Tag:63; Q:10; Act:2), //Reduce Rule; 
        (Tag:65; Q:10; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState63: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:107; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState64: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:108; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState65: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:109; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState66: packed array[0..30] of TParseEdge= (
        (Tag:7; Q:110; Act:1), //Shift; 
        (Tag:6; Q:92; Act:2), //Reduce Rule; 
        (Tag:8; Q:92; Act:2), //Reduce Rule; 
        (Tag:9; Q:92; Act:2), //Reduce Rule; 
        (Tag:10; Q:92; Act:2), //Reduce Rule; 
        (Tag:11; Q:92; Act:2), //Reduce Rule; 
        (Tag:13; Q:92; Act:2), //Reduce Rule; 
        (Tag:16; Q:92; Act:2), //Reduce Rule; 
        (Tag:17; Q:92; Act:2), //Reduce Rule; 
        (Tag:18; Q:92; Act:2), //Reduce Rule; 
        (Tag:19; Q:92; Act:2), //Reduce Rule; 
        (Tag:20; Q:92; Act:2), //Reduce Rule; 
        (Tag:21; Q:92; Act:2), //Reduce Rule; 
        (Tag:22; Q:92; Act:2), //Reduce Rule; 
        (Tag:23; Q:92; Act:2), //Reduce Rule; 
        (Tag:24; Q:92; Act:2), //Reduce Rule; 
        (Tag:25; Q:92; Act:2), //Reduce Rule; 
        (Tag:26; Q:92; Act:2), //Reduce Rule; 
        (Tag:27; Q:92; Act:2), //Reduce Rule; 
        (Tag:38; Q:92; Act:2), //Reduce Rule; 
        (Tag:39; Q:92; Act:2), //Reduce Rule; 
        (Tag:40; Q:92; Act:2), //Reduce Rule; 
        (Tag:41; Q:92; Act:2), //Reduce Rule; 
        (Tag:42; Q:92; Act:2), //Reduce Rule; 
        (Tag:51; Q:92; Act:2), //Reduce Rule; 
        (Tag:53; Q:92; Act:2), //Reduce Rule; 
        (Tag:54; Q:92; Act:2), //Reduce Rule; 
        (Tag:61; Q:92; Act:2), //Reduce Rule; 
        (Tag:62; Q:92; Act:2), //Reduce Rule; 
        (Tag:64; Q:92; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState67: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:111; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState68: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:84; Act:2), //Reduce Rule; 
        (Tag:8; Q:84; Act:2), //Reduce Rule; 
        (Tag:9; Q:84; Act:2), //Reduce Rule; 
        (Tag:10; Q:84; Act:2), //Reduce Rule; 
        (Tag:13; Q:84; Act:2), //Reduce Rule; 
        (Tag:16; Q:84; Act:2), //Reduce Rule; 
        (Tag:18; Q:84; Act:2), //Reduce Rule; 
        (Tag:20; Q:84; Act:2), //Reduce Rule; 
        (Tag:21; Q:84; Act:2), //Reduce Rule; 
        (Tag:22; Q:84; Act:2), //Reduce Rule; 
        (Tag:23; Q:84; Act:2), //Reduce Rule; 
        (Tag:24; Q:84; Act:2), //Reduce Rule; 
        (Tag:25; Q:84; Act:2), //Reduce Rule; 
        (Tag:26; Q:84; Act:2), //Reduce Rule; 
        (Tag:27; Q:84; Act:2), //Reduce Rule; 
        (Tag:38; Q:84; Act:2), //Reduce Rule; 
        (Tag:39; Q:84; Act:2), //Reduce Rule; 
        (Tag:40; Q:84; Act:2), //Reduce Rule; 
        (Tag:41; Q:84; Act:2), //Reduce Rule; 
        (Tag:42; Q:84; Act:2), //Reduce Rule; 
        (Tag:51; Q:84; Act:2), //Reduce Rule; 
        (Tag:53; Q:84; Act:2), //Reduce Rule; 
        (Tag:54; Q:84; Act:2), //Reduce Rule; 
        (Tag:61; Q:84; Act:2), //Reduce Rule; 
        (Tag:62; Q:84; Act:2), //Reduce Rule; 
        (Tag:64; Q:84; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState69: packed array[0..1] of TParseEdge= (
        (Tag:53; Q:112; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState70: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:74; Act:2), //Reduce Rule; 
        (Tag:8; Q:74; Act:2), //Reduce Rule; 
        (Tag:9; Q:74; Act:2), //Reduce Rule; 
        (Tag:10; Q:74; Act:2), //Reduce Rule; 
        (Tag:13; Q:74; Act:2), //Reduce Rule; 
        (Tag:16; Q:74; Act:2), //Reduce Rule; 
        (Tag:18; Q:74; Act:2), //Reduce Rule; 
        (Tag:20; Q:74; Act:2), //Reduce Rule; 
        (Tag:21; Q:74; Act:2), //Reduce Rule; 
        (Tag:22; Q:74; Act:2), //Reduce Rule; 
        (Tag:23; Q:74; Act:2), //Reduce Rule; 
        (Tag:24; Q:74; Act:2), //Reduce Rule; 
        (Tag:25; Q:74; Act:2), //Reduce Rule; 
        (Tag:26; Q:74; Act:2), //Reduce Rule; 
        (Tag:27; Q:74; Act:2), //Reduce Rule; 
        (Tag:38; Q:74; Act:2), //Reduce Rule; 
        (Tag:39; Q:74; Act:2), //Reduce Rule; 
        (Tag:40; Q:74; Act:2), //Reduce Rule; 
        (Tag:41; Q:74; Act:2), //Reduce Rule; 
        (Tag:42; Q:74; Act:2), //Reduce Rule; 
        (Tag:51; Q:74; Act:2), //Reduce Rule; 
        (Tag:53; Q:74; Act:2), //Reduce Rule; 
        (Tag:54; Q:74; Act:2), //Reduce Rule; 
        (Tag:61; Q:74; Act:2), //Reduce Rule; 
        (Tag:62; Q:74; Act:2), //Reduce Rule; 
        (Tag:64; Q:74; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState71: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:86; Act:2), //Reduce Rule; 
        (Tag:8; Q:86; Act:2), //Reduce Rule; 
        (Tag:9; Q:86; Act:2), //Reduce Rule; 
        (Tag:10; Q:86; Act:2), //Reduce Rule; 
        (Tag:13; Q:86; Act:2), //Reduce Rule; 
        (Tag:16; Q:86; Act:2), //Reduce Rule; 
        (Tag:18; Q:86; Act:2), //Reduce Rule; 
        (Tag:20; Q:86; Act:2), //Reduce Rule; 
        (Tag:21; Q:86; Act:2), //Reduce Rule; 
        (Tag:22; Q:86; Act:2), //Reduce Rule; 
        (Tag:23; Q:86; Act:2), //Reduce Rule; 
        (Tag:24; Q:86; Act:2), //Reduce Rule; 
        (Tag:25; Q:86; Act:2), //Reduce Rule; 
        (Tag:26; Q:86; Act:2), //Reduce Rule; 
        (Tag:27; Q:86; Act:2), //Reduce Rule; 
        (Tag:38; Q:86; Act:2), //Reduce Rule; 
        (Tag:39; Q:86; Act:2), //Reduce Rule; 
        (Tag:40; Q:86; Act:2), //Reduce Rule; 
        (Tag:41; Q:86; Act:2), //Reduce Rule; 
        (Tag:42; Q:86; Act:2), //Reduce Rule; 
        (Tag:51; Q:86; Act:2), //Reduce Rule; 
        (Tag:53; Q:86; Act:2), //Reduce Rule; 
        (Tag:54; Q:86; Act:2), //Reduce Rule; 
        (Tag:61; Q:86; Act:2), //Reduce Rule; 
        (Tag:62; Q:86; Act:2), //Reduce Rule; 
        (Tag:64; Q:86; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState72: packed array[0..21] of TParseEdge= (
        (Tag:6; Q:113; Act:1), //Shift; 
        (Tag:20; Q:114; Act:1), //Shift; 
        (Tag:21; Q:115; Act:1), //Shift; 
        (Tag:22; Q:116; Act:1), //Shift; 
        (Tag:23; Q:117; Act:1), //Shift; 
        (Tag:24; Q:118; Act:1), //Shift; 
        (Tag:25; Q:119; Act:1), //Shift; 
        (Tag:26; Q:120; Act:1), //Shift; 
        (Tag:54; Q:121; Act:1), //Shift; 
        (Tag:8; Q:63; Act:2), //Reduce Rule; 
        (Tag:10; Q:63; Act:2), //Reduce Rule; 
        (Tag:16; Q:63; Act:2), //Reduce Rule; 
        (Tag:18; Q:63; Act:2), //Reduce Rule; 
        (Tag:39; Q:63; Act:2), //Reduce Rule; 
        (Tag:40; Q:63; Act:2), //Reduce Rule; 
        (Tag:41; Q:63; Act:2), //Reduce Rule; 
        (Tag:42; Q:63; Act:2), //Reduce Rule; 
        (Tag:53; Q:63; Act:2), //Reduce Rule; 
        (Tag:61; Q:63; Act:2), //Reduce Rule; 
        (Tag:62; Q:63; Act:2), //Reduce Rule; 
        (Tag:64; Q:63; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState73: packed array[0..26] of TParseEdge= (
        (Tag:9; Q:122; Act:1), //Shift; 
        (Tag:13; Q:123; Act:1), //Shift; 
        (Tag:27; Q:124; Act:1), //Shift; 
        (Tag:38; Q:125; Act:1), //Shift; 
        (Tag:51; Q:126; Act:1), //Shift; 
        (Tag:6; Q:70; Act:2), //Reduce Rule; 
        (Tag:8; Q:70; Act:2), //Reduce Rule; 
        (Tag:10; Q:70; Act:2), //Reduce Rule; 
        (Tag:16; Q:70; Act:2), //Reduce Rule; 
        (Tag:18; Q:70; Act:2), //Reduce Rule; 
        (Tag:20; Q:70; Act:2), //Reduce Rule; 
        (Tag:21; Q:70; Act:2), //Reduce Rule; 
        (Tag:22; Q:70; Act:2), //Reduce Rule; 
        (Tag:23; Q:70; Act:2), //Reduce Rule; 
        (Tag:24; Q:70; Act:2), //Reduce Rule; 
        (Tag:25; Q:70; Act:2), //Reduce Rule; 
        (Tag:26; Q:70; Act:2), //Reduce Rule; 
        (Tag:39; Q:70; Act:2), //Reduce Rule; 
        (Tag:40; Q:70; Act:2), //Reduce Rule; 
        (Tag:41; Q:70; Act:2), //Reduce Rule; 
        (Tag:42; Q:70; Act:2), //Reduce Rule; 
        (Tag:53; Q:70; Act:2), //Reduce Rule; 
        (Tag:54; Q:70; Act:2), //Reduce Rule; 
        (Tag:61; Q:70; Act:2), //Reduce Rule; 
        (Tag:62; Q:70; Act:2), //Reduce Rule; 
        (Tag:64; Q:70; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState74: packed array[0..29] of TParseEdge= (
        (Tag:11; Q:83; Act:1), //Shift; 
        (Tag:17; Q:85; Act:1), //Shift; 
        (Tag:19; Q:86; Act:1), //Shift; 
        (Tag:6; Q:85; Act:2), //Reduce Rule; 
        (Tag:8; Q:85; Act:2), //Reduce Rule; 
        (Tag:9; Q:85; Act:2), //Reduce Rule; 
        (Tag:10; Q:85; Act:2), //Reduce Rule; 
        (Tag:13; Q:85; Act:2), //Reduce Rule; 
        (Tag:16; Q:85; Act:2), //Reduce Rule; 
        (Tag:18; Q:85; Act:2), //Reduce Rule; 
        (Tag:20; Q:85; Act:2), //Reduce Rule; 
        (Tag:21; Q:85; Act:2), //Reduce Rule; 
        (Tag:22; Q:85; Act:2), //Reduce Rule; 
        (Tag:23; Q:85; Act:2), //Reduce Rule; 
        (Tag:24; Q:85; Act:2), //Reduce Rule; 
        (Tag:25; Q:85; Act:2), //Reduce Rule; 
        (Tag:26; Q:85; Act:2), //Reduce Rule; 
        (Tag:27; Q:85; Act:2), //Reduce Rule; 
        (Tag:38; Q:85; Act:2), //Reduce Rule; 
        (Tag:39; Q:85; Act:2), //Reduce Rule; 
        (Tag:40; Q:85; Act:2), //Reduce Rule; 
        (Tag:41; Q:85; Act:2), //Reduce Rule; 
        (Tag:42; Q:85; Act:2), //Reduce Rule; 
        (Tag:51; Q:85; Act:2), //Reduce Rule; 
        (Tag:53; Q:85; Act:2), //Reduce Rule; 
        (Tag:54; Q:85; Act:2), //Reduce Rule; 
        (Tag:61; Q:85; Act:2), //Reduce Rule; 
        (Tag:62; Q:85; Act:2), //Reduce Rule; 
        (Tag:64; Q:85; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState75: packed array[0..1] of TParseEdge= (
        (Tag:15; Q:127; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState76: packed array[0..18] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:128; Act:3), //Goto; 
        (Tag:85; Q:129; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState77: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:51; Act:2), //Reduce Rule; 
        (Tag:41; Q:51; Act:2), //Reduce Rule; 
        (Tag:42; Q:51; Act:2), //Reduce Rule; 
        (Tag:64; Q:51; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState78: packed array[0..1] of TParseEdge= (
        (Tag:61; Q:130; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState79: packed array[0..1] of TParseEdge= (
        (Tag:64; Q:131; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState80: packed array[0..1] of TParseEdge= (
        (Tag:39; Q:132; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState81: packed array[0..21] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:39; Act:3), //Goto; 
        (Tag:103; Q:133; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:16; Q:49; Act:2), //Reduce Rule; 
        (Tag:42; Q:49; Act:2), //Reduce Rule; 
        (Tag:64; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState82: packed array[0..5] of TParseEdge= (
        (Tag:11; Q:38; Act:2), //Reduce Rule; 
        (Tag:16; Q:38; Act:2), //Reduce Rule; 
        (Tag:41; Q:38; Act:2), //Reduce Rule; 
        (Tag:42; Q:38; Act:2), //Reduce Rule; 
        (Tag:64; Q:38; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState83: packed array[0..1] of TParseEdge= (
        (Tag:49; Q:134; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState84: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:135; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState85: packed array[0..18] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:128; Act:3), //Goto; 
        (Tag:85; Q:136; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState86: packed array[0..30] of TParseEdge= (
        (Tag:6; Q:94; Act:2), //Reduce Rule; 
        (Tag:8; Q:94; Act:2), //Reduce Rule; 
        (Tag:9; Q:94; Act:2), //Reduce Rule; 
        (Tag:10; Q:94; Act:2), //Reduce Rule; 
        (Tag:11; Q:94; Act:2), //Reduce Rule; 
        (Tag:13; Q:94; Act:2), //Reduce Rule; 
        (Tag:15; Q:94; Act:2), //Reduce Rule; 
        (Tag:16; Q:94; Act:2), //Reduce Rule; 
        (Tag:17; Q:94; Act:2), //Reduce Rule; 
        (Tag:18; Q:94; Act:2), //Reduce Rule; 
        (Tag:19; Q:94; Act:2), //Reduce Rule; 
        (Tag:20; Q:94; Act:2), //Reduce Rule; 
        (Tag:21; Q:94; Act:2), //Reduce Rule; 
        (Tag:22; Q:94; Act:2), //Reduce Rule; 
        (Tag:23; Q:94; Act:2), //Reduce Rule; 
        (Tag:24; Q:94; Act:2), //Reduce Rule; 
        (Tag:25; Q:94; Act:2), //Reduce Rule; 
        (Tag:26; Q:94; Act:2), //Reduce Rule; 
        (Tag:27; Q:94; Act:2), //Reduce Rule; 
        (Tag:38; Q:94; Act:2), //Reduce Rule; 
        (Tag:39; Q:94; Act:2), //Reduce Rule; 
        (Tag:40; Q:94; Act:2), //Reduce Rule; 
        (Tag:41; Q:94; Act:2), //Reduce Rule; 
        (Tag:42; Q:94; Act:2), //Reduce Rule; 
        (Tag:51; Q:94; Act:2), //Reduce Rule; 
        (Tag:53; Q:94; Act:2), //Reduce Rule; 
        (Tag:54; Q:94; Act:2), //Reduce Rule; 
        (Tag:61; Q:94; Act:2), //Reduce Rule; 
        (Tag:62; Q:94; Act:2), //Reduce Rule; 
        (Tag:64; Q:94; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState87: packed array[0..2] of TParseEdge= (
        (Tag:8; Q:111; Act:2), //Reduce Rule; 
        (Tag:14; Q:111; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState88: packed array[0..6] of TParseEdge= (
        (Tag:29; Q:7; Act:2), //Reduce Rule; 
        (Tag:36; Q:7; Act:2), //Reduce Rule; 
        (Tag:47; Q:7; Act:2), //Reduce Rule; 
        (Tag:55; Q:7; Act:2), //Reduce Rule; 
        (Tag:63; Q:7; Act:2), //Reduce Rule; 
        (Tag:65; Q:7; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState89: packed array[0..6] of TParseEdge= (
        (Tag:29; Q:13; Act:2), //Reduce Rule; 
        (Tag:47; Q:13; Act:2), //Reduce Rule; 
        (Tag:49; Q:13; Act:2), //Reduce Rule; 
        (Tag:55; Q:13; Act:2), //Reduce Rule; 
        (Tag:63; Q:13; Act:2), //Reduce Rule; 
        (Tag:65; Q:13; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState90: packed array[0..2] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:92; Q:137; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState91: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:138; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState92: packed array[0..1] of TParseEdge= (
        (Tag:17; Q:139; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState93: packed array[0..1] of TParseEdge= (
        (Tag:53; Q:140; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState94: packed array[0..3] of TParseEdge= (
        (Tag:8; Q:96; Act:2), //Reduce Rule; 
        (Tag:16; Q:96; Act:2), //Reduce Rule; 
        (Tag:42; Q:96; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState95: packed array[0..4] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:87; Q:141; Act:3), //Goto; 
        (Tag:88; Q:142; Act:3), //Goto; 
        (Tag:92; Q:143; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState96: packed array[0..1] of TParseEdge= (
        (Tag:12; Q:144; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState97: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:145; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState98: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:146; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState99: packed array[0..3] of TParseEdge= (
        (Tag:29; Q:22; Act:2), //Reduce Rule; 
        (Tag:47; Q:22; Act:2), //Reduce Rule; 
        (Tag:55; Q:22; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState100: packed array[0..3] of TParseEdge= (
        (Tag:7; Q:147; Act:1), //Shift; 
        (Tag:70; Q:148; Act:3), //Goto; 
        (Tag:14; Q:33; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState101: packed array[0..3] of TParseEdge= (
        (Tag:7; Q:147; Act:1), //Shift; 
        (Tag:70; Q:149; Act:3), //Goto; 
        (Tag:16; Q:33; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState102: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:150; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState103: packed array[0..2] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:75; Q:151; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState104: packed array[0..1] of TParseEdge= (
        (Tag:29; Q:24; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState105: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:152; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState106: packed array[0..2] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:75; Q:153; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState107: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:82; Act:2), //Reduce Rule; 
        (Tag:8; Q:82; Act:2), //Reduce Rule; 
        (Tag:9; Q:82; Act:2), //Reduce Rule; 
        (Tag:10; Q:82; Act:2), //Reduce Rule; 
        (Tag:13; Q:82; Act:2), //Reduce Rule; 
        (Tag:16; Q:82; Act:2), //Reduce Rule; 
        (Tag:18; Q:82; Act:2), //Reduce Rule; 
        (Tag:20; Q:82; Act:2), //Reduce Rule; 
        (Tag:21; Q:82; Act:2), //Reduce Rule; 
        (Tag:22; Q:82; Act:2), //Reduce Rule; 
        (Tag:23; Q:82; Act:2), //Reduce Rule; 
        (Tag:24; Q:82; Act:2), //Reduce Rule; 
        (Tag:25; Q:82; Act:2), //Reduce Rule; 
        (Tag:26; Q:82; Act:2), //Reduce Rule; 
        (Tag:27; Q:82; Act:2), //Reduce Rule; 
        (Tag:38; Q:82; Act:2), //Reduce Rule; 
        (Tag:39; Q:82; Act:2), //Reduce Rule; 
        (Tag:40; Q:82; Act:2), //Reduce Rule; 
        (Tag:41; Q:82; Act:2), //Reduce Rule; 
        (Tag:42; Q:82; Act:2), //Reduce Rule; 
        (Tag:51; Q:82; Act:2), //Reduce Rule; 
        (Tag:53; Q:82; Act:2), //Reduce Rule; 
        (Tag:54; Q:82; Act:2), //Reduce Rule; 
        (Tag:61; Q:82; Act:2), //Reduce Rule; 
        (Tag:62; Q:82; Act:2), //Reduce Rule; 
        (Tag:64; Q:82; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState108: packed array[0..1] of TParseEdge= (
        (Tag:8; Q:154; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState109: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:81; Act:2), //Reduce Rule; 
        (Tag:8; Q:81; Act:2), //Reduce Rule; 
        (Tag:9; Q:81; Act:2), //Reduce Rule; 
        (Tag:10; Q:81; Act:2), //Reduce Rule; 
        (Tag:13; Q:81; Act:2), //Reduce Rule; 
        (Tag:16; Q:81; Act:2), //Reduce Rule; 
        (Tag:18; Q:81; Act:2), //Reduce Rule; 
        (Tag:20; Q:81; Act:2), //Reduce Rule; 
        (Tag:21; Q:81; Act:2), //Reduce Rule; 
        (Tag:22; Q:81; Act:2), //Reduce Rule; 
        (Tag:23; Q:81; Act:2), //Reduce Rule; 
        (Tag:24; Q:81; Act:2), //Reduce Rule; 
        (Tag:25; Q:81; Act:2), //Reduce Rule; 
        (Tag:26; Q:81; Act:2), //Reduce Rule; 
        (Tag:27; Q:81; Act:2), //Reduce Rule; 
        (Tag:38; Q:81; Act:2), //Reduce Rule; 
        (Tag:39; Q:81; Act:2), //Reduce Rule; 
        (Tag:40; Q:81; Act:2), //Reduce Rule; 
        (Tag:41; Q:81; Act:2), //Reduce Rule; 
        (Tag:42; Q:81; Act:2), //Reduce Rule; 
        (Tag:51; Q:81; Act:2), //Reduce Rule; 
        (Tag:53; Q:81; Act:2), //Reduce Rule; 
        (Tag:54; Q:81; Act:2), //Reduce Rule; 
        (Tag:61; Q:81; Act:2), //Reduce Rule; 
        (Tag:62; Q:81; Act:2), //Reduce Rule; 
        (Tag:64; Q:81; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState110: packed array[0..18] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:128; Act:3), //Goto; 
        (Tag:85; Q:155; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState111: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:83; Act:2), //Reduce Rule; 
        (Tag:8; Q:83; Act:2), //Reduce Rule; 
        (Tag:9; Q:83; Act:2), //Reduce Rule; 
        (Tag:10; Q:83; Act:2), //Reduce Rule; 
        (Tag:13; Q:83; Act:2), //Reduce Rule; 
        (Tag:16; Q:83; Act:2), //Reduce Rule; 
        (Tag:18; Q:83; Act:2), //Reduce Rule; 
        (Tag:20; Q:83; Act:2), //Reduce Rule; 
        (Tag:21; Q:83; Act:2), //Reduce Rule; 
        (Tag:22; Q:83; Act:2), //Reduce Rule; 
        (Tag:23; Q:83; Act:2), //Reduce Rule; 
        (Tag:24; Q:83; Act:2), //Reduce Rule; 
        (Tag:25; Q:83; Act:2), //Reduce Rule; 
        (Tag:26; Q:83; Act:2), //Reduce Rule; 
        (Tag:27; Q:83; Act:2), //Reduce Rule; 
        (Tag:38; Q:83; Act:2), //Reduce Rule; 
        (Tag:39; Q:83; Act:2), //Reduce Rule; 
        (Tag:40; Q:83; Act:2), //Reduce Rule; 
        (Tag:41; Q:83; Act:2), //Reduce Rule; 
        (Tag:42; Q:83; Act:2), //Reduce Rule; 
        (Tag:51; Q:83; Act:2), //Reduce Rule; 
        (Tag:53; Q:83; Act:2), //Reduce Rule; 
        (Tag:54; Q:83; Act:2), //Reduce Rule; 
        (Tag:61; Q:83; Act:2), //Reduce Rule; 
        (Tag:62; Q:83; Act:2), //Reduce Rule; 
        (Tag:64; Q:83; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState112: packed array[0..9] of TParseEdge= (
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:72; Q:156; Act:3), //Goto; 
        (Tag:73; Q:157; Act:3), //Goto; 
        (Tag:76; Q:158; Act:3), //Goto; 
        (Tag:80; Q:159; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState113: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:104; Q:160; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState114: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:104; Q:161; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState115: packed array[0..16] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:162; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState116: packed array[0..16] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:163; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState117: packed array[0..16] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:164; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState118: packed array[0..16] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:165; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState119: packed array[0..16] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:166; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState120: packed array[0..16] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:167; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState121: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:104; Q:168; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState122: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:169; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState123: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:170; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState124: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:171; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState125: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:172; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState126: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:86; Q:173; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState127: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:174; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState128: packed array[0..3] of TParseEdge= (
        (Tag:10; Q:175; Act:1), //Shift; 
        (Tag:8; Q:90; Act:2), //Reduce Rule; 
        (Tag:18; Q:90; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState129: packed array[0..1] of TParseEdge= (
        (Tag:8; Q:176; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState130: packed array[0..18] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:177; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:41; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState131: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:178; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState132: packed array[0..21] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:179; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:16; Q:49; Act:2), //Reduce Rule; 
        (Tag:41; Q:49; Act:2), //Reduce Rule; 
        (Tag:42; Q:49; Act:2), //Reduce Rule; 
        (Tag:64; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState133: packed array[0..2] of TParseEdge= (
        (Tag:42; Q:40; Act:2), //Reduce Rule; 
        (Tag:64; Q:40; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState134: packed array[0..30] of TParseEdge= (
        (Tag:6; Q:93; Act:2), //Reduce Rule; 
        (Tag:8; Q:93; Act:2), //Reduce Rule; 
        (Tag:9; Q:93; Act:2), //Reduce Rule; 
        (Tag:10; Q:93; Act:2), //Reduce Rule; 
        (Tag:11; Q:93; Act:2), //Reduce Rule; 
        (Tag:13; Q:93; Act:2), //Reduce Rule; 
        (Tag:15; Q:93; Act:2), //Reduce Rule; 
        (Tag:16; Q:93; Act:2), //Reduce Rule; 
        (Tag:17; Q:93; Act:2), //Reduce Rule; 
        (Tag:18; Q:93; Act:2), //Reduce Rule; 
        (Tag:19; Q:93; Act:2), //Reduce Rule; 
        (Tag:20; Q:93; Act:2), //Reduce Rule; 
        (Tag:21; Q:93; Act:2), //Reduce Rule; 
        (Tag:22; Q:93; Act:2), //Reduce Rule; 
        (Tag:23; Q:93; Act:2), //Reduce Rule; 
        (Tag:24; Q:93; Act:2), //Reduce Rule; 
        (Tag:25; Q:93; Act:2), //Reduce Rule; 
        (Tag:26; Q:93; Act:2), //Reduce Rule; 
        (Tag:27; Q:93; Act:2), //Reduce Rule; 
        (Tag:38; Q:93; Act:2), //Reduce Rule; 
        (Tag:39; Q:93; Act:2), //Reduce Rule; 
        (Tag:40; Q:93; Act:2), //Reduce Rule; 
        (Tag:41; Q:93; Act:2), //Reduce Rule; 
        (Tag:42; Q:93; Act:2), //Reduce Rule; 
        (Tag:51; Q:93; Act:2), //Reduce Rule; 
        (Tag:53; Q:93; Act:2), //Reduce Rule; 
        (Tag:54; Q:93; Act:2), //Reduce Rule; 
        (Tag:61; Q:93; Act:2), //Reduce Rule; 
        (Tag:62; Q:93; Act:2), //Reduce Rule; 
        (Tag:64; Q:93; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState135: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:50; Act:2), //Reduce Rule; 
        (Tag:41; Q:50; Act:2), //Reduce Rule; 
        (Tag:42; Q:50; Act:2), //Reduce Rule; 
        (Tag:64; Q:50; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState136: packed array[0..1] of TParseEdge= (
        (Tag:18; Q:180; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState137: packed array[0..1] of TParseEdge= (
        (Tag:8; Q:181; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState138: packed array[0..3] of TParseEdge= (
        (Tag:8; Q:97; Act:2), //Reduce Rule; 
        (Tag:16; Q:97; Act:2), //Reduce Rule; 
        (Tag:42; Q:97; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState139: packed array[0..9] of TParseEdge= (
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:182; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:183; Act:3), //Goto; 
        (Tag:82; Q:184; Act:3), //Goto; 
        (Tag:83; Q:185; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState140: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:186; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState141: packed array[0..2] of TParseEdge= (
        (Tag:16; Q:187; Act:1), //Shift; 
        (Tag:42; Q:107; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState142: packed array[0..1] of TParseEdge= (
        (Tag:42; Q:188; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState143: packed array[0..1] of TParseEdge= (
        (Tag:14; Q:189; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState144: packed array[0..6] of TParseEdge= (
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:190; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState145: packed array[0..5] of TParseEdge= (
        (Tag:29; Q:18; Act:2), //Reduce Rule; 
        (Tag:47; Q:18; Act:2), //Reduce Rule; 
        (Tag:49; Q:18; Act:2), //Reduce Rule; 
        (Tag:55; Q:18; Act:2), //Reduce Rule; 
        (Tag:65; Q:18; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState146: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:191; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState147: packed array[0..5] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:65; Q:192; Act:1), //Shift; 
        (Tag:68; Q:193; Act:3), //Goto; 
        (Tag:69; Q:194; Act:3), //Goto; 
        (Tag:92; Q:195; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState148: packed array[0..1] of TParseEdge= (
        (Tag:14; Q:196; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState149: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:197; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState150: packed array[0..3] of TParseEdge= (
        (Tag:29; Q:28; Act:2), //Reduce Rule; 
        (Tag:47; Q:28; Act:2), //Reduce Rule; 
        (Tag:55; Q:28; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState151: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:198; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState152: packed array[0..3] of TParseEdge= (
        (Tag:29; Q:26; Act:2), //Reduce Rule; 
        (Tag:47; Q:26; Act:2), //Reduce Rule; 
        (Tag:55; Q:26; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState153: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:199; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState154: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:80; Act:2), //Reduce Rule; 
        (Tag:8; Q:80; Act:2), //Reduce Rule; 
        (Tag:9; Q:80; Act:2), //Reduce Rule; 
        (Tag:10; Q:80; Act:2), //Reduce Rule; 
        (Tag:13; Q:80; Act:2), //Reduce Rule; 
        (Tag:16; Q:80; Act:2), //Reduce Rule; 
        (Tag:18; Q:80; Act:2), //Reduce Rule; 
        (Tag:20; Q:80; Act:2), //Reduce Rule; 
        (Tag:21; Q:80; Act:2), //Reduce Rule; 
        (Tag:22; Q:80; Act:2), //Reduce Rule; 
        (Tag:23; Q:80; Act:2), //Reduce Rule; 
        (Tag:24; Q:80; Act:2), //Reduce Rule; 
        (Tag:25; Q:80; Act:2), //Reduce Rule; 
        (Tag:26; Q:80; Act:2), //Reduce Rule; 
        (Tag:27; Q:80; Act:2), //Reduce Rule; 
        (Tag:38; Q:80; Act:2), //Reduce Rule; 
        (Tag:39; Q:80; Act:2), //Reduce Rule; 
        (Tag:40; Q:80; Act:2), //Reduce Rule; 
        (Tag:41; Q:80; Act:2), //Reduce Rule; 
        (Tag:42; Q:80; Act:2), //Reduce Rule; 
        (Tag:51; Q:80; Act:2), //Reduce Rule; 
        (Tag:53; Q:80; Act:2), //Reduce Rule; 
        (Tag:54; Q:80; Act:2), //Reduce Rule; 
        (Tag:61; Q:80; Act:2), //Reduce Rule; 
        (Tag:62; Q:80; Act:2), //Reduce Rule; 
        (Tag:64; Q:80; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState155: packed array[0..1] of TParseEdge= (
        (Tag:8; Q:200; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState156: packed array[0..2] of TParseEdge= (
        (Tag:16; Q:201; Act:1), //Shift; 
        (Tag:42; Q:58; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState157: packed array[0..1] of TParseEdge= (
        (Tag:42; Q:202; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState158: packed array[0..2] of TParseEdge= (
        (Tag:10; Q:203; Act:1), //Shift; 
        (Tag:14; Q:61; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState159: packed array[0..1] of TParseEdge= (
        (Tag:14; Q:204; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState160: packed array[0..26] of TParseEdge= (
        (Tag:9; Q:122; Act:1), //Shift; 
        (Tag:13; Q:123; Act:1), //Shift; 
        (Tag:27; Q:124; Act:1), //Shift; 
        (Tag:38; Q:125; Act:1), //Shift; 
        (Tag:51; Q:126; Act:1), //Shift; 
        (Tag:6; Q:72; Act:2), //Reduce Rule; 
        (Tag:8; Q:72; Act:2), //Reduce Rule; 
        (Tag:10; Q:72; Act:2), //Reduce Rule; 
        (Tag:16; Q:72; Act:2), //Reduce Rule; 
        (Tag:18; Q:72; Act:2), //Reduce Rule; 
        (Tag:20; Q:72; Act:2), //Reduce Rule; 
        (Tag:21; Q:72; Act:2), //Reduce Rule; 
        (Tag:22; Q:72; Act:2), //Reduce Rule; 
        (Tag:23; Q:72; Act:2), //Reduce Rule; 
        (Tag:24; Q:72; Act:2), //Reduce Rule; 
        (Tag:25; Q:72; Act:2), //Reduce Rule; 
        (Tag:26; Q:72; Act:2), //Reduce Rule; 
        (Tag:39; Q:72; Act:2), //Reduce Rule; 
        (Tag:40; Q:72; Act:2), //Reduce Rule; 
        (Tag:41; Q:72; Act:2), //Reduce Rule; 
        (Tag:42; Q:72; Act:2), //Reduce Rule; 
        (Tag:53; Q:72; Act:2), //Reduce Rule; 
        (Tag:54; Q:72; Act:2), //Reduce Rule; 
        (Tag:61; Q:72; Act:2), //Reduce Rule; 
        (Tag:62; Q:72; Act:2), //Reduce Rule; 
        (Tag:64; Q:72; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState161: packed array[0..26] of TParseEdge= (
        (Tag:9; Q:122; Act:1), //Shift; 
        (Tag:13; Q:123; Act:1), //Shift; 
        (Tag:27; Q:124; Act:1), //Shift; 
        (Tag:38; Q:125; Act:1), //Shift; 
        (Tag:51; Q:126; Act:1), //Shift; 
        (Tag:6; Q:71; Act:2), //Reduce Rule; 
        (Tag:8; Q:71; Act:2), //Reduce Rule; 
        (Tag:10; Q:71; Act:2), //Reduce Rule; 
        (Tag:16; Q:71; Act:2), //Reduce Rule; 
        (Tag:18; Q:71; Act:2), //Reduce Rule; 
        (Tag:20; Q:71; Act:2), //Reduce Rule; 
        (Tag:21; Q:71; Act:2), //Reduce Rule; 
        (Tag:22; Q:71; Act:2), //Reduce Rule; 
        (Tag:23; Q:71; Act:2), //Reduce Rule; 
        (Tag:24; Q:71; Act:2), //Reduce Rule; 
        (Tag:25; Q:71; Act:2), //Reduce Rule; 
        (Tag:26; Q:71; Act:2), //Reduce Rule; 
        (Tag:39; Q:71; Act:2), //Reduce Rule; 
        (Tag:40; Q:71; Act:2), //Reduce Rule; 
        (Tag:41; Q:71; Act:2), //Reduce Rule; 
        (Tag:42; Q:71; Act:2), //Reduce Rule; 
        (Tag:53; Q:71; Act:2), //Reduce Rule; 
        (Tag:54; Q:71; Act:2), //Reduce Rule; 
        (Tag:61; Q:71; Act:2), //Reduce Rule; 
        (Tag:62; Q:71; Act:2), //Reduce Rule; 
        (Tag:64; Q:71; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState162: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:113; Act:1), //Shift; 
        (Tag:20; Q:114; Act:1), //Shift; 
        (Tag:54; Q:121; Act:1), //Shift; 
        (Tag:8; Q:66; Act:2), //Reduce Rule; 
        (Tag:10; Q:66; Act:2), //Reduce Rule; 
        (Tag:16; Q:66; Act:2), //Reduce Rule; 
        (Tag:18; Q:66; Act:2), //Reduce Rule; 
        (Tag:39; Q:66; Act:2), //Reduce Rule; 
        (Tag:40; Q:66; Act:2), //Reduce Rule; 
        (Tag:41; Q:66; Act:2), //Reduce Rule; 
        (Tag:42; Q:66; Act:2), //Reduce Rule; 
        (Tag:53; Q:66; Act:2), //Reduce Rule; 
        (Tag:61; Q:66; Act:2), //Reduce Rule; 
        (Tag:62; Q:66; Act:2), //Reduce Rule; 
        (Tag:64; Q:66; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState163: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:113; Act:1), //Shift; 
        (Tag:20; Q:114; Act:1), //Shift; 
        (Tag:54; Q:121; Act:1), //Shift; 
        (Tag:8; Q:67; Act:2), //Reduce Rule; 
        (Tag:10; Q:67; Act:2), //Reduce Rule; 
        (Tag:16; Q:67; Act:2), //Reduce Rule; 
        (Tag:18; Q:67; Act:2), //Reduce Rule; 
        (Tag:39; Q:67; Act:2), //Reduce Rule; 
        (Tag:40; Q:67; Act:2), //Reduce Rule; 
        (Tag:41; Q:67; Act:2), //Reduce Rule; 
        (Tag:42; Q:67; Act:2), //Reduce Rule; 
        (Tag:53; Q:67; Act:2), //Reduce Rule; 
        (Tag:61; Q:67; Act:2), //Reduce Rule; 
        (Tag:62; Q:67; Act:2), //Reduce Rule; 
        (Tag:64; Q:67; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState164: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:113; Act:1), //Shift; 
        (Tag:20; Q:114; Act:1), //Shift; 
        (Tag:54; Q:121; Act:1), //Shift; 
        (Tag:8; Q:65; Act:2), //Reduce Rule; 
        (Tag:10; Q:65; Act:2), //Reduce Rule; 
        (Tag:16; Q:65; Act:2), //Reduce Rule; 
        (Tag:18; Q:65; Act:2), //Reduce Rule; 
        (Tag:39; Q:65; Act:2), //Reduce Rule; 
        (Tag:40; Q:65; Act:2), //Reduce Rule; 
        (Tag:41; Q:65; Act:2), //Reduce Rule; 
        (Tag:42; Q:65; Act:2), //Reduce Rule; 
        (Tag:53; Q:65; Act:2), //Reduce Rule; 
        (Tag:61; Q:65; Act:2), //Reduce Rule; 
        (Tag:62; Q:65; Act:2), //Reduce Rule; 
        (Tag:64; Q:65; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState165: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:113; Act:1), //Shift; 
        (Tag:20; Q:114; Act:1), //Shift; 
        (Tag:54; Q:121; Act:1), //Shift; 
        (Tag:8; Q:64; Act:2), //Reduce Rule; 
        (Tag:10; Q:64; Act:2), //Reduce Rule; 
        (Tag:16; Q:64; Act:2), //Reduce Rule; 
        (Tag:18; Q:64; Act:2), //Reduce Rule; 
        (Tag:39; Q:64; Act:2), //Reduce Rule; 
        (Tag:40; Q:64; Act:2), //Reduce Rule; 
        (Tag:41; Q:64; Act:2), //Reduce Rule; 
        (Tag:42; Q:64; Act:2), //Reduce Rule; 
        (Tag:53; Q:64; Act:2), //Reduce Rule; 
        (Tag:61; Q:64; Act:2), //Reduce Rule; 
        (Tag:62; Q:64; Act:2), //Reduce Rule; 
        (Tag:64; Q:64; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState166: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:113; Act:1), //Shift; 
        (Tag:20; Q:114; Act:1), //Shift; 
        (Tag:54; Q:121; Act:1), //Shift; 
        (Tag:8; Q:68; Act:2), //Reduce Rule; 
        (Tag:10; Q:68; Act:2), //Reduce Rule; 
        (Tag:16; Q:68; Act:2), //Reduce Rule; 
        (Tag:18; Q:68; Act:2), //Reduce Rule; 
        (Tag:39; Q:68; Act:2), //Reduce Rule; 
        (Tag:40; Q:68; Act:2), //Reduce Rule; 
        (Tag:41; Q:68; Act:2), //Reduce Rule; 
        (Tag:42; Q:68; Act:2), //Reduce Rule; 
        (Tag:53; Q:68; Act:2), //Reduce Rule; 
        (Tag:61; Q:68; Act:2), //Reduce Rule; 
        (Tag:62; Q:68; Act:2), //Reduce Rule; 
        (Tag:64; Q:68; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState167: packed array[0..15] of TParseEdge= (
        (Tag:6; Q:113; Act:1), //Shift; 
        (Tag:20; Q:114; Act:1), //Shift; 
        (Tag:54; Q:121; Act:1), //Shift; 
        (Tag:8; Q:69; Act:2), //Reduce Rule; 
        (Tag:10; Q:69; Act:2), //Reduce Rule; 
        (Tag:16; Q:69; Act:2), //Reduce Rule; 
        (Tag:18; Q:69; Act:2), //Reduce Rule; 
        (Tag:39; Q:69; Act:2), //Reduce Rule; 
        (Tag:40; Q:69; Act:2), //Reduce Rule; 
        (Tag:41; Q:69; Act:2), //Reduce Rule; 
        (Tag:42; Q:69; Act:2), //Reduce Rule; 
        (Tag:53; Q:69; Act:2), //Reduce Rule; 
        (Tag:61; Q:69; Act:2), //Reduce Rule; 
        (Tag:62; Q:69; Act:2), //Reduce Rule; 
        (Tag:64; Q:69; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState168: packed array[0..26] of TParseEdge= (
        (Tag:9; Q:122; Act:1), //Shift; 
        (Tag:13; Q:123; Act:1), //Shift; 
        (Tag:27; Q:124; Act:1), //Shift; 
        (Tag:38; Q:125; Act:1), //Shift; 
        (Tag:51; Q:126; Act:1), //Shift; 
        (Tag:6; Q:73; Act:2), //Reduce Rule; 
        (Tag:8; Q:73; Act:2), //Reduce Rule; 
        (Tag:10; Q:73; Act:2), //Reduce Rule; 
        (Tag:16; Q:73; Act:2), //Reduce Rule; 
        (Tag:18; Q:73; Act:2), //Reduce Rule; 
        (Tag:20; Q:73; Act:2), //Reduce Rule; 
        (Tag:21; Q:73; Act:2), //Reduce Rule; 
        (Tag:22; Q:73; Act:2), //Reduce Rule; 
        (Tag:23; Q:73; Act:2), //Reduce Rule; 
        (Tag:24; Q:73; Act:2), //Reduce Rule; 
        (Tag:25; Q:73; Act:2), //Reduce Rule; 
        (Tag:26; Q:73; Act:2), //Reduce Rule; 
        (Tag:39; Q:73; Act:2), //Reduce Rule; 
        (Tag:40; Q:73; Act:2), //Reduce Rule; 
        (Tag:41; Q:73; Act:2), //Reduce Rule; 
        (Tag:42; Q:73; Act:2), //Reduce Rule; 
        (Tag:53; Q:73; Act:2), //Reduce Rule; 
        (Tag:54; Q:73; Act:2), //Reduce Rule; 
        (Tag:61; Q:73; Act:2), //Reduce Rule; 
        (Tag:62; Q:73; Act:2), //Reduce Rule; 
        (Tag:64; Q:73; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState169: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:75; Act:2), //Reduce Rule; 
        (Tag:8; Q:75; Act:2), //Reduce Rule; 
        (Tag:9; Q:75; Act:2), //Reduce Rule; 
        (Tag:10; Q:75; Act:2), //Reduce Rule; 
        (Tag:13; Q:75; Act:2), //Reduce Rule; 
        (Tag:16; Q:75; Act:2), //Reduce Rule; 
        (Tag:18; Q:75; Act:2), //Reduce Rule; 
        (Tag:20; Q:75; Act:2), //Reduce Rule; 
        (Tag:21; Q:75; Act:2), //Reduce Rule; 
        (Tag:22; Q:75; Act:2), //Reduce Rule; 
        (Tag:23; Q:75; Act:2), //Reduce Rule; 
        (Tag:24; Q:75; Act:2), //Reduce Rule; 
        (Tag:25; Q:75; Act:2), //Reduce Rule; 
        (Tag:26; Q:75; Act:2), //Reduce Rule; 
        (Tag:27; Q:75; Act:2), //Reduce Rule; 
        (Tag:38; Q:75; Act:2), //Reduce Rule; 
        (Tag:39; Q:75; Act:2), //Reduce Rule; 
        (Tag:40; Q:75; Act:2), //Reduce Rule; 
        (Tag:41; Q:75; Act:2), //Reduce Rule; 
        (Tag:42; Q:75; Act:2), //Reduce Rule; 
        (Tag:51; Q:75; Act:2), //Reduce Rule; 
        (Tag:53; Q:75; Act:2), //Reduce Rule; 
        (Tag:54; Q:75; Act:2), //Reduce Rule; 
        (Tag:61; Q:75; Act:2), //Reduce Rule; 
        (Tag:62; Q:75; Act:2), //Reduce Rule; 
        (Tag:64; Q:75; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState170: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:76; Act:2), //Reduce Rule; 
        (Tag:8; Q:76; Act:2), //Reduce Rule; 
        (Tag:9; Q:76; Act:2), //Reduce Rule; 
        (Tag:10; Q:76; Act:2), //Reduce Rule; 
        (Tag:13; Q:76; Act:2), //Reduce Rule; 
        (Tag:16; Q:76; Act:2), //Reduce Rule; 
        (Tag:18; Q:76; Act:2), //Reduce Rule; 
        (Tag:20; Q:76; Act:2), //Reduce Rule; 
        (Tag:21; Q:76; Act:2), //Reduce Rule; 
        (Tag:22; Q:76; Act:2), //Reduce Rule; 
        (Tag:23; Q:76; Act:2), //Reduce Rule; 
        (Tag:24; Q:76; Act:2), //Reduce Rule; 
        (Tag:25; Q:76; Act:2), //Reduce Rule; 
        (Tag:26; Q:76; Act:2), //Reduce Rule; 
        (Tag:27; Q:76; Act:2), //Reduce Rule; 
        (Tag:38; Q:76; Act:2), //Reduce Rule; 
        (Tag:39; Q:76; Act:2), //Reduce Rule; 
        (Tag:40; Q:76; Act:2), //Reduce Rule; 
        (Tag:41; Q:76; Act:2), //Reduce Rule; 
        (Tag:42; Q:76; Act:2), //Reduce Rule; 
        (Tag:51; Q:76; Act:2), //Reduce Rule; 
        (Tag:53; Q:76; Act:2), //Reduce Rule; 
        (Tag:54; Q:76; Act:2), //Reduce Rule; 
        (Tag:61; Q:76; Act:2), //Reduce Rule; 
        (Tag:62; Q:76; Act:2), //Reduce Rule; 
        (Tag:64; Q:76; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState171: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:79; Act:2), //Reduce Rule; 
        (Tag:8; Q:79; Act:2), //Reduce Rule; 
        (Tag:9; Q:79; Act:2), //Reduce Rule; 
        (Tag:10; Q:79; Act:2), //Reduce Rule; 
        (Tag:13; Q:79; Act:2), //Reduce Rule; 
        (Tag:16; Q:79; Act:2), //Reduce Rule; 
        (Tag:18; Q:79; Act:2), //Reduce Rule; 
        (Tag:20; Q:79; Act:2), //Reduce Rule; 
        (Tag:21; Q:79; Act:2), //Reduce Rule; 
        (Tag:22; Q:79; Act:2), //Reduce Rule; 
        (Tag:23; Q:79; Act:2), //Reduce Rule; 
        (Tag:24; Q:79; Act:2), //Reduce Rule; 
        (Tag:25; Q:79; Act:2), //Reduce Rule; 
        (Tag:26; Q:79; Act:2), //Reduce Rule; 
        (Tag:27; Q:79; Act:2), //Reduce Rule; 
        (Tag:38; Q:79; Act:2), //Reduce Rule; 
        (Tag:39; Q:79; Act:2), //Reduce Rule; 
        (Tag:40; Q:79; Act:2), //Reduce Rule; 
        (Tag:41; Q:79; Act:2), //Reduce Rule; 
        (Tag:42; Q:79; Act:2), //Reduce Rule; 
        (Tag:51; Q:79; Act:2), //Reduce Rule; 
        (Tag:53; Q:79; Act:2), //Reduce Rule; 
        (Tag:54; Q:79; Act:2), //Reduce Rule; 
        (Tag:61; Q:79; Act:2), //Reduce Rule; 
        (Tag:62; Q:79; Act:2), //Reduce Rule; 
        (Tag:64; Q:79; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState172: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:77; Act:2), //Reduce Rule; 
        (Tag:8; Q:77; Act:2), //Reduce Rule; 
        (Tag:9; Q:77; Act:2), //Reduce Rule; 
        (Tag:10; Q:77; Act:2), //Reduce Rule; 
        (Tag:13; Q:77; Act:2), //Reduce Rule; 
        (Tag:16; Q:77; Act:2), //Reduce Rule; 
        (Tag:18; Q:77; Act:2), //Reduce Rule; 
        (Tag:20; Q:77; Act:2), //Reduce Rule; 
        (Tag:21; Q:77; Act:2), //Reduce Rule; 
        (Tag:22; Q:77; Act:2), //Reduce Rule; 
        (Tag:23; Q:77; Act:2), //Reduce Rule; 
        (Tag:24; Q:77; Act:2), //Reduce Rule; 
        (Tag:25; Q:77; Act:2), //Reduce Rule; 
        (Tag:26; Q:77; Act:2), //Reduce Rule; 
        (Tag:27; Q:77; Act:2), //Reduce Rule; 
        (Tag:38; Q:77; Act:2), //Reduce Rule; 
        (Tag:39; Q:77; Act:2), //Reduce Rule; 
        (Tag:40; Q:77; Act:2), //Reduce Rule; 
        (Tag:41; Q:77; Act:2), //Reduce Rule; 
        (Tag:42; Q:77; Act:2), //Reduce Rule; 
        (Tag:51; Q:77; Act:2), //Reduce Rule; 
        (Tag:53; Q:77; Act:2), //Reduce Rule; 
        (Tag:54; Q:77; Act:2), //Reduce Rule; 
        (Tag:61; Q:77; Act:2), //Reduce Rule; 
        (Tag:62; Q:77; Act:2), //Reduce Rule; 
        (Tag:64; Q:77; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState173: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:78; Act:2), //Reduce Rule; 
        (Tag:8; Q:78; Act:2), //Reduce Rule; 
        (Tag:9; Q:78; Act:2), //Reduce Rule; 
        (Tag:10; Q:78; Act:2), //Reduce Rule; 
        (Tag:13; Q:78; Act:2), //Reduce Rule; 
        (Tag:16; Q:78; Act:2), //Reduce Rule; 
        (Tag:18; Q:78; Act:2), //Reduce Rule; 
        (Tag:20; Q:78; Act:2), //Reduce Rule; 
        (Tag:21; Q:78; Act:2), //Reduce Rule; 
        (Tag:22; Q:78; Act:2), //Reduce Rule; 
        (Tag:23; Q:78; Act:2), //Reduce Rule; 
        (Tag:24; Q:78; Act:2), //Reduce Rule; 
        (Tag:25; Q:78; Act:2), //Reduce Rule; 
        (Tag:26; Q:78; Act:2), //Reduce Rule; 
        (Tag:27; Q:78; Act:2), //Reduce Rule; 
        (Tag:38; Q:78; Act:2), //Reduce Rule; 
        (Tag:39; Q:78; Act:2), //Reduce Rule; 
        (Tag:40; Q:78; Act:2), //Reduce Rule; 
        (Tag:41; Q:78; Act:2), //Reduce Rule; 
        (Tag:42; Q:78; Act:2), //Reduce Rule; 
        (Tag:51; Q:78; Act:2), //Reduce Rule; 
        (Tag:53; Q:78; Act:2), //Reduce Rule; 
        (Tag:54; Q:78; Act:2), //Reduce Rule; 
        (Tag:61; Q:78; Act:2), //Reduce Rule; 
        (Tag:62; Q:78; Act:2), //Reduce Rule; 
        (Tag:64; Q:78; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState174: packed array[0..2] of TParseEdge= (
        (Tag:40; Q:205; Act:1), //Shift; 
        (Tag:62; Q:206; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState175: packed array[0..18] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:128; Act:3), //Goto; 
        (Tag:85; Q:207; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState176: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:88; Act:2), //Reduce Rule; 
        (Tag:41; Q:88; Act:2), //Reduce Rule; 
        (Tag:42; Q:88; Act:2), //Reduce Rule; 
        (Tag:64; Q:88; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState177: packed array[0..1] of TParseEdge= (
        (Tag:41; Q:208; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState178: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:56; Act:2), //Reduce Rule; 
        (Tag:41; Q:56; Act:2), //Reduce Rule; 
        (Tag:42; Q:56; Act:2), //Reduce Rule; 
        (Tag:64; Q:56; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState179: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:54; Act:2), //Reduce Rule; 
        (Tag:41; Q:54; Act:2), //Reduce Rule; 
        (Tag:42; Q:54; Act:2), //Reduce Rule; 
        (Tag:64; Q:54; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState180: packed array[0..30] of TParseEdge= (
        (Tag:6; Q:95; Act:2), //Reduce Rule; 
        (Tag:8; Q:95; Act:2), //Reduce Rule; 
        (Tag:9; Q:95; Act:2), //Reduce Rule; 
        (Tag:10; Q:95; Act:2), //Reduce Rule; 
        (Tag:11; Q:95; Act:2), //Reduce Rule; 
        (Tag:13; Q:95; Act:2), //Reduce Rule; 
        (Tag:15; Q:95; Act:2), //Reduce Rule; 
        (Tag:16; Q:95; Act:2), //Reduce Rule; 
        (Tag:17; Q:95; Act:2), //Reduce Rule; 
        (Tag:18; Q:95; Act:2), //Reduce Rule; 
        (Tag:19; Q:95; Act:2), //Reduce Rule; 
        (Tag:20; Q:95; Act:2), //Reduce Rule; 
        (Tag:21; Q:95; Act:2), //Reduce Rule; 
        (Tag:22; Q:95; Act:2), //Reduce Rule; 
        (Tag:23; Q:95; Act:2), //Reduce Rule; 
        (Tag:24; Q:95; Act:2), //Reduce Rule; 
        (Tag:25; Q:95; Act:2), //Reduce Rule; 
        (Tag:26; Q:95; Act:2), //Reduce Rule; 
        (Tag:27; Q:95; Act:2), //Reduce Rule; 
        (Tag:38; Q:95; Act:2), //Reduce Rule; 
        (Tag:39; Q:95; Act:2), //Reduce Rule; 
        (Tag:40; Q:95; Act:2), //Reduce Rule; 
        (Tag:41; Q:95; Act:2), //Reduce Rule; 
        (Tag:42; Q:95; Act:2), //Reduce Rule; 
        (Tag:51; Q:95; Act:2), //Reduce Rule; 
        (Tag:53; Q:95; Act:2), //Reduce Rule; 
        (Tag:54; Q:95; Act:2), //Reduce Rule; 
        (Tag:61; Q:95; Act:2), //Reduce Rule; 
        (Tag:62; Q:95; Act:2), //Reduce Rule; 
        (Tag:64; Q:95; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState181: packed array[0..3] of TParseEdge= (
        (Tag:8; Q:98; Act:2), //Reduce Rule; 
        (Tag:16; Q:98; Act:2), //Reduce Rule; 
        (Tag:42; Q:98; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState182: packed array[0..2] of TParseEdge= (
        (Tag:10; Q:106; Act:2), //Reduce Rule; 
        (Tag:18; Q:106; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState183: packed array[0..1] of TParseEdge= (
        (Tag:12; Q:209; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState184: packed array[0..2] of TParseEdge= (
        (Tag:10; Q:210; Act:1), //Shift; 
        (Tag:18; Q:103; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState185: packed array[0..1] of TParseEdge= (
        (Tag:18; Q:211; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState186: packed array[0..3] of TParseEdge= (
        (Tag:8; Q:102; Act:2), //Reduce Rule; 
        (Tag:16; Q:102; Act:2), //Reduce Rule; 
        (Tag:42; Q:102; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState187: packed array[0..4] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:87; Q:141; Act:3), //Goto; 
        (Tag:88; Q:212; Act:3), //Goto; 
        (Tag:92; Q:143; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState188: packed array[0..3] of TParseEdge= (
        (Tag:8; Q:101; Act:2), //Reduce Rule; 
        (Tag:16; Q:101; Act:2), //Reduce Rule; 
        (Tag:42; Q:101; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState189: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:213; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState190: packed array[0..3] of TParseEdge= (
        (Tag:8; Q:99; Act:2), //Reduce Rule; 
        (Tag:16; Q:99; Act:2), //Reduce Rule; 
        (Tag:42; Q:99; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState191: packed array[0..4] of TParseEdge= (
        (Tag:29; Q:23; Act:2), //Reduce Rule; 
        (Tag:47; Q:23; Act:2), //Reduce Rule; 
        (Tag:49; Q:23; Act:2), //Reduce Rule; 
        (Tag:55; Q:23; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState192: packed array[0..2] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:92; Q:214; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState193: packed array[0..2] of TParseEdge= (
        (Tag:16; Q:215; Act:1), //Shift; 
        (Tag:8; Q:34; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState194: packed array[0..1] of TParseEdge= (
        (Tag:8; Q:216; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState195: packed array[0..1] of TParseEdge= (
        (Tag:14; Q:217; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState196: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:218; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState197: packed array[0..7] of TParseEdge= (
        (Tag:29; Q:30; Act:2), //Reduce Rule; 
        (Tag:36; Q:30; Act:2), //Reduce Rule; 
        (Tag:46; Q:30; Act:2), //Reduce Rule; 
        (Tag:47; Q:30; Act:2), //Reduce Rule; 
        (Tag:55; Q:30; Act:2), //Reduce Rule; 
        (Tag:63; Q:30; Act:2), //Reduce Rule; 
        (Tag:65; Q:30; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState198: packed array[0..3] of TParseEdge= (
        (Tag:29; Q:29; Act:2), //Reduce Rule; 
        (Tag:47; Q:29; Act:2), //Reduce Rule; 
        (Tag:55; Q:29; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState199: packed array[0..3] of TParseEdge= (
        (Tag:29; Q:27; Act:2), //Reduce Rule; 
        (Tag:47; Q:27; Act:2), //Reduce Rule; 
        (Tag:55; Q:27; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState200: packed array[0..26] of TParseEdge= (
        (Tag:6; Q:87; Act:2), //Reduce Rule; 
        (Tag:8; Q:87; Act:2), //Reduce Rule; 
        (Tag:9; Q:87; Act:2), //Reduce Rule; 
        (Tag:10; Q:87; Act:2), //Reduce Rule; 
        (Tag:13; Q:87; Act:2), //Reduce Rule; 
        (Tag:16; Q:87; Act:2), //Reduce Rule; 
        (Tag:18; Q:87; Act:2), //Reduce Rule; 
        (Tag:20; Q:87; Act:2), //Reduce Rule; 
        (Tag:21; Q:87; Act:2), //Reduce Rule; 
        (Tag:22; Q:87; Act:2), //Reduce Rule; 
        (Tag:23; Q:87; Act:2), //Reduce Rule; 
        (Tag:24; Q:87; Act:2), //Reduce Rule; 
        (Tag:25; Q:87; Act:2), //Reduce Rule; 
        (Tag:26; Q:87; Act:2), //Reduce Rule; 
        (Tag:27; Q:87; Act:2), //Reduce Rule; 
        (Tag:38; Q:87; Act:2), //Reduce Rule; 
        (Tag:39; Q:87; Act:2), //Reduce Rule; 
        (Tag:40; Q:87; Act:2), //Reduce Rule; 
        (Tag:41; Q:87; Act:2), //Reduce Rule; 
        (Tag:42; Q:87; Act:2), //Reduce Rule; 
        (Tag:51; Q:87; Act:2), //Reduce Rule; 
        (Tag:53; Q:87; Act:2), //Reduce Rule; 
        (Tag:54; Q:87; Act:2), //Reduce Rule; 
        (Tag:61; Q:87; Act:2), //Reduce Rule; 
        (Tag:62; Q:87; Act:2), //Reduce Rule; 
        (Tag:64; Q:87; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState201: packed array[0..9] of TParseEdge= (
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:72; Q:156; Act:3), //Goto; 
        (Tag:73; Q:219; Act:3), //Goto; 
        (Tag:76; Q:158; Act:3), //Goto; 
        (Tag:80; Q:159; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState202: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:57; Act:2), //Reduce Rule; 
        (Tag:41; Q:57; Act:2), //Reduce Rule; 
        (Tag:42; Q:57; Act:2), //Reduce Rule; 
        (Tag:64; Q:57; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState203: packed array[0..7] of TParseEdge= (
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:158; Act:3), //Goto; 
        (Tag:80; Q:220; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState204: packed array[0..19] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:221; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:16; Q:49; Act:2), //Reduce Rule; 
        (Tag:42; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState205: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:222; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState206: packed array[0..17] of TParseEdge= (
        (Tag:6; Q:63; Act:1), //Shift; 
        (Tag:7; Q:64; Act:1), //Shift; 
        (Tag:20; Q:65; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:66; Act:1), //Shift; 
        (Tag:52; Q:67; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:68; Act:3), //Goto; 
        (Tag:84; Q:223; Act:3), //Goto; 
        (Tag:86; Q:70; Act:3), //Goto; 
        (Tag:90; Q:71; Act:3), //Goto; 
        (Tag:101; Q:72; Act:3), //Goto; 
        (Tag:104; Q:73; Act:3), //Goto; 
        (Tag:109; Q:74; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState207: packed array[0..2] of TParseEdge= (
        (Tag:8; Q:91; Act:2), //Reduce Rule; 
        (Tag:18; Q:91; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState208: packed array[0..21] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:224; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:16; Q:49; Act:2), //Reduce Rule; 
        (Tag:41; Q:49; Act:2), //Reduce Rule; 
        (Tag:42; Q:49; Act:2), //Reduce Rule; 
        (Tag:64; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState209: packed array[0..6] of TParseEdge= (
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:225; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState210: packed array[0..9] of TParseEdge= (
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:182; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:183; Act:3), //Goto; 
        (Tag:82; Q:184; Act:3), //Goto; 
        (Tag:83; Q:226; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState211: packed array[0..1] of TParseEdge= (
        (Tag:53; Q:227; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState212: packed array[0..1] of TParseEdge= (
        (Tag:42; Q:108; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState213: packed array[0..2] of TParseEdge= (
        (Tag:16; Q:109; Act:2), //Reduce Rule; 
        (Tag:42; Q:109; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState214: packed array[0..1] of TParseEdge= (
        (Tag:14; Q:228; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState215: packed array[0..5] of TParseEdge= (
        (Tag:49; Q:17; Act:1), //Shift; 
        (Tag:65; Q:192; Act:1), //Shift; 
        (Tag:68; Q:193; Act:3), //Goto; 
        (Tag:69; Q:229; Act:3), //Goto; 
        (Tag:92; Q:195; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState216: packed array[0..2] of TParseEdge= (
        (Tag:14; Q:32; Act:2), //Reduce Rule; 
        (Tag:16; Q:32; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState217: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:230; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState218: packed array[0..1] of TParseEdge= (
        (Tag:16; Q:231; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState219: packed array[0..1] of TParseEdge= (
        (Tag:42; Q:59; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState220: packed array[0..1] of TParseEdge= (
        (Tag:14; Q:62; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState221: packed array[0..2] of TParseEdge= (
        (Tag:16; Q:60; Act:2), //Reduce Rule; 
        (Tag:42; Q:60; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState222: packed array[0..1] of TParseEdge= (
        (Tag:39; Q:232; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState223: packed array[0..1] of TParseEdge= (
        (Tag:39; Q:233; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState224: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:55; Act:2), //Reduce Rule; 
        (Tag:41; Q:55; Act:2), //Reduce Rule; 
        (Tag:42; Q:55; Act:2), //Reduce Rule; 
        (Tag:64; Q:55; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState225: packed array[0..2] of TParseEdge= (
        (Tag:10; Q:105; Act:2), //Reduce Rule; 
        (Tag:18; Q:105; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState226: packed array[0..1] of TParseEdge= (
        (Tag:18; Q:104; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState227: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:234; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState228: packed array[0..13] of TParseEdge= (
        (Tag:7; Q:90; Act:1), //Shift; 
        (Tag:19; Q:91; Act:1), //Shift; 
        (Tag:28; Q:92; Act:1), //Shift; 
        (Tag:31; Q:46; Act:1), //Shift; 
        (Tag:37; Q:47; Act:1), //Shift; 
        (Tag:43; Q:93; Act:1), //Shift; 
        (Tag:44; Q:48; Act:1), //Shift; 
        (Tag:48; Q:49; Act:1), //Shift; 
        (Tag:49; Q:94; Act:1), //Shift; 
        (Tag:57; Q:95; Act:1), //Shift; 
        (Tag:59; Q:50; Act:1), //Shift; 
        (Tag:76; Q:96; Act:3), //Goto; 
        (Tag:108; Q:235; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState229: packed array[0..1] of TParseEdge= (
        (Tag:8; Q:35; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState230: packed array[0..2] of TParseEdge= (
        (Tag:8; Q:36; Act:2), //Reduce Rule; 
        (Tag:16; Q:36; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState231: packed array[0..7] of TParseEdge= (
        (Tag:29; Q:31; Act:2), //Reduce Rule; 
        (Tag:36; Q:31; Act:2), //Reduce Rule; 
        (Tag:46; Q:31; Act:2), //Reduce Rule; 
        (Tag:47; Q:31; Act:2), //Reduce Rule; 
        (Tag:55; Q:31; Act:2), //Reduce Rule; 
        (Tag:63; Q:31; Act:2), //Reduce Rule; 
        (Tag:65; Q:31; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState232: packed array[0..21] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:236; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:16; Q:49; Act:2), //Reduce Rule; 
        (Tag:41; Q:49; Act:2), //Reduce Rule; 
        (Tag:42; Q:49; Act:2), //Reduce Rule; 
        (Tag:64; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState233: packed array[0..21] of TParseEdge= (
        (Tag:29; Q:15; Act:1), //Shift; 
        (Tag:30; Q:26; Act:1), //Shift; 
        (Tag:45; Q:27; Act:1), //Shift; 
        (Tag:49; Q:28; Act:1), //Shift; 
        (Tag:50; Q:29; Act:1), //Shift; 
        (Tag:58; Q:30; Act:1), //Shift; 
        (Tag:66; Q:31; Act:1), //Shift; 
        (Tag:71; Q:32; Act:3), //Goto; 
        (Tag:74; Q:33; Act:3), //Goto; 
        (Tag:75; Q:34; Act:3), //Goto; 
        (Tag:89; Q:35; Act:3), //Goto; 
        (Tag:93; Q:36; Act:3), //Goto; 
        (Tag:94; Q:37; Act:3), //Goto; 
        (Tag:100; Q:38; Act:3), //Goto; 
        (Tag:102; Q:237; Act:3), //Goto; 
        (Tag:109; Q:41; Act:3), //Goto; 
        (Tag:113; Q:42; Act:3), //Goto; 
        (Tag:16; Q:49; Act:2), //Reduce Rule; 
        (Tag:41; Q:49; Act:2), //Reduce Rule; 
        (Tag:42; Q:49; Act:2), //Reduce Rule; 
        (Tag:64; Q:49; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState234: packed array[0..3] of TParseEdge= (
        (Tag:8; Q:100; Act:2), //Reduce Rule; 
        (Tag:16; Q:100; Act:2), //Reduce Rule; 
        (Tag:42; Q:100; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState235: packed array[0..2] of TParseEdge= (
        (Tag:8; Q:37; Act:2), //Reduce Rule; 
        (Tag:16; Q:37; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState236: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:53; Act:2), //Reduce Rule; 
        (Tag:41; Q:53; Act:2), //Reduce Rule; 
        (Tag:42; Q:53; Act:2), //Reduce Rule; 
        (Tag:64; Q:53; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState237: packed array[0..4] of TParseEdge= (
        (Tag:16; Q:52; Act:2), //Reduce Rule; 
        (Tag:41; Q:52; Act:2), //Reduce Rule; 
        (Tag:42; Q:52; Act:2), //Reduce Rule; 
        (Tag:64; Q:52; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseStateList: packed array[TState] of TEntry= (
        (EntryPtr:@ParseState0;	EdgeCnt:3),
        (EntryPtr:@ParseState1;	EdgeCnt:1),
        (EntryPtr:@ParseState2;	EdgeCnt:1),
        (EntryPtr:@ParseState3;	EdgeCnt:8),
        (EntryPtr:@ParseState4;	EdgeCnt:2),
        (EntryPtr:@ParseState5;	EdgeCnt:3),
        (EntryPtr:@ParseState6;	EdgeCnt:6),
        (EntryPtr:@ParseState7;	EdgeCnt:2),
        (EntryPtr:@ParseState8;	EdgeCnt:2),
        (EntryPtr:@ParseState9;	EdgeCnt:6),
        (EntryPtr:@ParseState10;	EdgeCnt:1),
        (EntryPtr:@ParseState11;	EdgeCnt:8),
        (EntryPtr:@ParseState12;	EdgeCnt:5),
        (EntryPtr:@ParseState13;	EdgeCnt:3),
        (EntryPtr:@ParseState14;	EdgeCnt:5),
        (EntryPtr:@ParseState15;	EdgeCnt:20),
        (EntryPtr:@ParseState16;	EdgeCnt:1),
        (EntryPtr:@ParseState17;	EdgeCnt:3),
        (EntryPtr:@ParseState18;	EdgeCnt:1),
        (EntryPtr:@ParseState19;	EdgeCnt:6),
        (EntryPtr:@ParseState20;	EdgeCnt:5),
        (EntryPtr:@ParseState21;	EdgeCnt:1),
        (EntryPtr:@ParseState22;	EdgeCnt:7),
        (EntryPtr:@ParseState23;	EdgeCnt:4),
        (EntryPtr:@ParseState24;	EdgeCnt:4),
        (EntryPtr:@ParseState25;	EdgeCnt:7),
        (EntryPtr:@ParseState26;	EdgeCnt:17),
        (EntryPtr:@ParseState27;	EdgeCnt:1),
        (EntryPtr:@ParseState28;	EdgeCnt:10),
        (EntryPtr:@ParseState29;	EdgeCnt:17),
        (EntryPtr:@ParseState30;	EdgeCnt:20),
        (EntryPtr:@ParseState31;	EdgeCnt:17),
        (EntryPtr:@ParseState32;	EdgeCnt:4),
        (EntryPtr:@ParseState33;	EdgeCnt:4),
        (EntryPtr:@ParseState34;	EdgeCnt:4),
        (EntryPtr:@ParseState35;	EdgeCnt:4),
        (EntryPtr:@ParseState36;	EdgeCnt:4),
        (EntryPtr:@ParseState37;	EdgeCnt:4),
        (EntryPtr:@ParseState38;	EdgeCnt:4),
        (EntryPtr:@ParseState39;	EdgeCnt:3),
        (EntryPtr:@ParseState40;	EdgeCnt:1),
        (EntryPtr:@ParseState41;	EdgeCnt:4),
        (EntryPtr:@ParseState42;	EdgeCnt:4),
        (EntryPtr:@ParseState43;	EdgeCnt:1),
        (EntryPtr:@ParseState44;	EdgeCnt:2),
        (EntryPtr:@ParseState45;	EdgeCnt:1),
        (EntryPtr:@ParseState46;	EdgeCnt:28),
        (EntryPtr:@ParseState47;	EdgeCnt:28),
        (EntryPtr:@ParseState48;	EdgeCnt:28),
        (EntryPtr:@ParseState49;	EdgeCnt:28),
        (EntryPtr:@ParseState50;	EdgeCnt:28),
        (EntryPtr:@ParseState51;	EdgeCnt:1),
        (EntryPtr:@ParseState52;	EdgeCnt:13),
        (EntryPtr:@ParseState53;	EdgeCnt:4),
        (EntryPtr:@ParseState54;	EdgeCnt:1),
        (EntryPtr:@ParseState55;	EdgeCnt:7),
        (EntryPtr:@ParseState56;	EdgeCnt:3),
        (EntryPtr:@ParseState57;	EdgeCnt:1),
        (EntryPtr:@ParseState58;	EdgeCnt:1),
        (EntryPtr:@ParseState59;	EdgeCnt:9),
        (EntryPtr:@ParseState60;	EdgeCnt:7),
        (EntryPtr:@ParseState61;	EdgeCnt:1),
        (EntryPtr:@ParseState62;	EdgeCnt:9),
        (EntryPtr:@ParseState63;	EdgeCnt:14),
        (EntryPtr:@ParseState64;	EdgeCnt:17),
        (EntryPtr:@ParseState65;	EdgeCnt:14),
        (EntryPtr:@ParseState66;	EdgeCnt:30),
        (EntryPtr:@ParseState67;	EdgeCnt:14),
        (EntryPtr:@ParseState68;	EdgeCnt:26),
        (EntryPtr:@ParseState69;	EdgeCnt:1),
        (EntryPtr:@ParseState70;	EdgeCnt:26),
        (EntryPtr:@ParseState71;	EdgeCnt:26),
        (EntryPtr:@ParseState72;	EdgeCnt:21),
        (EntryPtr:@ParseState73;	EdgeCnt:26),
        (EntryPtr:@ParseState74;	EdgeCnt:29),
        (EntryPtr:@ParseState75;	EdgeCnt:1),
        (EntryPtr:@ParseState76;	EdgeCnt:18),
        (EntryPtr:@ParseState77;	EdgeCnt:4),
        (EntryPtr:@ParseState78;	EdgeCnt:1),
        (EntryPtr:@ParseState79;	EdgeCnt:1),
        (EntryPtr:@ParseState80;	EdgeCnt:1),
        (EntryPtr:@ParseState81;	EdgeCnt:21),
        (EntryPtr:@ParseState82;	EdgeCnt:5),
        (EntryPtr:@ParseState83;	EdgeCnt:1),
        (EntryPtr:@ParseState84;	EdgeCnt:17),
        (EntryPtr:@ParseState85;	EdgeCnt:18),
        (EntryPtr:@ParseState86;	EdgeCnt:30),
        (EntryPtr:@ParseState87;	EdgeCnt:2),
        (EntryPtr:@ParseState88;	EdgeCnt:6),
        (EntryPtr:@ParseState89;	EdgeCnt:6),
        (EntryPtr:@ParseState90;	EdgeCnt:2),
        (EntryPtr:@ParseState91;	EdgeCnt:13),
        (EntryPtr:@ParseState92;	EdgeCnt:1),
        (EntryPtr:@ParseState93;	EdgeCnt:1),
        (EntryPtr:@ParseState94;	EdgeCnt:3),
        (EntryPtr:@ParseState95;	EdgeCnt:4),
        (EntryPtr:@ParseState96;	EdgeCnt:1),
        (EntryPtr:@ParseState97;	EdgeCnt:1),
        (EntryPtr:@ParseState98;	EdgeCnt:13),
        (EntryPtr:@ParseState99;	EdgeCnt:3),
        (EntryPtr:@ParseState100;	EdgeCnt:3),
        (EntryPtr:@ParseState101;	EdgeCnt:3),
        (EntryPtr:@ParseState102;	EdgeCnt:1),
        (EntryPtr:@ParseState103;	EdgeCnt:2),
        (EntryPtr:@ParseState104;	EdgeCnt:1),
        (EntryPtr:@ParseState105;	EdgeCnt:1),
        (EntryPtr:@ParseState106;	EdgeCnt:2),
        (EntryPtr:@ParseState107;	EdgeCnt:26),
        (EntryPtr:@ParseState108;	EdgeCnt:1),
        (EntryPtr:@ParseState109;	EdgeCnt:26),
        (EntryPtr:@ParseState110;	EdgeCnt:18),
        (EntryPtr:@ParseState111;	EdgeCnt:26),
        (EntryPtr:@ParseState112;	EdgeCnt:9),
        (EntryPtr:@ParseState113;	EdgeCnt:15),
        (EntryPtr:@ParseState114;	EdgeCnt:15),
        (EntryPtr:@ParseState115;	EdgeCnt:16),
        (EntryPtr:@ParseState116;	EdgeCnt:16),
        (EntryPtr:@ParseState117;	EdgeCnt:16),
        (EntryPtr:@ParseState118;	EdgeCnt:16),
        (EntryPtr:@ParseState119;	EdgeCnt:16),
        (EntryPtr:@ParseState120;	EdgeCnt:16),
        (EntryPtr:@ParseState121;	EdgeCnt:15),
        (EntryPtr:@ParseState122;	EdgeCnt:14),
        (EntryPtr:@ParseState123;	EdgeCnt:14),
        (EntryPtr:@ParseState124;	EdgeCnt:14),
        (EntryPtr:@ParseState125;	EdgeCnt:14),
        (EntryPtr:@ParseState126;	EdgeCnt:14),
        (EntryPtr:@ParseState127;	EdgeCnt:17),
        (EntryPtr:@ParseState128;	EdgeCnt:3),
        (EntryPtr:@ParseState129;	EdgeCnt:1),
        (EntryPtr:@ParseState130;	EdgeCnt:18),
        (EntryPtr:@ParseState131;	EdgeCnt:17),
        (EntryPtr:@ParseState132;	EdgeCnt:21),
        (EntryPtr:@ParseState133;	EdgeCnt:2),
        (EntryPtr:@ParseState134;	EdgeCnt:30),
        (EntryPtr:@ParseState135;	EdgeCnt:4),
        (EntryPtr:@ParseState136;	EdgeCnt:1),
        (EntryPtr:@ParseState137;	EdgeCnt:1),
        (EntryPtr:@ParseState138;	EdgeCnt:3),
        (EntryPtr:@ParseState139;	EdgeCnt:9),
        (EntryPtr:@ParseState140;	EdgeCnt:13),
        (EntryPtr:@ParseState141;	EdgeCnt:2),
        (EntryPtr:@ParseState142;	EdgeCnt:1),
        (EntryPtr:@ParseState143;	EdgeCnt:1),
        (EntryPtr:@ParseState144;	EdgeCnt:6),
        (EntryPtr:@ParseState145;	EdgeCnt:5),
        (EntryPtr:@ParseState146;	EdgeCnt:1),
        (EntryPtr:@ParseState147;	EdgeCnt:5),
        (EntryPtr:@ParseState148;	EdgeCnt:1),
        (EntryPtr:@ParseState149;	EdgeCnt:1),
        (EntryPtr:@ParseState150;	EdgeCnt:3),
        (EntryPtr:@ParseState151;	EdgeCnt:1),
        (EntryPtr:@ParseState152;	EdgeCnt:3),
        (EntryPtr:@ParseState153;	EdgeCnt:1),
        (EntryPtr:@ParseState154;	EdgeCnt:26),
        (EntryPtr:@ParseState155;	EdgeCnt:1),
        (EntryPtr:@ParseState156;	EdgeCnt:2),
        (EntryPtr:@ParseState157;	EdgeCnt:1),
        (EntryPtr:@ParseState158;	EdgeCnt:2),
        (EntryPtr:@ParseState159;	EdgeCnt:1),
        (EntryPtr:@ParseState160;	EdgeCnt:26),
        (EntryPtr:@ParseState161;	EdgeCnt:26),
        (EntryPtr:@ParseState162;	EdgeCnt:15),
        (EntryPtr:@ParseState163;	EdgeCnt:15),
        (EntryPtr:@ParseState164;	EdgeCnt:15),
        (EntryPtr:@ParseState165;	EdgeCnt:15),
        (EntryPtr:@ParseState166;	EdgeCnt:15),
        (EntryPtr:@ParseState167;	EdgeCnt:15),
        (EntryPtr:@ParseState168;	EdgeCnt:26),
        (EntryPtr:@ParseState169;	EdgeCnt:26),
        (EntryPtr:@ParseState170;	EdgeCnt:26),
        (EntryPtr:@ParseState171;	EdgeCnt:26),
        (EntryPtr:@ParseState172;	EdgeCnt:26),
        (EntryPtr:@ParseState173;	EdgeCnt:26),
        (EntryPtr:@ParseState174;	EdgeCnt:2),
        (EntryPtr:@ParseState175;	EdgeCnt:18),
        (EntryPtr:@ParseState176;	EdgeCnt:4),
        (EntryPtr:@ParseState177;	EdgeCnt:1),
        (EntryPtr:@ParseState178;	EdgeCnt:4),
        (EntryPtr:@ParseState179;	EdgeCnt:4),
        (EntryPtr:@ParseState180;	EdgeCnt:30),
        (EntryPtr:@ParseState181;	EdgeCnt:3),
        (EntryPtr:@ParseState182;	EdgeCnt:2),
        (EntryPtr:@ParseState183;	EdgeCnt:1),
        (EntryPtr:@ParseState184;	EdgeCnt:2),
        (EntryPtr:@ParseState185;	EdgeCnt:1),
        (EntryPtr:@ParseState186;	EdgeCnt:3),
        (EntryPtr:@ParseState187;	EdgeCnt:4),
        (EntryPtr:@ParseState188;	EdgeCnt:3),
        (EntryPtr:@ParseState189;	EdgeCnt:13),
        (EntryPtr:@ParseState190;	EdgeCnt:3),
        (EntryPtr:@ParseState191;	EdgeCnt:4),
        (EntryPtr:@ParseState192;	EdgeCnt:2),
        (EntryPtr:@ParseState193;	EdgeCnt:2),
        (EntryPtr:@ParseState194;	EdgeCnt:1),
        (EntryPtr:@ParseState195;	EdgeCnt:1),
        (EntryPtr:@ParseState196;	EdgeCnt:13),
        (EntryPtr:@ParseState197;	EdgeCnt:7),
        (EntryPtr:@ParseState198;	EdgeCnt:3),
        (EntryPtr:@ParseState199;	EdgeCnt:3),
        (EntryPtr:@ParseState200;	EdgeCnt:26),
        (EntryPtr:@ParseState201;	EdgeCnt:9),
        (EntryPtr:@ParseState202;	EdgeCnt:4),
        (EntryPtr:@ParseState203;	EdgeCnt:7),
        (EntryPtr:@ParseState204;	EdgeCnt:19),
        (EntryPtr:@ParseState205;	EdgeCnt:17),
        (EntryPtr:@ParseState206;	EdgeCnt:17),
        (EntryPtr:@ParseState207;	EdgeCnt:2),
        (EntryPtr:@ParseState208;	EdgeCnt:21),
        (EntryPtr:@ParseState209;	EdgeCnt:6),
        (EntryPtr:@ParseState210;	EdgeCnt:9),
        (EntryPtr:@ParseState211;	EdgeCnt:1),
        (EntryPtr:@ParseState212;	EdgeCnt:1),
        (EntryPtr:@ParseState213;	EdgeCnt:2),
        (EntryPtr:@ParseState214;	EdgeCnt:1),
        (EntryPtr:@ParseState215;	EdgeCnt:5),
        (EntryPtr:@ParseState216;	EdgeCnt:2),
        (EntryPtr:@ParseState217;	EdgeCnt:13),
        (EntryPtr:@ParseState218;	EdgeCnt:1),
        (EntryPtr:@ParseState219;	EdgeCnt:1),
        (EntryPtr:@ParseState220;	EdgeCnt:1),
        (EntryPtr:@ParseState221;	EdgeCnt:2),
        (EntryPtr:@ParseState222;	EdgeCnt:1),
        (EntryPtr:@ParseState223;	EdgeCnt:1),
        (EntryPtr:@ParseState224;	EdgeCnt:4),
        (EntryPtr:@ParseState225;	EdgeCnt:2),
        (EntryPtr:@ParseState226;	EdgeCnt:1),
        (EntryPtr:@ParseState227;	EdgeCnt:13),
        (EntryPtr:@ParseState228;	EdgeCnt:13),
        (EntryPtr:@ParseState229;	EdgeCnt:1),
        (EntryPtr:@ParseState230;	EdgeCnt:2),
        (EntryPtr:@ParseState231;	EdgeCnt:7),
        (EntryPtr:@ParseState232;	EdgeCnt:21),
        (EntryPtr:@ParseState233;	EdgeCnt:21),
        (EntryPtr:@ParseState234;	EdgeCnt:3),
        (EntryPtr:@ParseState235;	EdgeCnt:2),
        (EntryPtr:@ParseState236;	EdgeCnt:4),
        (EntryPtr:@ParseState237;	EdgeCnt:4),
        (EntryPtr:Nil; EdgeCnt:0 ));  
const ReduceTable: packed array [0..112] of record Cnt:Byte; Tag:TTokenTag; end = (
    {  0} (Cnt:1; Tag:76),	//CONSTANT_DECLITERAL,
    {  1} (Cnt:1; Tag:76),	//CONSTANT_STRINGLITERAL,
    {  2} (Cnt:1; Tag:76),	//CONSTANT_FLOATLITERAL,
    {  3} (Cnt:1; Tag:76),	//CONSTANT_HEXLITERAL,
    {  4} (Cnt:1; Tag:76),	//CONSTANT_CHARLITERAL,
    {  5} (Cnt:4; Tag:98),	//PROGRAM_DOT,
    {  6} (Cnt:3; Tag:99),	//PROGRAMHEADER_PROGRAM_ID_SEMI,
    {  7} (Cnt:6; Tag:99),	//PROGRAMHEADER_PROGRAM_ID_LPARAN_RPARAN_SEMI,
    {  8} (Cnt:4; Tag:81),	//DECLARATIONS,
    {  9} (Cnt:2; Tag:79),	//CONSTANTDEFINITIONS_CONST,
    { 10} (Cnt:0; Tag:79),	//CONSTANTDEFINITIONS,
    { 11} (Cnt:1; Tag:78),	//CONSTANTDEFINITIONLIST,
    { 12} (Cnt:2; Tag:78),	//CONSTANTDEFINITIONLIST2,
    { 13} (Cnt:4; Tag:77),	//CONSTANTDEF_ID_EQ_SEMI,
    { 14} (Cnt:2; Tag:107),	//TYPEDEFINITIONS_TYPE,
    { 15} (Cnt:0; Tag:107),	//TYPEDEFINITIONS,
    { 16} (Cnt:1; Tag:106),	//TYPEDEFINITIONLIST,
    { 17} (Cnt:2; Tag:106),	//TYPEDEFINITIONLIST2,
    { 18} (Cnt:4; Tag:105),	//TYPEDEF_ID_EQ_SEMI,
    { 19} (Cnt:2; Tag:112),	//VARIABLEDECLARATIONS_VAR,
    { 20} (Cnt:0; Tag:112),	//VARIABLEDECLARATIONS,
    { 21} (Cnt:1; Tag:111),	//VARIABLEDECLARATIONLIST,
    { 22} (Cnt:2; Tag:111),	//VARIABLEDECLARATIONLIST2,
    { 23} (Cnt:4; Tag:110),	//VARIABLEDEC_COLON_SEMI,
    { 24} (Cnt:2; Tag:96),	//PROCEDUREDECLARATIONS,
    { 25} (Cnt:0; Tag:96),	//PROCEDUREDECLARATIONS2,
    { 26} (Cnt:3; Tag:95),	//PROCEDUREDEC_FORWARD_SEMI,
    { 27} (Cnt:4; Tag:95),	//PROCEDUREDEC_SEMI,
    { 28} (Cnt:3; Tag:95),	//PROCEDUREDEC_FORWARD_SEMI2,
    { 29} (Cnt:4; Tag:95),	//PROCEDUREDEC_SEMI2,
    { 30} (Cnt:4; Tag:97),	//PROCEDUREHEADER_PROCEDURE_ID_SEMI,
    { 31} (Cnt:6; Tag:91),	//FUNCTIONHEADER_FUNCTION_ID_COLON_SEMI,
    { 32} (Cnt:3; Tag:70),	//ARGUMENTS_LPARAN_RPARAN,
    { 33} (Cnt:0; Tag:70),	//ARGUMENTS,
    { 34} (Cnt:1; Tag:69),	//ARGUMENTLIST,
    { 35} (Cnt:3; Tag:69),	//ARGUMENTLIST_SEMI,
    { 36} (Cnt:3; Tag:68),	//ARG_COLON,
    { 37} (Cnt:4; Tag:68),	//ARG_VAR_COLON,
    { 38} (Cnt:3; Tag:75),	//COMPOUNDSTATEMENT_BEGIN_END,
    { 39} (Cnt:1; Tag:103),	//STATEMENTLIST,
    { 40} (Cnt:3; Tag:103),	//STATEMENTLIST_SEMI,
    { 41} (Cnt:1; Tag:102),	//STATEMENT,
    { 42} (Cnt:1; Tag:102),	//STATEMENT2,
    { 43} (Cnt:1; Tag:102),	//STATEMENT3,
    { 44} (Cnt:1; Tag:102),	//STATEMENT4,
    { 45} (Cnt:1; Tag:102),	//STATEMENT5,
    { 46} (Cnt:1; Tag:102),	//STATEMENT6,
    { 47} (Cnt:1; Tag:102),	//STATEMENT7,
    { 48} (Cnt:1; Tag:102),	//STATEMENT8,
    { 49} (Cnt:0; Tag:102),	//STATEMENT9,
    { 50} (Cnt:3; Tag:71),	//ASSIGNMENTSTATEMENT_COLONEQ,
    { 51} (Cnt:2; Tag:94),	//PROCEDURECALL_ID,
    { 52} (Cnt:8; Tag:89),	//FORSTATEMENT_FOR_ID_COLONEQ_TO_DO,
    { 53} (Cnt:8; Tag:89),	//FORSTATEMENT_FOR_ID_COLONEQ_DOWNTO_DO,
    { 54} (Cnt:4; Tag:113),	//WHILESTATEMENT_WHILE_DO,
    { 55} (Cnt:6; Tag:93),	//IFSTATEMENT_IF_THEN_ELSE,
    { 56} (Cnt:4; Tag:100),	//REPEATSTATEMENT_REPEAT_UNTIL,
    { 57} (Cnt:5; Tag:74),	//CASESTATEMENT_CASE_OF_END,
    { 58} (Cnt:1; Tag:73),	//CASELIST,
    { 59} (Cnt:3; Tag:73),	//CASELIST_SEMI,
    { 60} (Cnt:3; Tag:72),	//CASE_COLON,
    { 61} (Cnt:1; Tag:80),	//CONSTANTLIST,
    { 62} (Cnt:3; Tag:80),	//CONSTANTLIST_COMMA,
    { 63} (Cnt:1; Tag:84),	//EXPRESSION,
    { 64} (Cnt:3; Tag:84),	//EXPRESSION_EQ,
    { 65} (Cnt:3; Tag:84),	//EXPRESSION_LTGT,
    { 66} (Cnt:3; Tag:84),	//EXPRESSION_LT,
    { 67} (Cnt:3; Tag:84),	//EXPRESSION_LTEQ,
    { 68} (Cnt:3; Tag:84),	//EXPRESSION_GT,
    { 69} (Cnt:3; Tag:84),	//EXPRESSION_GTEQ,
    { 70} (Cnt:1; Tag:101),	//SIMPLEEXPRESSION,
    { 71} (Cnt:3; Tag:101),	//SIMPLEEXPRESSION_PLUS,
    { 72} (Cnt:3; Tag:101),	//SIMPLEEXPRESSION_MINUS,
    { 73} (Cnt:3; Tag:101),	//SIMPLEEXPRESSION_OR,
    { 74} (Cnt:1; Tag:104),	//TERM,
    { 75} (Cnt:3; Tag:104),	//TERM_TIMES,
    { 76} (Cnt:3; Tag:104),	//TERM_DIV,
    { 77} (Cnt:3; Tag:104),	//TERM_DIV2,
    { 78} (Cnt:3; Tag:104),	//TERM_MOD,
    { 79} (Cnt:3; Tag:104),	//TERM_AND,
    { 80} (Cnt:3; Tag:86),	//FACTOR_LPARAN_RPARAN,
    { 81} (Cnt:2; Tag:86),	//FACTOR_PLUS,
    { 82} (Cnt:2; Tag:86),	//FACTOR_MINUS,
    { 83} (Cnt:2; Tag:86),	//FACTOR_NOT,
    { 84} (Cnt:1; Tag:86),	//FACTOR,
    { 85} (Cnt:1; Tag:86),	//FACTOR2,
    { 86} (Cnt:1; Tag:86),	//FACTOR3,
    { 87} (Cnt:4; Tag:90),	//FUNCTIONCALL_ID_LPARAN_RPARAN,
    { 88} (Cnt:3; Tag:67),	//ACTUALS_LPARAN_RPARAN,
    { 89} (Cnt:0; Tag:67),	//ACTUALS,
    { 90} (Cnt:1; Tag:85),	//EXPRESSIONLIST,
    { 91} (Cnt:3; Tag:85),	//EXPRESSIONLIST_COMMA,
    { 92} (Cnt:1; Tag:109),	//VARIABLE_ID,
    { 93} (Cnt:3; Tag:109),	//VARIABLE_DOT_ID,
    { 94} (Cnt:2; Tag:109),	//VARIABLE_CARET,
    { 95} (Cnt:4; Tag:109),	//VARIABLE_LBRACKET_RBRACKET,
    { 96} (Cnt:1; Tag:108),	//TYPESPECIFIER_ID,
    { 97} (Cnt:2; Tag:108),	//TYPESPECIFIER_CARET,
    { 98} (Cnt:3; Tag:108),	//TYPESPECIFIER_LPARAN_RPARAN,
    { 99} (Cnt:3; Tag:108),	//TYPESPECIFIER_DOTDOT,
    {100} (Cnt:6; Tag:108),	//TYPESPECIFIER_ARRAY_LBRACKET_RBRACKET_OF,
    {101} (Cnt:3; Tag:108),	//TYPESPECIFIER_RECORD_END,
    {102} (Cnt:3; Tag:108),	//TYPESPECIFIER_FILE_OF,
    {103} (Cnt:1; Tag:83),	//DIMENSIONLIST,
    {104} (Cnt:3; Tag:83),	//DIMENSIONLIST_COMMA,
    {105} (Cnt:3; Tag:82),	//DIMENSION_DOTDOT,
    {106} (Cnt:1; Tag:82),	//DIMENSION_ID,
    {107} (Cnt:1; Tag:88),	//FIELDLIST,
    {108} (Cnt:3; Tag:88),	//FIELDLIST_SEMI,
    {109} (Cnt:3; Tag:87),	//FIELD_COLON,
    {110} (Cnt:1; Tag:92),	//IDLIST_ID,
    {111} (Cnt:3; Tag:92),	//IDLIST_ID_COMMA,
    {112} (Cnt:0; Tag:ActError)
  );
  {}
  {}   
  {...........................................................................}
  procedure DebugStacks;
  {...........................................................................}
  var S:PState; T:PToken; N0,N1,k:Integer;
  begin
    S:=StateStack; N1:=1;
    while S<>StateStackTop do begin inc(S); inc(N1); end;
    if N1>12 then N0:=N1-12 else N0:=1;
    S:=StateStack; for k:=2 to N0 do inc(S);
    T:=TokenStack; for k:=2 to N0 do inc(T);
    write(Fo^,'  StateStack[',N0:1,'..',N1:1,']=[',S^:3);
    for k:=N0+1 to N1 do begin inc(S); write(Fo^,',',S^:3); end;
    writeln(Fo^,']');
    write(Fo^,'  TokenStack[',N0:1,'..',N1:1,']=[',T^.Tag:3);
    for k:=N0+1 to N1 do begin inc(T); write(Fo^,',',T^.Tag:3); end;
    writeln(Fo^,']');
  end;
  {} 
  {...........................................................................}
  function GetParseEdge(Tag:TTokenTag):PParseEdge;
  {...........................................................................}
  // returns the transition to a next state, or last tarnsition of an EdgeList
  var EdgePtr:PParseEdge; k:Integer;
  begin
    EdgePtr :=ParseStateList[StateStackTop^].EntryPtr;
    for k:=1 to ParseStateList[StateStackTop^].EdgeCnt do begin
      if (EdgePtr^.Tag=Tag) then break;
      inc(EdgePtr);
    end;  
    GetParseEdge:=EdgePtr;
  end;
  {}
  {...........................................................................}
  function GetExpect:TTokenTag;
  {...........................................................................}
  //inquire the parse tables, to identify what token was expected
  var EdgePtr:PParseEdge; Expect:TTokenTag; k,OK:Integer;
  begin
    OK:=0; Expect:=TagAny;
    EdgePtr :=ParseStateList[StateStackTop^].EntryPtr;
    for k:=1 to ParseStateList[StateStackTop^].EdgeCnt do begin
      if (EdgePtr^.Tag<>Tag_SynError) then begin
        //to do: give priority of ActReduce over ActShift/ActGoto
        inc(OK); Expect:=EdgePtr^.Tag;
      end;  
      inc(EdgePtr);
    end;
    if OK<>1 then Expect:=Token.Tag;
    GetExpect:=Expect;
  end;
  {}
  {...........................................................................}
  function HandleError:Boolean;
  {...........................................................................}
  var  EdgePtr:PParseEdge;  Invalidated:Integer;  NewError:Boolean;
  begin
    //[Step 1] check if previous repair has failed
    //NewError:=(HasShifted or (ErrorStatePtr<>StateStackTop) or (ErrorState<>StateStackTop^)); //??
    NewError:=HasShifted;
    Invalidated  := 0;
    HasShifted   := False;
    ErrorStatePtr:= StateStackTop;
    ErrorState   := StateStackTop^;    
    //[Step 2] report the error, if it is a new one
    if NewError then begin
      inc(ErrorCnt);
      if (ErrorCnt<=ErrorMax) then begin
        TokenStackTop^.Tag:=GetExpect;
        DoError(-StateStackTop^,TokenStackTop);
        TokenStackTop^.Tag:=Token.Tag;
      end else begin
        DoError(Err_Overflow, TokenStackTop);
        HandleError:=False;
        Exit;
      end;
    end;
    //[Step 3] remove processed tokens, until an error-token is found with a shift action
    repeat
      if (TokenStackTop=TokenStack) then begin
         DoError(Err_Halted,TokenStackTop);
         HandleError:=False;
         exit; //error unsolveable due to lack of adequate error production
      end;
      if NewError or (Invalidated>1) then begin
        EdgePtr:=GetParseEdge(Tag_SynError);
        if  (EdgePtr^.Tag<>TagAny) and (EdgePtr^.Act=ActShift) then break;
      end;
      DoCleanup(TokenStackTop);
      dec(TokenStackTop);
      dec(StateStackTop);
      inc(Invalidated);
    until false;
    //[Step 4] push error on the stack, with position info on the error
    TokenStackTop^.Tag:=Tag_SynError;
    //[Step 5] skip tokens, and push the first valid one on the stack
    inc(StateStackTop); StateStackTop^:=EdgePtr^.Q;
    inc(TokenStackTop); TokenStackTop^:=Token;
    while GetParseEdge(Token.Tag)^.Tag=TagAny do begin
      if Token.Tag=Tag_EOF then break;
      GetToken; HasShifted:=True;
      TokenStackTop^:=Token;
      inc(Invalidated);
    end;
    {$IFDEF Debug_ERRORS} if (Invalidated>0) then DoError(Err_Skipped,TokenStackTop); {$ENDIF}
    HandleError:=(Token.Tag<>Tag_EOF);
  end;
  {}
label ParseNext, ParseDone, ParseOverflow;
var   Cnt,RuleNr:Integer;
      EdgePtr:PParseEdge;
      TopToken:TToken;
begin
  GetToken; HasShifted:=True;
  ErrorState:=StartState;
  ErrorStatePtr:=Nil;
  GetMem(TokenStack, StackSize*sizeof(TokenStackTop^));
  GetMem(StateStack, StackSize*sizeof(StateStackTop^));
  TokenStackTop :=TokenStack;
  TokenStackTop^:=Token;
  StateStackTop :=StateStack;
  StateStackEnd :=StateStack; inc(StateStackEnd,StackSize-1);
  StateStackTop^:=StartState;
ParseNext: //Repeat
  if (StateStackTop=StateStackEnd) then goto ParseOverflow;
  {$IFDEF Debug_PARSER}
    DebugStacks;
    write (Fo^,'      (State=', StateStackTop^:2,', Tag=',TokenStackTop^.Tag:2,' ==> ');
  {$ENDIF}
  EdgePtr:=GetParseEdge(TokenStackTop^.Tag);
  case EdgePtr^.Act of
    ActError:
       begin {invalidate several tokens, in an attempt to recover from this error}
         {$IFDEF Debug_PARSER} writeln(Fo^,'Error)'); {$ENDIF}
         //first reduce to the highest rule, before handling the error
         EdgePtr:=GetParseEdge(Tag_SynError);
         if (EdgePtr^.Tag<>TagAny) and (EdgePtr^.Act<>1) then begin
           TokenStackTop^.Tag:=Tag_SynError;
           goto ParseNext;
         end;
         if HandleError then goto ParseNext else goto ParseDone;
       end;
    ActShift:
       begin {read and push another token on the stack, and analyze again }
         {$IFDEF Debug_PARSER} writeln(Fo^,'Q=', EdgePtr^.Q:2,', Shift)'); {$ENDIF}
         GetToken; HasShifted:=True;
         inc(StateStackTop); StateStackTop^:=EdgePtr^.Q;
         inc(TokenStackTop); TokenStackTop^:=Token;
         goto ParseNext;
       end;
    ActReduce: 
       begin {replace several tokens, by a single one, representing a rule}
         {$IFDEF Debug_PARSER} write (Fo^,'Q=', EdgePtr^.Q:2,', Reduce'); {$ENDIF}
         RuleNr:=EdgePtr^.Q;
         Cnt:=ReduceTable[RuleNr].Cnt;
         dec(TokenStackTop,Cnt);
         dec(StateStackTop,Cnt);
         {$IFDEF  Debug_PARSER} WriteLn(Fo^,'By ',Cnt,')'); {$ENDIF}
         DoAction(PTokenList(TokenStackTop), RuleNr, Cnt);
         TokenStackTop^.Tag:=ReduceTable[RuleNr].Tag;
         TokenStackTop^.Kind:=0; //flag this token as a "non-terminal" token
         goto ParseNext;
       end;
    ActNext: 
       begin {analyze again, but now from another state}
         {$IFDEF Debug_PARSER} writeln(Fo^,'Q=', EdgePtr^.Q:2,', Next)'); {$ENDIF}
         inc(StateStackTop); StateStackTop^:=EdgePtr^.Q;
         inc(TokenStackTop); TokenStackTop^:=Token;
         goto ParseNext;
       end;
    ActAccept:
         begin {startsymbol found, all parsing can be finished}
         {$IFDEF Debug_PARSER} writeln(Fo^,'Q=', EdgePtr^.Q:2,', Accept)'); {$ENDIF}
         dec(TokenStackTop);
         dec(StateStackTop);
         goto ParseDone;
       end;
  end {case};
ParseOverflow:
  DoError(Err_StackOverflow,Nil);
  inc(ErrorCnt);
ParseDone:
  while (TokenStackTop<>TokenStack) do begin //clean up
    DoCleanup(TokenStackTop);
    dec(TokenStackTop);
  end;
  TopToken:=TokenStackTop^;
  FreeMem(TokenStack, StackSize*sizeof(TokenStackTop^));
  FreeMem(StateStack, StackSize*sizeof(StateStackTop^));
  if (ErrorCnt=0) then DoAccept(@TopToken);
  {$IFDEF Debug_HEAPMEM} ShowMem('MemUsage, at Parse accept'); {$ENDIF}
  DoCleanup(@TopToken);
  {$IFDEF Debug_HEAPMEM} ShowMem('MemUsage, at Parse finish'); {$ENDIF}
  DoParse:=ErrorCnt;
end; {TParser.DoParse}




var Parser:TParser;
    ErrorCnt:Integer;
begin
  if ParamCount=0 then begin
    Writeln(' Usage:   PasParse Infile ');
    Writeln(' Usage:   PasParse Infile OutFile');
    Writeln(' Usage:   PasParse Infile OutFile ErrFile');
    exit;
  end else
  if ParamCount>=1 then begin
    Fo:=@OutPut; Fe:=@OutPut; Parser.Init(ParamStr(1)); 
    WriteLn('Parsing: "',ParamStr(1),'"');
  end;
  if ParamCount>=2 then begin
    new(Fo); assign(Fo^,ParamStr(2)); rewrite(Fo^);
  end;
  if ParamCount>=3 then begin
    New(Fe); assign(Fe^,ParamStr(3)); rewrite(Fe^);
  end;
  ErrorCnt:=Parser.DoParse(1000);
  Parser.Done;
  if ErrorCnt=0
  then write('done <SUCCES>, hit <return> :=')
  else write('done <FAILED> with ',ErrorCnt,' errors, hit <return> :=');
  {if ErrorCnt>0 then} readln;
  if ParamCount>=3 then begin close(Fe^); dispose(Fe); end;
  if ParamCount>=2 then begin close(Fo^); dispose(Fo); end;
end.
