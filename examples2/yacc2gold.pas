Program yacc2gold;

//---<This file is auto generated by GoldParser>-------------------------------
// Pascal_Engine.pgt, Version 1.1, Aug 2006
// (c) Rob F.M. van den Brink, the Netherlands, R.F.M.vandenBrink@hccnet.nl
//-----------------------------------------------------------------------------
  {$UNDEF  IsDELPHI       //define to compile with Delphi specific needs}
  {$UNDEF  IsNESTED       //define to nest comment blocks within comments}
//-----------------------------------------------------------------------------
  {$UNDEF  Debug_LEXER    //define if lexer  (DFA) are to be dumped to screen} 
  {$UNDEF  Debug_LEXEMES  //define if lexemes are to be dumped, before they are tokenized}
  {$UNDEF  Debug_TOKENS   //define if tokenized lexemes are to be dumped} 
  {$UNDEF  Debug_PARSER   //define if parser (LALR) states are to be dumped} 
  {$UNDEF  Debug_ACTIONS  //define if called actions are to be dumped } 
  {$UNDEF  Debug_TREE     //define if the nodes of the tree should be dumped to screen } 
  {$DEFINE Debug_ERRORS   //undefine if not used} 
  {$UNDEF  Debug_HEAPMEM  //define if status of memory heap is to be reported} 
//-----------------------------------------------------------------------------


{$IFDEF IsDELPHI} {$APPTYPE CONSOLE} {$ENDIF}

const Tab=chr(9); LF=Chr(10); CR=Chr(13);  FF=Chr(12); EOF=Chr(26);

//-----------------------------------------------------------------------------
// ERROR TAGS
//-----------------------------------------------------------------------------
const Err_Lexeme        = 1;
      Err_Skipped       = 2; 
      Err_Halted	= 3;
      Err_Overflow      = 4;
      Err_StackOverflow = 5;

//-----------------------------------------------------------------------------
// TOKEN TAGS
//-----------------------------------------------------------------------------
const TagCount = 50;
      Tag_EOF            =  0;   // Kind=3;  Lex='(EOF)';  
      Tag_ERROR          =  1;   // Kind=7;  Lex='(Error)';  
      Tag_WHITESPACE     =  2;   // Kind=2;  Lex='(Whitespace)';  
      Tag_COMMENTEND     =  3;   // Kind=5;  Lex='(Comment End)';  
      Tag_COMMENTLINE    =  4;   // Kind=6;  Lex='(Comment Line)';  
      Tag_COMMENTSTART   =  5;   // Kind=4;  Lex='(Comment Start)';  
      Tag_PERCENTPERCENT =  6;   // Kind=1;  Lex='%%';  
      Tag_PERCENTBINARY  =  7;   // Kind=1;  Lex='%binary';  
      Tag_PERCENTEXPECT  =  8;   // Kind=1;  Lex='%expect';  
      Tag_PERCENTLEFT    =  9;   // Kind=1;  Lex='%left';  
      Tag_PERCENTNONASSOC= 10;   // Kind=1;  Lex='%nonassoc';  
      Tag_PERCENTPREC    = 11;   // Kind=1;  Lex='%prec';  
      Tag_PERCENTRIGHT   = 12;   // Kind=1;  Lex='%right';  
      Tag_PERCENTSTART   = 13;   // Kind=1;  Lex='%start';  
      Tag_PERCENTTOKEN   = 14;   // Kind=1;  Lex='%token';  
      Tag_PERCENTTYPE    = 15;   // Kind=1;  Lex='%type';  
      Tag_PERCENTUNION   = 16;   // Kind=1;  Lex='%union';  
      Tag_COMMA          = 17;   // Kind=1;  Lex=',';  
      Tag_COLON          = 18;   // Kind=1;  Lex=':';  
      Tag_SEMI           = 19;   // Kind=1;  Lex=';';  
      Tag_PIPE           = 20;   // Kind=1;  Lex='|';  
      Tag_LT             = 21;   // Kind=1;  Lex='<';  
      Tag_EQ             = 22;   // Kind=1;  Lex='=';  
      Tag_GT             = 23;   // Kind=1;  Lex='>';  
      Tag_ACTION         = 24;   // Kind=1;  Lex='Action';  
      Tag_COMMENTEND1    = 25;   // Kind=1;  Lex='CommentEnd1';  
      Tag_COMMENTEND2    = 26;   // Kind=1;  Lex='CommentEnd2';  
      Tag_COMMENTSTART1  = 27;   // Kind=1;  Lex='CommentStart1';  
      Tag_COMMENTSTART2  = 28;   // Kind=1;  Lex='CommentStart2';  
      Tag_DECLARATIONCODE= 29;   // Kind=1;  Lex='DeclarationCode';  
      Tag_IDENTIFIER     = 30;   // Kind=1;  Lex='Identifier';  
      Tag_LBRACE         = 31;   // Kind=1;  Lex='LBrace';  
      Tag_LITERAL        = 32;   // Kind=1;  Lex='Literal';  
      Tag_NUMBER         = 33;   // Kind=1;  Lex='Number';  
      Tag_RULENAME       = 34;   // Kind=1;  Lex='RuleName';  
      Tag_SYNERROR       = 35;   // Kind=1;  Lex='SynError';  
      Tag_ENDMARKEROPT   = 36;   // Kind=0;  Lex='<End Marker Opt>';  
      Tag_ITEM           = 37;   // Kind=0;  Lex='<Item>';  
      Tag_ITEMLIST       = 38;   // Kind=0;  Lex='<ItemList>';  
      Tag_RULE           = 39;   // Kind=0;  Lex='<Rule>';  
      Tag_RULEBODY       = 40;   // Kind=0;  Lex='<RuleBody>';  
      Tag_RULEHEAD       = 41;   // Kind=0;  Lex='<RuleHead>';  
      Tag_RULEOPT        = 42;   // Kind=0;  Lex='<RuleOpt>';  
      Tag_RULES          = 43;   // Kind=0;  Lex='<Rules>';  
      Tag_SYMBOL         = 44;   // Kind=0;  Lex='<Symbol>';  
      Tag_SYMBOLS        = 45;   // Kind=0;  Lex='<Symbols>';  
      Tag_TOKEN          = 46;   // Kind=0;  Lex='<Token>';  
      Tag_TOKENS         = 47;   // Kind=0;  Lex='<Tokens>';  
      Tag_UNIONNAMEOPT   = 48;   // Kind=0;  Lex='<Union Name Opt>';  
      Tag_YACCGRAMMAR    = 49;   // Kind=0;  Lex='<YACC Grammar>';  
      TagAny = 50;

      //the length evaluation is a bit clumsy, but GoldParser offers no alternative
      Lex_0: string[length('(EOF)')] ='(EOF)';
      Lex_1: string[length('(Error)')] ='(Error)';
      Lex_2: string[length('(Whitespace)')] ='(Whitespace)';
      Lex_3: string[length('(Comment End)')] ='(Comment End)';
      Lex_4: string[length('(Comment Line)')] ='(Comment Line)';
      Lex_5: string[length('(Comment Start)')] ='(Comment Start)';
      Lex_6: string[length('%%')] ='%%';
      Lex_7: string[length('%binary')] ='%binary';
      Lex_8: string[length('%expect')] ='%expect';
      Lex_9: string[length('%left')] ='%left';
      Lex_10: string[length('%nonassoc')] ='%nonassoc';
      Lex_11: string[length('%prec')] ='%prec';
      Lex_12: string[length('%right')] ='%right';
      Lex_13: string[length('%start')] ='%start';
      Lex_14: string[length('%token')] ='%token';
      Lex_15: string[length('%type')] ='%type';
      Lex_16: string[length('%union')] ='%union';
      Lex_17: string[length(',')] =',';
      Lex_18: string[length(':')] =':';
      Lex_19: string[length(';')] =';';
      Lex_20: string[length('|')] ='|';
      Lex_21: string[length('<')] ='<';
      Lex_22: string[length('=')] ='=';
      Lex_23: string[length('>')] ='>';
      Lex_24: string[length('Action')] ='Action';
      Lex_25: string[length('CommentEnd1')] ='CommentEnd1';
      Lex_26: string[length('CommentEnd2')] ='CommentEnd2';
      Lex_27: string[length('CommentStart1')] ='CommentStart1';
      Lex_28: string[length('CommentStart2')] ='CommentStart2';
      Lex_29: string[length('DeclarationCode')] ='DeclarationCode';
      Lex_30: string[length('Identifier')] ='Identifier';
      Lex_31: string[length('LBrace')] ='LBrace';
      Lex_32: string[length('Literal')] ='Literal';
      Lex_33: string[length('Number')] ='Number';
      Lex_34: string[length('RuleName')] ='RuleName';
      Lex_35: string[length('SynError')] ='SynError';
      Lex_36: string[length('<End Marker Opt>')] ='<End Marker Opt>';
      Lex_37: string[length('<Item>')] ='<Item>';
      Lex_38: string[length('<ItemList>')] ='<ItemList>';
      Lex_39: string[length('<Rule>')] ='<Rule>';
      Lex_40: string[length('<RuleBody>')] ='<RuleBody>';
      Lex_41: string[length('<RuleHead>')] ='<RuleHead>';
      Lex_42: string[length('<RuleOpt>')] ='<RuleOpt>';
      Lex_43: string[length('<Rules>')] ='<Rules>';
      Lex_44: string[length('<Symbol>')] ='<Symbol>';
      Lex_45: string[length('<Symbols>')] ='<Symbols>';
      Lex_46: string[length('<Token>')] ='<Token>';
      Lex_47: string[length('<Tokens>')] ='<Tokens>';
      Lex_48: string[length('<Union Name Opt>')] ='<Union Name Opt>';
      Lex_49: string[length('<YACC Grammar>')] ='<YACC Grammar>';
      Lex_50: string[7] ='<:ANY:>';
        

      LexTable : array[0..50] of ^String = (
      @Lex_0,
      @Lex_1,
      @Lex_2,
      @Lex_3,
      @Lex_4,
      @Lex_5,
      @Lex_6,
      @Lex_7,
      @Lex_8,
      @Lex_9,
      @Lex_10,
      @Lex_11,
      @Lex_12,
      @Lex_13,
      @Lex_14,
      @Lex_15,
      @Lex_16,
      @Lex_17,
      @Lex_18,
      @Lex_19,
      @Lex_20,
      @Lex_21,
      @Lex_22,
      @Lex_23,
      @Lex_24,
      @Lex_25,
      @Lex_26,
      @Lex_27,
      @Lex_28,
      @Lex_29,
      @Lex_30,
      @Lex_31,
      @Lex_32,
      @Lex_33,
      @Lex_34,
      @Lex_35,
      @Lex_36,
      @Lex_37,
      @Lex_38,
      @Lex_39,
      @Lex_40,
      @Lex_41,
      @Lex_42,
      @Lex_43,
      @Lex_44,
      @Lex_45,
      @Lex_46,
      @Lex_47,
      @Lex_48,
      @Lex_49,
      @Lex_50);

type  TTokenTag    = 0..TagCount;
      PTokenTree   = ^TTokenTree;
      TToken       = record 
                       Tag:TTokenTag; 
                       LinePos, CharPos:Integer; 
                       case Kind:Byte of
                        1: (Lex:^String);
                        0: (Lnk:PTokenTree); 
                       end;

      PToken       = ^TToken;
      TTokenList   = array [1..100] of TToken;
      PTokenList   = ^TTokenList;
      TTokenTree   = record Rule:Integer; Cnt:Byte; Tok:TTokenList; end;
      PText        = ^Text;

var   Fo,Fe:PText;

//-----------------------------------------------------------------------------
// OBJECTS (SCANNER,LEXER,PARSER)
//-----------------------------------------------------------------------------
Type
  TScanner = object
    Fi:Text;
    CurChar:    Char;
    NextChar:   Char;
    procedure   Get; virtual;
    constructor Init(FileName:String); 
    destructor  Done; Virtual;
  end;  

  
  TLexer=object(TScanner)
    ErrorMax:   Integer;
    ErrorCnt:   Integer;
    LinePos:	Integer;
    CharPos:	Integer;
    LexemeLen:  Integer;
    LexemeStr:  String;
    Token:      TToken;
    Mode:       Integer;
    constructor Init(FileName:String); 
    procedure   GetChar; 
    procedure   GetLine; 
    procedure   GetToken; virtual;
    procedure   GetComment(TagCommentStart,TagCommentEnd:Integer);
    function    GetLexeme (SkipMode:Boolean):Integer; 
    procedure   GetAction;
    procedure   DoError   (ErrorNr:Integer; TokenPtr: PToken);
  end;

  
  PParser = ^TParser;
  TParser = object(TLexer)
    constructor Init(InFile:String);
    destructor  Done; virtual;
    Procedure   DoAction (T:PTokenList; RuleNr,TokenCnt:Integer);
    procedure   DoAccept (TokenPtr: PToken);
    Procedure   DoCleanup(TokenPtr: PToken);
    function    DoParse  (StackSize:Integer):Integer;
    // the rules below are auto-generated from the grammar: 'YACC' 
    Function    TreeBuild  (T:PTokenList; RuleNr,Cnt:Integer):PTokenTree;
    Procedure   TreeDone(Root:PTokenTree);
    procedure   TreeShow(Root:PToken);
    Procedure   TreeDump(Root:PToken);
  end {TParser};



{$IFDEF Debug_HEAPMEM} 
{-----------------------------------------------------------------------------}
procedure ShowMem(Prefix:String);
{-----------------------------------------------------------------------------}
var Status:theapstatus;
begin
  Status:=GetHeapStatus;
  Writeln(Fo^, Prefix,': ',Status.TotalAllocated:1, ' bytes'); // [',HeapCount:1,':',HeapSize,']');
end;
{$ENDIF}


{-----------------------------------------------------------------------------}
constructor TScanner.Init(FileName:String);
{-----------------------------------------------------------------------------}
begin
  assign(Fi,FileName);
  reset(Fi);
  CurChar:=#0;
  NextChar:=#0;
  Get;
end;


{-----------------------------------------------------------------------------}
destructor TScanner.Done;
{-----------------------------------------------------------------------------}
begin
  close(Fi);
end;


{-----------------------------------------------------------------------------}
Procedure TScanner.Get; //replace this one with your own reader
{-----------------------------------------------------------------------------}
begin
  CurChar:=NextChar;
  if NextChar<>EOF then Read(Fi,NextChar); 
end;


{-----------------------------------------------------------------------------}
constructor TLexer.Init(FileName:String);
{-----------------------------------------------------------------------------}
begin
  inherited init(FileName);
  LexemeLen:=0;
  LexemeStr:='';
  LinePos:=1;
  CharPos:=0;
  ErrorMax:=100;
  ErrorCnt:=0;
  Token.Tag:=0;
  Token.LinePos:=LinePos;
  Token.CharPos:=CharPos;
  Mode:=0;
  GetChar;
end;


{-----------------------------------------------------------------------------}
Procedure TLexer.GetChar; 
{-----------------------------------------------------------------------------}
begin  
  case CurChar of
    LF:    begin CharPos:=0; inc(LinePos);      end;
    CR,FF: begin CharPos:=0;                    end;
    TAB:   begin CharPos:= (CharPos div 8)*8+8; end;
  end; {case} 
  inc(LexemeLen); inc(CharPos);
  if LexemeLen<256 then begin
    setlength(LexemeStr,LexemeLen);
    LexemeStr[LexemeLen]:=CurChar;
  end {else overflow};
  Get;
end;


{-----------------------------------------------------------------------------}
Procedure TLexer.GetLine;
{-----------------------------------------------------------------------------}
begin
  repeat
    case CurChar of
      CR,FF,LF: Break;
      else      Get;
    end; {case}
  until false;
  repeat
    case CurChar of
      LF:    begin CharPos:=0; inc(LinePos);      end;
      CR,FF: begin CharPos:=0;                    end;
      else   Break;
    end;
    Get;
  until false;
  inc(CharPos);
  LexemeStr:='';
  LexemeLen:=0;
end;


{-----------------------------------------------------------------------------}
procedure TLexer.GetToken;
{-----------------------------------------------------------------------------}
// Reads a "token", being a representation of a lexeme.
// This means, reading a lexeme string and bind it to a token
// Extend or change this function according to your application needs
//
// A token is a record, usually containing information like
//   - a tag being unique for each lexeme, 
//   - a pointer to a string to that lexeme, 
//   - the location of that lexeme
//   - and everything that is needed for your application
{-----------------------------------------------------------------------------}
var Tag:Integer;
begin
  if (Token.Tag=TAG_PERCENTPERCENT) and (Mode>1) then begin
    //skip everything after second '%%'
    GetLexeme(False);
    Token.Tag:=TAG_EOF;
    Token.Lex:=Nil;
    Token.Kind:=1;
    exit;
  end;
  repeat
    Tag:=GetLexeme(False);
    case Tag of
      TAG_WHITESPACE:      {$IFDEF Debug_LEXER} WriteLn(Fo^,'  ---WhiteSpace---') {$ENDIF};
      TAG_COMMENTLINE:     GetLine;
      TAG_COMMENTSTART:    GetComment(TAG_COMMENTSTART,  TAG_COMMENTEND );
      TAG_COMMENTSTART1:   GetComment(TAG_COMMENTSTART1, TAG_COMMENTEND1);
      TAG_COMMENTSTART2:   GetComment(TAG_COMMENTSTART2, TAG_COMMENTEND2);
      TAG_COMMENTEND, TAG_COMMENTEND1, TAG_COMMENTEND2, -1:      
                           begin inc(ErrorCnt); DoError(Err_Lexeme, Nil); GetChar;   end;
      TAG_LBRACE:          begin 
                             GetAction; LexemeStr:='{}'; Tag:=TAG_ACTION; break;
                           end;
      TAG_DECLARATIONCODE: begin LexemeStr:='{}'; break end;
      TAG_PERCENTPERCENT:  begin inc(Mode); break; end;
      TAG_IDENTIFIER:      begin
                             if (CurChar=':')
                             or (Token.CharPos=1) then Tag:=TAG_RULENAME;
                             break;
                           end;   
      else                 break;
    end;
  until False;
  getmem(Token.Lex, length(LexemeStr)+1);
  Token.Tag :=Tag;
  Token.Lex^:=LexemeStr;
  Token.Kind:=1; //flag this token as an "terminal" token
  {$IFDEF Debug_TOKENS} writeln(Fo^,'Token(',Token.LinePos:1,':',Token.CharPos:1,'):',Tab,'Tag=',Token.Tag,Tab,': "',LexemeStr,'"'); {$ENDIF}
end;


{-----------------------------------------------------------------------------}
procedure TLexer.GetComment(TagCommentStart,TagCommentEnd:Integer);
{-----------------------------------------------------------------------------}
var Tag:Integer;
begin
  repeat
    Tag:=GetLexeme(True);
    if (Tag=TagCommentEnd)   then break;
    if (Tag=TAG_EOF)         then break;
    {$ifdef IsNESTED} 
    if (Tag=TagCommentStart) then GetComment(TagCommentStart, TagCommentEnd);
    {$endif}
  until false;    
end;      

{-----------------------------------------------------------------------------}
procedure TLexer.GetAction;
{-----------------------------------------------------------------------------}
//reads all between {}, in a nested way
var NestLevel:Integer;
begin
  NestLevel:=1;
  repeat
    case CurChar of
      '{':  inc(NestLevel);
      '}':  dec(NestLevel);
    end;
    GetChar;
  until (NestLevel=0); 
end;


{-----------------------------------------------------------------------------}
Procedure TLexer.DoError(ErrorNr:Integer; TokenPtr:PToken);
{-----------------------------------------------------------------------------}
//Augment this with you own code, to handle errors
begin
  case ErrorNr of
    Err_StackOverflow:  
         begin
           writeln(Fe^,'Syntax Error: Overflow of parse stack at');
           writeln(Fe^,'  Pos(',Token.LinePos:1,':',Token.CharPos:1,')=',Tab,Token.Tag,Tab,'"',LexemeStr,'"');
         end;
    Err_Overflow:  
         begin
           writeln(Fe^,'--> too many errors (',ErrorMax,'), parsing stopped');
         end;
    Err_Skipped:
         begin
           dec(TokenPtr);
           write(Fe^,'--> Invalidating all input between ');
           write(Fe^,  '(',TokenPtr^.LinePos,':',TokenPtr^.CharPos,') and ');
           inc(TokenPtr);
           write(Fe^,  '(',TokenPtr^.LinePos,':',TokenPtr^.CharPos,')');
           writeln(Fe^, ' into a single <error>');
         end;
    Err_Halted:
         begin
           write(Fe^,'--> Parsing prematurely halted due to unsolveable error at');
           writeln(Fe^,' (',Token.LinePos:1,':',Token.CharPos:1,')');
         end;
    Err_Lexeme:
         begin
           write(Fe^,'Pos(',Token.LinePos:1,':',Token.CharPos:1,') ');
           write(Fe^,'Pos(',Token.LinePos:1,':',Token.CharPos:1,') ');
           write(Fe^,'Lexical Error: character ');
           if ord(CurChar)>=32 
             then writeln(Fe^,'"',CurChar,'" is skipped')
             else writeln(Fe^,'<',ord(CurChar),'> is skipped');
         end;
    else begin
           write(Fe^,'Pos(',Token.LinePos:1,':',Token.CharPos:1,') ');
           write(Fe^,'Syntax Error(',ErrorNr,'): "',LexemeStr,'" found');
           if Token.Tag<>TokenPtr^.Tag then
//           write(Fe^,' but <',TokenPtr^.Tag:1,'> expected');
           write(Fe^,' but [',LexTable[TokenPtr^.Tag]^,'] expected');
           writeln(Fe^);
         end;
  end;
end;


{-----------------------------------------------------------------------------}
constructor TParser.Init(InFile:String);
{-----------------------------------------------------------------------------}
begin
  {$IFDEF Debug_HEAPMEM} ShowMem('MemUsage, at Parse start '); {$ENDIF}
  inherited init(InFile);
end;


{-----------------------------------------------------------------------------}
destructor TParser.Done;
{-----------------------------------------------------------------------------}
begin
  inherited done;
  {$IFDEF Debug_HEAPMEM} ShowMem('MemUsage, at Parse Done '); {$ENDIF}
end;


{-----------------------------------------------------------------------------}
Procedure TParser.DoAccept(TokenPtr:PToken);
{-----------------------------------------------------------------------------}
begin
  //replace this with you own code, to process for instance a parse tree tha has
  //been build during the parsing process
  {$ifdef Debug_TREE} TreeDump(TokenPtr); {$endif}
  TreeShow(TokenPtr);
  writeln(Fo^);
end;



{-----------------------------------------------------------------------------}
Procedure TParser.DoCleanup(TokenPtr:PToken);
{-----------------------------------------------------------------------------}
begin
  if TokenPtr=Nil then exit;
  case TokenPtr^.Kind of
    0:  TreeDone(TokenPtr^.Lnk);
    1:  freemem(TokenPtr^.Lex, length(TokenPtr^.Lex^)+1);
  end;
end;  


{-----------------------------------------------------------------------------}
Procedure TParser.DoAction(T:PTokenList; RuleNr,TokenCnt:Integer);
{-----------------------------------------------------------------------------}
// Then call associated action routine, with a pointer to the first 
// left-hand item of the involved rule.
// When finished, replace first left hand token tag with a new non-terminal,
// and return the number of left-hand items
{-----------------------------------------------------------------------------}
const
    Rule_YACCGRAMMAR_PERCENTPERCENT   = 0; //	<YACC Grammar> ::= <Tokens> %% <Rules> <End Marker Opt>
    Rule_TOKENS                       = 1; //	<Tokens> ::= <Tokens> <Token>
    Rule_TOKENS2                      = 2; //	<Tokens> ::= 
    Rule_TOKEN_PERCENTSTART_IDENTIFIER= 3; //	<Token> ::= %start Identifier
    Rule_TOKEN_PERCENTUNION_ACTION    = 4; //	<Token> ::= %union Action
    Rule_TOKEN_PERCENTEXPECT_NUMBER   = 5; //	<Token> ::= %expect Number
    Rule_TOKEN_PERCENTTOKEN           = 6; //	<Token> ::= %token <Union Name Opt> <Symbols>
    Rule_TOKEN_PERCENTLEFT            = 7; //	<Token> ::= %left <Union Name Opt> <Symbols>
    Rule_TOKEN_PERCENTRIGHT           = 8; //	<Token> ::= %right <Union Name Opt> <Symbols>
    Rule_TOKEN_PERCENTBINARY          = 9; //	<Token> ::= %binary <Union Name Opt> <Symbols>
    Rule_TOKEN_PERCENTNONASSOC        =10; //	<Token> ::= %nonassoc <Union Name Opt> <Symbols>
    Rule_TOKEN_PERCENTTYPE            =11; //	<Token> ::= %type <Union Name Opt> <Symbols>
    Rule_TOKEN_DECLARATIONCODE        =12; //	<Token> ::= DeclarationCode
    Rule_ENDMARKEROPT_PERCENTPERCENT  =13; //	<End Marker Opt> ::= %%
    Rule_ENDMARKEROPT                 =14; //	<End Marker Opt> ::= 
    Rule_UNIONNAMEOPT_LT_IDENTIFIER_GT=15; //	<Union Name Opt> ::= < Identifier >
    Rule_UNIONNAMEOPT                 =16; //	<Union Name Opt> ::= 
    Rule_RULES                        =17; //	<Rules> ::= <Rules> <Rule>
    Rule_RULES2                       =18; //	<Rules> ::= 
    Rule_RULE_SEMI                    =19; //	<Rule> ::= <RuleHead> <RuleBody> ;
    Rule_RULE                         =20; //	<Rule> ::= <RuleHead> <RuleBody>
    Rule_RULEHEAD_RULENAME_COLON      =21; //	<RuleHead> ::= RuleName :
    Rule_RULEHEAD_RULENAME_COLON2     =22; //	<RuleHead> ::= RuleName : <ItemList>
    Rule_RULEBODY                     =23; //	<RuleBody> ::= <RuleBody> <RuleOpt>
    Rule_RULEBODY2                    =24; //	<RuleBody> ::= <RuleOpt>
    Rule_RULEBODY3                    =25; //	<RuleBody> ::= 
    Rule_RULEOPT_PIPE                 =26; //	<RuleOpt> ::= | <ItemList>
    Rule_RULEOPT_PIPE2                =27; //	<RuleOpt> ::= |
    Rule_ITEMLIST                     =28; //	<ItemList> ::= <ItemList> <Item>
    Rule_ITEMLIST2                    =29; //	<ItemList> ::= <Item>
    Rule_ITEM                         =30; //	<Item> ::= <Symbol>
    Rule_ITEM_PERCENTPREC             =31; //	<Item> ::= %prec <Symbol>
    Rule_ITEM_EQ                      =32; //	<Item> ::= = <Symbol>
    Rule_ITEM_ACTION                  =33; //	<Item> ::= Action
    Rule_SYMBOLS                      =34; //	<Symbols> ::= <Symbols> <Symbol>
    Rule_SYMBOLS_COMMA                =35; //	<Symbols> ::= <Symbols> , <Symbol>
    Rule_SYMBOLS2                     =36; //	<Symbols> ::= <Symbol>
    Rule_SYMBOL_IDENTIFIER            =37; //	<Symbol> ::= Identifier
    Rule_SYMBOL_LITERAL               =38; //	<Symbol> ::= Literal
begin
  //This template is auto-generated by GoldParser
  //Your tokens of this rule are in T^[1], T^[2], T^[3] .... T^[Cnt]
  //replace it with you own code, to handle adequate semantic actions
  T^[1].Lnk:=TreeBuild(T,RuleNr,TokenCnt);
end {DoAction}; 




{-----------------------------------------------------------------------------}
function TLexer.GetLexeme(SkipMode:Boolean):Integer;
{-----------------------------------------------------------------------------}
TYPE TLexEdge = record SetNr:Byte; L:Integer; end;
     PLexEdge = ^TLexEdge;
     TByteSet = set of Byte;  //32bytes long
     PByteSet = ^TByteSet;
CONST
  Empty=39;
  CharSet : array [0..39] of TByteSet = (
    {#0} [9..13,32,160],
    {#1} [42],
    {#2} [44],
    {#3} [58],
    {#4} [59],
    {#5} [124],
    {#6} [60],
    {#7} [61],
    {#8} [62],
    {#9} [65..90,97..122],
    {#10} [39],
    {#11} [48..57],
    {#12} [37],
    {#13} [47],
    {#14} [123],
    {#15} [48..57,65..90,95,97..122],
    {#16} [9..13,32..38,40..126,160],
    {#17} [66,98],
    {#18} [69,101],
    {#19} [76,108],
    {#20} [78,110],
    {#21} [80,112],
    {#22} [82,114],
    {#23} [83,115],
    {#24} [85,117],
    {#25} [84,116],
    {#26} [73,105],
    {#27} [65,97],
    {#28} [89,121],
    {#29} [88,120],
    {#30} [67,99],
    {#31} [70,102],
    {#32} [79,111],
    {#33} [71,103],
    {#34} [72,104],
    {#35} [9..13,32..36,38..126,160],
    {#36} [9..13,32..124,126,160],
    {#37} [125],
    {#38} [75,107],
    []
  );
  LexState0: array [0..15] of TLexEdge = ( 
    (SetNr:0;        L:1), 
    (SetNr:1;        L:2), 
    (SetNr:2;        L:4), 
    (SetNr:3;        L:5), 
    (SetNr:4;        L:6), 
    (SetNr:5;        L:7), 
    (SetNr:6;        L:8), 
    (SetNr:7;        L:9), 
    (SetNr:8;        L:10), 
    (SetNr:9;        L:11), 
    (SetNr:10;        L:13), 
    (SetNr:11;        L:16), 
    (SetNr:12;        L:17), 
    (SetNr:13;        L:75), 
    (SetNr:14;        L:78), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState1: array [0..1] of TLexEdge = ( 
    (SetNr:0;        L:1), 
    (SetNr:Empty; L:2)); //Tag:=2
  LexState2: array [0..1] of TLexEdge = ( 
    (SetNr:13;        L:3), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState3: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:3)); //Tag:=3
  LexState4: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:17)); //Tag:=17
  LexState5: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:18)); //Tag:=18
  LexState6: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:19)); //Tag:=19
  LexState7: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:20)); //Tag:=20
  LexState8: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:21)); //Tag:=21
  LexState9: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:22)); //Tag:=22
  LexState10: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:23)); //Tag:=23
  LexState11: array [0..1] of TLexEdge = ( 
    (SetNr:15;        L:12), 
    (SetNr:Empty; L:30)); //Tag:=30
  LexState12: array [0..1] of TLexEdge = ( 
    (SetNr:15;        L:12), 
    (SetNr:Empty; L:30)); //Tag:=30
  LexState13: array [0..1] of TLexEdge = ( 
    (SetNr:16;        L:14), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState14: array [0..2] of TLexEdge = ( 
    (SetNr:16;        L:14), 
    (SetNr:10;        L:15), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState15: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:32)); //Tag:=32
  LexState16: array [0..1] of TLexEdge = ( 
    (SetNr:11;        L:16), 
    (SetNr:Empty; L:33)); //Tag:=33
  LexState17: array [0..11] of TLexEdge = ( 
    (SetNr:12;        L:18), 
    (SetNr:17;        L:19), 
    (SetNr:18;        L:25), 
    (SetNr:19;        L:31), 
    (SetNr:20;        L:35), 
    (SetNr:21;        L:43), 
    (SetNr:22;        L:47), 
    (SetNr:23;        L:52), 
    (SetNr:24;        L:57), 
    (SetNr:14;        L:62), 
    (SetNr:25;        L:67), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState18: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:6)); //Tag:=6
  LexState19: array [0..1] of TLexEdge = ( 
    (SetNr:26;        L:20), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState20: array [0..1] of TLexEdge = ( 
    (SetNr:20;        L:21), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState21: array [0..1] of TLexEdge = ( 
    (SetNr:27;        L:22), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState22: array [0..1] of TLexEdge = ( 
    (SetNr:22;        L:23), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState23: array [0..1] of TLexEdge = ( 
    (SetNr:28;        L:24), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState24: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:7)); //Tag:=7
  LexState25: array [0..1] of TLexEdge = ( 
    (SetNr:29;        L:26), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState26: array [0..1] of TLexEdge = ( 
    (SetNr:21;        L:27), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState27: array [0..1] of TLexEdge = ( 
    (SetNr:18;        L:28), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState28: array [0..1] of TLexEdge = ( 
    (SetNr:30;        L:29), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState29: array [0..1] of TLexEdge = ( 
    (SetNr:25;        L:30), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState30: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:8)); //Tag:=8
  LexState31: array [0..1] of TLexEdge = ( 
    (SetNr:18;        L:32), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState32: array [0..1] of TLexEdge = ( 
    (SetNr:31;        L:33), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState33: array [0..1] of TLexEdge = ( 
    (SetNr:25;        L:34), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState34: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:9)); //Tag:=9
  LexState35: array [0..1] of TLexEdge = ( 
    (SetNr:32;        L:36), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState36: array [0..1] of TLexEdge = ( 
    (SetNr:20;        L:37), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState37: array [0..1] of TLexEdge = ( 
    (SetNr:27;        L:38), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState38: array [0..1] of TLexEdge = ( 
    (SetNr:23;        L:39), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState39: array [0..1] of TLexEdge = ( 
    (SetNr:23;        L:40), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState40: array [0..1] of TLexEdge = ( 
    (SetNr:32;        L:41), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState41: array [0..1] of TLexEdge = ( 
    (SetNr:30;        L:42), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState42: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:10)); //Tag:=10
  LexState43: array [0..1] of TLexEdge = ( 
    (SetNr:22;        L:44), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState44: array [0..1] of TLexEdge = ( 
    (SetNr:18;        L:45), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState45: array [0..1] of TLexEdge = ( 
    (SetNr:30;        L:46), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState46: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:11)); //Tag:=11
  LexState47: array [0..1] of TLexEdge = ( 
    (SetNr:26;        L:48), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState48: array [0..1] of TLexEdge = ( 
    (SetNr:33;        L:49), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState49: array [0..1] of TLexEdge = ( 
    (SetNr:34;        L:50), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState50: array [0..1] of TLexEdge = ( 
    (SetNr:25;        L:51), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState51: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:12)); //Tag:=12
  LexState52: array [0..1] of TLexEdge = ( 
    (SetNr:25;        L:53), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState53: array [0..1] of TLexEdge = ( 
    (SetNr:27;        L:54), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState54: array [0..1] of TLexEdge = ( 
    (SetNr:22;        L:55), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState55: array [0..1] of TLexEdge = ( 
    (SetNr:25;        L:56), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState56: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:13)); //Tag:=13
  LexState57: array [0..1] of TLexEdge = ( 
    (SetNr:20;        L:58), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState58: array [0..1] of TLexEdge = ( 
    (SetNr:26;        L:59), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState59: array [0..1] of TLexEdge = ( 
    (SetNr:32;        L:60), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState60: array [0..1] of TLexEdge = ( 
    (SetNr:20;        L:61), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState61: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:16)); //Tag:=16
  LexState62: array [0..2] of TLexEdge = ( 
    (SetNr:35;        L:63), 
    (SetNr:12;        L:64), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState63: array [0..2] of TLexEdge = ( 
    (SetNr:35;        L:63), 
    (SetNr:12;        L:64), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState64: array [0..2] of TLexEdge = ( 
    (SetNr:36;        L:65), 
    (SetNr:37;        L:66), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState65: array [0..2] of TLexEdge = ( 
    (SetNr:35;        L:63), 
    (SetNr:12;        L:64), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState66: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:29)); //Tag:=29
  LexState67: array [0..2] of TLexEdge = ( 
    (SetNr:32;        L:68), 
    (SetNr:28;        L:72), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState68: array [0..1] of TLexEdge = ( 
    (SetNr:38;        L:69), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState69: array [0..1] of TLexEdge = ( 
    (SetNr:18;        L:70), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState70: array [0..1] of TLexEdge = ( 
    (SetNr:20;        L:71), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState71: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:14)); //Tag:=14
  LexState72: array [0..1] of TLexEdge = ( 
    (SetNr:21;        L:73), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState73: array [0..1] of TLexEdge = ( 
    (SetNr:18;        L:74), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState74: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:15)); //Tag:=15
  LexState75: array [0..2] of TLexEdge = ( 
    (SetNr:13;        L:76), 
    (SetNr:1;        L:77), 
    (SetNr:Empty; L:-1)); //Tag:=-1
  LexState76: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:4)); //Tag:=4
  LexState77: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:5)); //Tag:=5
  LexState78: array [0..1] of TLexEdge = ( 
    (SetNr:37;        L:79), 
    (SetNr:Empty; L:31)); //Tag:=31
  LexState79: array [0..0] of TLexEdge = ( 
    (SetNr:Empty; L:24)); //Tag:=24
  LexStateList: array [0..80] of PLexEdge = (
    @LexState0,
    @LexState1,
    @LexState2,
    @LexState3,
    @LexState4,
    @LexState5,
    @LexState6,
    @LexState7,
    @LexState8,
    @LexState9,
    @LexState10,
    @LexState11,
    @LexState12,
    @LexState13,
    @LexState14,
    @LexState15,
    @LexState16,
    @LexState17,
    @LexState18,
    @LexState19,
    @LexState20,
    @LexState21,
    @LexState22,
    @LexState23,
    @LexState24,
    @LexState25,
    @LexState26,
    @LexState27,
    @LexState28,
    @LexState29,
    @LexState30,
    @LexState31,
    @LexState32,
    @LexState33,
    @LexState34,
    @LexState35,
    @LexState36,
    @LexState37,
    @LexState38,
    @LexState39,
    @LexState40,
    @LexState41,
    @LexState42,
    @LexState43,
    @LexState44,
    @LexState45,
    @LexState46,
    @LexState47,
    @LexState48,
    @LexState49,
    @LexState50,
    @LexState51,
    @LexState52,
    @LexState53,
    @LexState54,
    @LexState55,
    @LexState56,
    @LexState57,
    @LexState58,
    @LexState59,
    @LexState60,
    @LexState61,
    @LexState62,
    @LexState63,
    @LexState64,
    @LexState65,
    @LexState66,
    @LexState67,
    @LexState68,
    @LexState69,
    @LexState70,
    @LexState71,
    @LexState72,
    @LexState73,
    @LexState74,
    @LexState75,
    @LexState76,
    @LexState77,
    @LexState78,
    @LexState79,
    Nil
  );
  InitialState=0;
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// Reads a "lexeme", being a logical cohesive sequence of characters 
//
// if SkipMode is true, the reader becomes verry tolerant to errors
// It will consume all characters unless a lexeme of one or two
// characters is found. This enables you to skip block comments until a closing
// lexeme is found, like '}' or '*)'
//
// This lexeme reader can read one character ahead. The result is that it will read
// only a character, if the ahead character is not in conflict with a valid lexeme.
// This enables you to tokenize an input stream like('13..37') into a valid
// ('13'+'..'+'378') and not as ('13.') followed by an error.
// This mechanism uses the flag LexAccept, to delays acceptance of a char, until 
// its ahead char has proven not to be in conflict with a valid lexeme
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
label LexBegin, LexNextState, LexNextSet, LexDone;
var LexEdgePtr:PLexEdge;
    LexSetNr:Integer;
    LexChar:Char;
    LexAccept:Boolean; //reads one character ahead, to enable 123..456
    LexTag, State, OldState:Integer;
    LexTagStr: string[5];
begin
LexBegin:
  Token.LinePos:=LinePos;
  Token.CharPos:=CharPos;
  Token.Tag:=1; {Tag_ERROR};
  LexemeLen:=0;
  LexemeStr:='';
  State:=InitialState;
  OldState:=InitialState;
  LexChar:=CurChar;
  LexAccept:=False;
LexNextState:
  {$IFDEF Debug_LEXER}
  Write(Fo^,'  LexState=',State:3, ',  ord(Char)=',ord(LexChar):3,',  Char=');
  if ord(LexChar)>31 then write(Fo^,'"',LexChar,'"') else write(Fo^,'***');
  {$ENDIF Debug_LEXER}
  LexEdgePtr:=LexStateList[State];
  LexSetNr:=LexEdgePtr^.SetNr;
  {}
LexNextSet: {Loop}
  if (LexSetNr=Empty) then begin
    LexTag:=LexEdgePtr^.L;
    if (LexTag>=0) or (SkipMode and (LexemeLen=0)) then GetChar else begin
      {$IFDEF Debug_LEXER} Write(Fo^,'   (not found, set back)'); {$ENDIF}
      //try to repair error by falling back to previous state;
      LexEdgePtr:=LexStateList[OldState];
      while (LexEdgePtr^.SetNr<>Empty) do inc(LexEdgePtr);
      LexTag:=LexEdgePtr^.L;
    end;
    goto LexDone;
  end;
  if (ord(LexChar) in CharSet[LexSetNr]) then begin
    {$IFDEF Debug_LEXER} WriteLn(Fo^,',  (Found in CharSet[',LexSetNr,'])'); {$ENDIF}
    OldState:=State;
    State:=LexEdgePtr^.L;
    if SkipMode and (LexemeLen=1) then goto LexBegin;
    if LexAccept then GetChar;
    LexChar:=NextChar; LexAccept:=True;
    goto LexNextState;
  end;
  inc(LexEdgePtr);
  LexSetNr:=LexEdgePtr^.SetNr;
  goto LexNextSet;  {next}
  {}
LexDone:
  if (LexTag<0) and (CurChar=EOF) then LexTag:=0; {TAG_EOF}
  {$IFDEF Debug_LEXER} WriteLn(Fo^,',  ==> Tag:=',LexTag); {$ENDIF}
  GetLexeme:=LexTag;
  {$IFDEF Debug_LEXEMES}
  case LexTag of
    TAG_WHITESPACE:    LexTagStr:='<WS>';
    TAG_COMMENTLINE:   LexTagStr:='<CL>';
    TAG_COMMENTSTART:  LexTagStr:='<CS>';
    TAG_COMMENTEND:    LexTagStr:='<CE>';
    TAG_EOF:           LexTagStr:='<EOF>';
    else               LexTagStr:='';
  end;
  write(Fo^,'Lexeme(',Token.LinePos:1,':',Token.CharPos:1,').Tag=',Tab);
  if LexTagStr=''
    then WriteLn(Fo^, LexTag,    Tab,'"',LexemeStr,'"')
    else WriteLn(Fo^, LexTagStr, Tab,'"',LexemeStr,'"');
  {$ENDIF}  
end;


{-----------------------------------------------------------------------------}
function TParser.DoParse(StackSize:Integer):Integer;
{-----------------------------------------------------------------------------}
const Any  =TagAny;
      ActError=0; ActShift=1; ActReduce=2; ActNext=3; ActAccept=4;
      StartState=0;       
type  TState =0..61; 
      PState =^TState; 
      TParseEdge= packed record Tag:TTokenTag; Q:TState; Act:Byte; end;
      PParseEdge=^TParseEdge;
      TEntry = packed record EntryPtr:PParseEdge; EdgeCnt:Byte; end; 
var   StateStack, StateStackTop, StateStackEnd: PState;
      TokenStack, TokenStackTop:                PToken;
      ErrorState:    TState;
      ErrorStatePtr: PState;
      HasShifted:    Boolean;
const ParseState0: packed array[0..13] of TParseEdge= (
        (Tag:47; Q:1; Act:3), //Goto; 
        (Tag:49; Q:2; Act:3), //Goto; 
        (Tag:6; Q:2; Act:2), //Reduce Rule; 
        (Tag:7; Q:2; Act:2), //Reduce Rule; 
        (Tag:8; Q:2; Act:2), //Reduce Rule; 
        (Tag:9; Q:2; Act:2), //Reduce Rule; 
        (Tag:10; Q:2; Act:2), //Reduce Rule; 
        (Tag:12; Q:2; Act:2), //Reduce Rule; 
        (Tag:13; Q:2; Act:2), //Reduce Rule; 
        (Tag:14; Q:2; Act:2), //Reduce Rule; 
        (Tag:15; Q:2; Act:2), //Reduce Rule; 
        (Tag:16; Q:2; Act:2), //Reduce Rule; 
        (Tag:29; Q:2; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState1: packed array[0..12] of TParseEdge= (
        (Tag:6; Q:3; Act:1), //Shift; 
        (Tag:7; Q:4; Act:1), //Shift; 
        (Tag:8; Q:5; Act:1), //Shift; 
        (Tag:9; Q:6; Act:1), //Shift; 
        (Tag:10; Q:7; Act:1), //Shift; 
        (Tag:12; Q:8; Act:1), //Shift; 
        (Tag:13; Q:9; Act:1), //Shift; 
        (Tag:14; Q:10; Act:1), //Shift; 
        (Tag:15; Q:11; Act:1), //Shift; 
        (Tag:16; Q:12; Act:1), //Shift; 
        (Tag:29; Q:13; Act:1), //Shift; 
        (Tag:46; Q:14; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState2: packed array[0..1] of TParseEdge= (
        (Tag:0; Q:0; Act:4), //Accept; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState3: packed array[0..4] of TParseEdge= (
        (Tag:43; Q:15; Act:3), //Goto; 
        (Tag:0; Q:18; Act:2), //Reduce Rule; 
        (Tag:6; Q:18; Act:2), //Reduce Rule; 
        (Tag:34; Q:18; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState4: packed array[0..4] of TParseEdge= (
        (Tag:21; Q:16; Act:1), //Shift; 
        (Tag:48; Q:17; Act:3), //Goto; 
        (Tag:30; Q:16; Act:2), //Reduce Rule; 
        (Tag:32; Q:16; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState5: packed array[0..1] of TParseEdge= (
        (Tag:33; Q:18; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState6: packed array[0..4] of TParseEdge= (
        (Tag:21; Q:16; Act:1), //Shift; 
        (Tag:48; Q:19; Act:3), //Goto; 
        (Tag:30; Q:16; Act:2), //Reduce Rule; 
        (Tag:32; Q:16; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState7: packed array[0..4] of TParseEdge= (
        (Tag:21; Q:16; Act:1), //Shift; 
        (Tag:48; Q:20; Act:3), //Goto; 
        (Tag:30; Q:16; Act:2), //Reduce Rule; 
        (Tag:32; Q:16; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState8: packed array[0..4] of TParseEdge= (
        (Tag:21; Q:16; Act:1), //Shift; 
        (Tag:48; Q:21; Act:3), //Goto; 
        (Tag:30; Q:16; Act:2), //Reduce Rule; 
        (Tag:32; Q:16; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState9: packed array[0..1] of TParseEdge= (
        (Tag:30; Q:22; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState10: packed array[0..4] of TParseEdge= (
        (Tag:21; Q:16; Act:1), //Shift; 
        (Tag:48; Q:23; Act:3), //Goto; 
        (Tag:30; Q:16; Act:2), //Reduce Rule; 
        (Tag:32; Q:16; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState11: packed array[0..4] of TParseEdge= (
        (Tag:21; Q:16; Act:1), //Shift; 
        (Tag:48; Q:24; Act:3), //Goto; 
        (Tag:30; Q:16; Act:2), //Reduce Rule; 
        (Tag:32; Q:16; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState12: packed array[0..1] of TParseEdge= (
        (Tag:24; Q:25; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState13: packed array[0..11] of TParseEdge= (
        (Tag:6; Q:12; Act:2), //Reduce Rule; 
        (Tag:7; Q:12; Act:2), //Reduce Rule; 
        (Tag:8; Q:12; Act:2), //Reduce Rule; 
        (Tag:9; Q:12; Act:2), //Reduce Rule; 
        (Tag:10; Q:12; Act:2), //Reduce Rule; 
        (Tag:12; Q:12; Act:2), //Reduce Rule; 
        (Tag:13; Q:12; Act:2), //Reduce Rule; 
        (Tag:14; Q:12; Act:2), //Reduce Rule; 
        (Tag:15; Q:12; Act:2), //Reduce Rule; 
        (Tag:16; Q:12; Act:2), //Reduce Rule; 
        (Tag:29; Q:12; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState14: packed array[0..11] of TParseEdge= (
        (Tag:6; Q:1; Act:2), //Reduce Rule; 
        (Tag:7; Q:1; Act:2), //Reduce Rule; 
        (Tag:8; Q:1; Act:2), //Reduce Rule; 
        (Tag:9; Q:1; Act:2), //Reduce Rule; 
        (Tag:10; Q:1; Act:2), //Reduce Rule; 
        (Tag:12; Q:1; Act:2), //Reduce Rule; 
        (Tag:13; Q:1; Act:2), //Reduce Rule; 
        (Tag:14; Q:1; Act:2), //Reduce Rule; 
        (Tag:15; Q:1; Act:2), //Reduce Rule; 
        (Tag:16; Q:1; Act:2), //Reduce Rule; 
        (Tag:29; Q:1; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState15: packed array[0..6] of TParseEdge= (
        (Tag:6; Q:26; Act:1), //Shift; 
        (Tag:34; Q:27; Act:1), //Shift; 
        (Tag:36; Q:28; Act:3), //Goto; 
        (Tag:39; Q:29; Act:3), //Goto; 
        (Tag:41; Q:30; Act:3), //Goto; 
        (Tag:0; Q:14; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState16: packed array[0..1] of TParseEdge= (
        (Tag:30; Q:31; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState17: packed array[0..4] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:34; Act:3), //Goto; 
        (Tag:45; Q:35; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState18: packed array[0..11] of TParseEdge= (
        (Tag:6; Q:5; Act:2), //Reduce Rule; 
        (Tag:7; Q:5; Act:2), //Reduce Rule; 
        (Tag:8; Q:5; Act:2), //Reduce Rule; 
        (Tag:9; Q:5; Act:2), //Reduce Rule; 
        (Tag:10; Q:5; Act:2), //Reduce Rule; 
        (Tag:12; Q:5; Act:2), //Reduce Rule; 
        (Tag:13; Q:5; Act:2), //Reduce Rule; 
        (Tag:14; Q:5; Act:2), //Reduce Rule; 
        (Tag:15; Q:5; Act:2), //Reduce Rule; 
        (Tag:16; Q:5; Act:2), //Reduce Rule; 
        (Tag:29; Q:5; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState19: packed array[0..4] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:34; Act:3), //Goto; 
        (Tag:45; Q:36; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState20: packed array[0..4] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:34; Act:3), //Goto; 
        (Tag:45; Q:37; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState21: packed array[0..4] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:34; Act:3), //Goto; 
        (Tag:45; Q:38; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState22: packed array[0..11] of TParseEdge= (
        (Tag:6; Q:3; Act:2), //Reduce Rule; 
        (Tag:7; Q:3; Act:2), //Reduce Rule; 
        (Tag:8; Q:3; Act:2), //Reduce Rule; 
        (Tag:9; Q:3; Act:2), //Reduce Rule; 
        (Tag:10; Q:3; Act:2), //Reduce Rule; 
        (Tag:12; Q:3; Act:2), //Reduce Rule; 
        (Tag:13; Q:3; Act:2), //Reduce Rule; 
        (Tag:14; Q:3; Act:2), //Reduce Rule; 
        (Tag:15; Q:3; Act:2), //Reduce Rule; 
        (Tag:16; Q:3; Act:2), //Reduce Rule; 
        (Tag:29; Q:3; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState23: packed array[0..4] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:34; Act:3), //Goto; 
        (Tag:45; Q:39; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState24: packed array[0..4] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:34; Act:3), //Goto; 
        (Tag:45; Q:40; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState25: packed array[0..11] of TParseEdge= (
        (Tag:6; Q:4; Act:2), //Reduce Rule; 
        (Tag:7; Q:4; Act:2), //Reduce Rule; 
        (Tag:8; Q:4; Act:2), //Reduce Rule; 
        (Tag:9; Q:4; Act:2), //Reduce Rule; 
        (Tag:10; Q:4; Act:2), //Reduce Rule; 
        (Tag:12; Q:4; Act:2), //Reduce Rule; 
        (Tag:13; Q:4; Act:2), //Reduce Rule; 
        (Tag:14; Q:4; Act:2), //Reduce Rule; 
        (Tag:15; Q:4; Act:2), //Reduce Rule; 
        (Tag:16; Q:4; Act:2), //Reduce Rule; 
        (Tag:29; Q:4; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState26: packed array[0..1] of TParseEdge= (
        (Tag:0; Q:13; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState27: packed array[0..1] of TParseEdge= (
        (Tag:18; Q:41; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState28: packed array[0..1] of TParseEdge= (
        (Tag:0; Q:0; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState29: packed array[0..3] of TParseEdge= (
        (Tag:0; Q:17; Act:2), //Reduce Rule; 
        (Tag:6; Q:17; Act:2), //Reduce Rule; 
        (Tag:34; Q:17; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState30: packed array[0..7] of TParseEdge= (
        (Tag:20; Q:42; Act:1), //Shift; 
        (Tag:40; Q:43; Act:3), //Goto; 
        (Tag:42; Q:44; Act:3), //Goto; 
        (Tag:0; Q:25; Act:2), //Reduce Rule; 
        (Tag:6; Q:25; Act:2), //Reduce Rule; 
        (Tag:19; Q:25; Act:2), //Reduce Rule; 
        (Tag:34; Q:25; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState31: packed array[0..1] of TParseEdge= (
        (Tag:23; Q:45; Act:1), //Shift; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState32: packed array[0..21] of TParseEdge= (
        (Tag:0; Q:37; Act:2), //Reduce Rule; 
        (Tag:6; Q:37; Act:2), //Reduce Rule; 
        (Tag:7; Q:37; Act:2), //Reduce Rule; 
        (Tag:8; Q:37; Act:2), //Reduce Rule; 
        (Tag:9; Q:37; Act:2), //Reduce Rule; 
        (Tag:10; Q:37; Act:2), //Reduce Rule; 
        (Tag:11; Q:37; Act:2), //Reduce Rule; 
        (Tag:12; Q:37; Act:2), //Reduce Rule; 
        (Tag:13; Q:37; Act:2), //Reduce Rule; 
        (Tag:14; Q:37; Act:2), //Reduce Rule; 
        (Tag:15; Q:37; Act:2), //Reduce Rule; 
        (Tag:16; Q:37; Act:2), //Reduce Rule; 
        (Tag:17; Q:37; Act:2), //Reduce Rule; 
        (Tag:19; Q:37; Act:2), //Reduce Rule; 
        (Tag:20; Q:37; Act:2), //Reduce Rule; 
        (Tag:22; Q:37; Act:2), //Reduce Rule; 
        (Tag:24; Q:37; Act:2), //Reduce Rule; 
        (Tag:29; Q:37; Act:2), //Reduce Rule; 
        (Tag:30; Q:37; Act:2), //Reduce Rule; 
        (Tag:32; Q:37; Act:2), //Reduce Rule; 
        (Tag:34; Q:37; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState33: packed array[0..21] of TParseEdge= (
        (Tag:0; Q:38; Act:2), //Reduce Rule; 
        (Tag:6; Q:38; Act:2), //Reduce Rule; 
        (Tag:7; Q:38; Act:2), //Reduce Rule; 
        (Tag:8; Q:38; Act:2), //Reduce Rule; 
        (Tag:9; Q:38; Act:2), //Reduce Rule; 
        (Tag:10; Q:38; Act:2), //Reduce Rule; 
        (Tag:11; Q:38; Act:2), //Reduce Rule; 
        (Tag:12; Q:38; Act:2), //Reduce Rule; 
        (Tag:13; Q:38; Act:2), //Reduce Rule; 
        (Tag:14; Q:38; Act:2), //Reduce Rule; 
        (Tag:15; Q:38; Act:2), //Reduce Rule; 
        (Tag:16; Q:38; Act:2), //Reduce Rule; 
        (Tag:17; Q:38; Act:2), //Reduce Rule; 
        (Tag:19; Q:38; Act:2), //Reduce Rule; 
        (Tag:20; Q:38; Act:2), //Reduce Rule; 
        (Tag:22; Q:38; Act:2), //Reduce Rule; 
        (Tag:24; Q:38; Act:2), //Reduce Rule; 
        (Tag:29; Q:38; Act:2), //Reduce Rule; 
        (Tag:30; Q:38; Act:2), //Reduce Rule; 
        (Tag:32; Q:38; Act:2), //Reduce Rule; 
        (Tag:34; Q:38; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState34: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:36; Act:2), //Reduce Rule; 
        (Tag:7; Q:36; Act:2), //Reduce Rule; 
        (Tag:8; Q:36; Act:2), //Reduce Rule; 
        (Tag:9; Q:36; Act:2), //Reduce Rule; 
        (Tag:10; Q:36; Act:2), //Reduce Rule; 
        (Tag:12; Q:36; Act:2), //Reduce Rule; 
        (Tag:13; Q:36; Act:2), //Reduce Rule; 
        (Tag:14; Q:36; Act:2), //Reduce Rule; 
        (Tag:15; Q:36; Act:2), //Reduce Rule; 
        (Tag:16; Q:36; Act:2), //Reduce Rule; 
        (Tag:17; Q:36; Act:2), //Reduce Rule; 
        (Tag:29; Q:36; Act:2), //Reduce Rule; 
        (Tag:30; Q:36; Act:2), //Reduce Rule; 
        (Tag:32; Q:36; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState35: packed array[0..15] of TParseEdge= (
        (Tag:17; Q:46; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:47; Act:3), //Goto; 
        (Tag:6; Q:9; Act:2), //Reduce Rule; 
        (Tag:7; Q:9; Act:2), //Reduce Rule; 
        (Tag:8; Q:9; Act:2), //Reduce Rule; 
        (Tag:9; Q:9; Act:2), //Reduce Rule; 
        (Tag:10; Q:9; Act:2), //Reduce Rule; 
        (Tag:12; Q:9; Act:2), //Reduce Rule; 
        (Tag:13; Q:9; Act:2), //Reduce Rule; 
        (Tag:14; Q:9; Act:2), //Reduce Rule; 
        (Tag:15; Q:9; Act:2), //Reduce Rule; 
        (Tag:16; Q:9; Act:2), //Reduce Rule; 
        (Tag:29; Q:9; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState36: packed array[0..15] of TParseEdge= (
        (Tag:17; Q:46; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:47; Act:3), //Goto; 
        (Tag:6; Q:7; Act:2), //Reduce Rule; 
        (Tag:7; Q:7; Act:2), //Reduce Rule; 
        (Tag:8; Q:7; Act:2), //Reduce Rule; 
        (Tag:9; Q:7; Act:2), //Reduce Rule; 
        (Tag:10; Q:7; Act:2), //Reduce Rule; 
        (Tag:12; Q:7; Act:2), //Reduce Rule; 
        (Tag:13; Q:7; Act:2), //Reduce Rule; 
        (Tag:14; Q:7; Act:2), //Reduce Rule; 
        (Tag:15; Q:7; Act:2), //Reduce Rule; 
        (Tag:16; Q:7; Act:2), //Reduce Rule; 
        (Tag:29; Q:7; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState37: packed array[0..15] of TParseEdge= (
        (Tag:17; Q:46; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:47; Act:3), //Goto; 
        (Tag:6; Q:10; Act:2), //Reduce Rule; 
        (Tag:7; Q:10; Act:2), //Reduce Rule; 
        (Tag:8; Q:10; Act:2), //Reduce Rule; 
        (Tag:9; Q:10; Act:2), //Reduce Rule; 
        (Tag:10; Q:10; Act:2), //Reduce Rule; 
        (Tag:12; Q:10; Act:2), //Reduce Rule; 
        (Tag:13; Q:10; Act:2), //Reduce Rule; 
        (Tag:14; Q:10; Act:2), //Reduce Rule; 
        (Tag:15; Q:10; Act:2), //Reduce Rule; 
        (Tag:16; Q:10; Act:2), //Reduce Rule; 
        (Tag:29; Q:10; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState38: packed array[0..15] of TParseEdge= (
        (Tag:17; Q:46; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:47; Act:3), //Goto; 
        (Tag:6; Q:8; Act:2), //Reduce Rule; 
        (Tag:7; Q:8; Act:2), //Reduce Rule; 
        (Tag:8; Q:8; Act:2), //Reduce Rule; 
        (Tag:9; Q:8; Act:2), //Reduce Rule; 
        (Tag:10; Q:8; Act:2), //Reduce Rule; 
        (Tag:12; Q:8; Act:2), //Reduce Rule; 
        (Tag:13; Q:8; Act:2), //Reduce Rule; 
        (Tag:14; Q:8; Act:2), //Reduce Rule; 
        (Tag:15; Q:8; Act:2), //Reduce Rule; 
        (Tag:16; Q:8; Act:2), //Reduce Rule; 
        (Tag:29; Q:8; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState39: packed array[0..15] of TParseEdge= (
        (Tag:17; Q:46; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:47; Act:3), //Goto; 
        (Tag:6; Q:6; Act:2), //Reduce Rule; 
        (Tag:7; Q:6; Act:2), //Reduce Rule; 
        (Tag:8; Q:6; Act:2), //Reduce Rule; 
        (Tag:9; Q:6; Act:2), //Reduce Rule; 
        (Tag:10; Q:6; Act:2), //Reduce Rule; 
        (Tag:12; Q:6; Act:2), //Reduce Rule; 
        (Tag:13; Q:6; Act:2), //Reduce Rule; 
        (Tag:14; Q:6; Act:2), //Reduce Rule; 
        (Tag:15; Q:6; Act:2), //Reduce Rule; 
        (Tag:16; Q:6; Act:2), //Reduce Rule; 
        (Tag:29; Q:6; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState40: packed array[0..15] of TParseEdge= (
        (Tag:17; Q:46; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:47; Act:3), //Goto; 
        (Tag:6; Q:11; Act:2), //Reduce Rule; 
        (Tag:7; Q:11; Act:2), //Reduce Rule; 
        (Tag:8; Q:11; Act:2), //Reduce Rule; 
        (Tag:9; Q:11; Act:2), //Reduce Rule; 
        (Tag:10; Q:11; Act:2), //Reduce Rule; 
        (Tag:12; Q:11; Act:2), //Reduce Rule; 
        (Tag:13; Q:11; Act:2), //Reduce Rule; 
        (Tag:14; Q:11; Act:2), //Reduce Rule; 
        (Tag:15; Q:11; Act:2), //Reduce Rule; 
        (Tag:16; Q:11; Act:2), //Reduce Rule; 
        (Tag:29; Q:11; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState41: packed array[0..13] of TParseEdge= (
        (Tag:11; Q:48; Act:1), //Shift; 
        (Tag:22; Q:49; Act:1), //Shift; 
        (Tag:24; Q:50; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:37; Q:51; Act:3), //Goto; 
        (Tag:38; Q:52; Act:3), //Goto; 
        (Tag:44; Q:53; Act:3), //Goto; 
        (Tag:0; Q:21; Act:2), //Reduce Rule; 
        (Tag:6; Q:21; Act:2), //Reduce Rule; 
        (Tag:19; Q:21; Act:2), //Reduce Rule; 
        (Tag:20; Q:21; Act:2), //Reduce Rule; 
        (Tag:34; Q:21; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState42: packed array[0..13] of TParseEdge= (
        (Tag:11; Q:48; Act:1), //Shift; 
        (Tag:22; Q:49; Act:1), //Shift; 
        (Tag:24; Q:50; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:37; Q:51; Act:3), //Goto; 
        (Tag:38; Q:54; Act:3), //Goto; 
        (Tag:44; Q:53; Act:3), //Goto; 
        (Tag:0; Q:27; Act:2), //Reduce Rule; 
        (Tag:6; Q:27; Act:2), //Reduce Rule; 
        (Tag:19; Q:27; Act:2), //Reduce Rule; 
        (Tag:20; Q:27; Act:2), //Reduce Rule; 
        (Tag:34; Q:27; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState43: packed array[0..6] of TParseEdge= (
        (Tag:19; Q:55; Act:1), //Shift; 
        (Tag:20; Q:42; Act:1), //Shift; 
        (Tag:42; Q:56; Act:3), //Goto; 
        (Tag:0; Q:20; Act:2), //Reduce Rule; 
        (Tag:6; Q:20; Act:2), //Reduce Rule; 
        (Tag:34; Q:20; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState44: packed array[0..5] of TParseEdge= (
        (Tag:0; Q:24; Act:2), //Reduce Rule; 
        (Tag:6; Q:24; Act:2), //Reduce Rule; 
        (Tag:19; Q:24; Act:2), //Reduce Rule; 
        (Tag:20; Q:24; Act:2), //Reduce Rule; 
        (Tag:34; Q:24; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState45: packed array[0..2] of TParseEdge= (
        (Tag:30; Q:15; Act:2), //Reduce Rule; 
        (Tag:32; Q:15; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState46: packed array[0..3] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:57; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState47: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:34; Act:2), //Reduce Rule; 
        (Tag:7; Q:34; Act:2), //Reduce Rule; 
        (Tag:8; Q:34; Act:2), //Reduce Rule; 
        (Tag:9; Q:34; Act:2), //Reduce Rule; 
        (Tag:10; Q:34; Act:2), //Reduce Rule; 
        (Tag:12; Q:34; Act:2), //Reduce Rule; 
        (Tag:13; Q:34; Act:2), //Reduce Rule; 
        (Tag:14; Q:34; Act:2), //Reduce Rule; 
        (Tag:15; Q:34; Act:2), //Reduce Rule; 
        (Tag:16; Q:34; Act:2), //Reduce Rule; 
        (Tag:17; Q:34; Act:2), //Reduce Rule; 
        (Tag:29; Q:34; Act:2), //Reduce Rule; 
        (Tag:30; Q:34; Act:2), //Reduce Rule; 
        (Tag:32; Q:34; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState48: packed array[0..3] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:58; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState49: packed array[0..3] of TParseEdge= (
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:44; Q:59; Act:3), //Goto; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState50: packed array[0..10] of TParseEdge= (
        (Tag:0; Q:33; Act:2), //Reduce Rule; 
        (Tag:6; Q:33; Act:2), //Reduce Rule; 
        (Tag:11; Q:33; Act:2), //Reduce Rule; 
        (Tag:19; Q:33; Act:2), //Reduce Rule; 
        (Tag:20; Q:33; Act:2), //Reduce Rule; 
        (Tag:22; Q:33; Act:2), //Reduce Rule; 
        (Tag:24; Q:33; Act:2), //Reduce Rule; 
        (Tag:30; Q:33; Act:2), //Reduce Rule; 
        (Tag:32; Q:33; Act:2), //Reduce Rule; 
        (Tag:34; Q:33; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState51: packed array[0..10] of TParseEdge= (
        (Tag:0; Q:29; Act:2), //Reduce Rule; 
        (Tag:6; Q:29; Act:2), //Reduce Rule; 
        (Tag:11; Q:29; Act:2), //Reduce Rule; 
        (Tag:19; Q:29; Act:2), //Reduce Rule; 
        (Tag:20; Q:29; Act:2), //Reduce Rule; 
        (Tag:22; Q:29; Act:2), //Reduce Rule; 
        (Tag:24; Q:29; Act:2), //Reduce Rule; 
        (Tag:30; Q:29; Act:2), //Reduce Rule; 
        (Tag:32; Q:29; Act:2), //Reduce Rule; 
        (Tag:34; Q:29; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState52: packed array[0..12] of TParseEdge= (
        (Tag:11; Q:48; Act:1), //Shift; 
        (Tag:22; Q:49; Act:1), //Shift; 
        (Tag:24; Q:50; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:37; Q:60; Act:3), //Goto; 
        (Tag:44; Q:53; Act:3), //Goto; 
        (Tag:0; Q:22; Act:2), //Reduce Rule; 
        (Tag:6; Q:22; Act:2), //Reduce Rule; 
        (Tag:19; Q:22; Act:2), //Reduce Rule; 
        (Tag:20; Q:22; Act:2), //Reduce Rule; 
        (Tag:34; Q:22; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState53: packed array[0..10] of TParseEdge= (
        (Tag:0; Q:30; Act:2), //Reduce Rule; 
        (Tag:6; Q:30; Act:2), //Reduce Rule; 
        (Tag:11; Q:30; Act:2), //Reduce Rule; 
        (Tag:19; Q:30; Act:2), //Reduce Rule; 
        (Tag:20; Q:30; Act:2), //Reduce Rule; 
        (Tag:22; Q:30; Act:2), //Reduce Rule; 
        (Tag:24; Q:30; Act:2), //Reduce Rule; 
        (Tag:30; Q:30; Act:2), //Reduce Rule; 
        (Tag:32; Q:30; Act:2), //Reduce Rule; 
        (Tag:34; Q:30; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState54: packed array[0..12] of TParseEdge= (
        (Tag:11; Q:48; Act:1), //Shift; 
        (Tag:22; Q:49; Act:1), //Shift; 
        (Tag:24; Q:50; Act:1), //Shift; 
        (Tag:30; Q:32; Act:1), //Shift; 
        (Tag:32; Q:33; Act:1), //Shift; 
        (Tag:37; Q:60; Act:3), //Goto; 
        (Tag:44; Q:53; Act:3), //Goto; 
        (Tag:0; Q:26; Act:2), //Reduce Rule; 
        (Tag:6; Q:26; Act:2), //Reduce Rule; 
        (Tag:19; Q:26; Act:2), //Reduce Rule; 
        (Tag:20; Q:26; Act:2), //Reduce Rule; 
        (Tag:34; Q:26; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState55: packed array[0..3] of TParseEdge= (
        (Tag:0; Q:19; Act:2), //Reduce Rule; 
        (Tag:6; Q:19; Act:2), //Reduce Rule; 
        (Tag:34; Q:19; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState56: packed array[0..5] of TParseEdge= (
        (Tag:0; Q:23; Act:2), //Reduce Rule; 
        (Tag:6; Q:23; Act:2), //Reduce Rule; 
        (Tag:19; Q:23; Act:2), //Reduce Rule; 
        (Tag:20; Q:23; Act:2), //Reduce Rule; 
        (Tag:34; Q:23; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState57: packed array[0..14] of TParseEdge= (
        (Tag:6; Q:35; Act:2), //Reduce Rule; 
        (Tag:7; Q:35; Act:2), //Reduce Rule; 
        (Tag:8; Q:35; Act:2), //Reduce Rule; 
        (Tag:9; Q:35; Act:2), //Reduce Rule; 
        (Tag:10; Q:35; Act:2), //Reduce Rule; 
        (Tag:12; Q:35; Act:2), //Reduce Rule; 
        (Tag:13; Q:35; Act:2), //Reduce Rule; 
        (Tag:14; Q:35; Act:2), //Reduce Rule; 
        (Tag:15; Q:35; Act:2), //Reduce Rule; 
        (Tag:16; Q:35; Act:2), //Reduce Rule; 
        (Tag:17; Q:35; Act:2), //Reduce Rule; 
        (Tag:29; Q:35; Act:2), //Reduce Rule; 
        (Tag:30; Q:35; Act:2), //Reduce Rule; 
        (Tag:32; Q:35; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState58: packed array[0..10] of TParseEdge= (
        (Tag:0; Q:31; Act:2), //Reduce Rule; 
        (Tag:6; Q:31; Act:2), //Reduce Rule; 
        (Tag:11; Q:31; Act:2), //Reduce Rule; 
        (Tag:19; Q:31; Act:2), //Reduce Rule; 
        (Tag:20; Q:31; Act:2), //Reduce Rule; 
        (Tag:22; Q:31; Act:2), //Reduce Rule; 
        (Tag:24; Q:31; Act:2), //Reduce Rule; 
        (Tag:30; Q:31; Act:2), //Reduce Rule; 
        (Tag:32; Q:31; Act:2), //Reduce Rule; 
        (Tag:34; Q:31; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState59: packed array[0..10] of TParseEdge= (
        (Tag:0; Q:32; Act:2), //Reduce Rule; 
        (Tag:6; Q:32; Act:2), //Reduce Rule; 
        (Tag:11; Q:32; Act:2), //Reduce Rule; 
        (Tag:19; Q:32; Act:2), //Reduce Rule; 
        (Tag:20; Q:32; Act:2), //Reduce Rule; 
        (Tag:22; Q:32; Act:2), //Reduce Rule; 
        (Tag:24; Q:32; Act:2), //Reduce Rule; 
        (Tag:30; Q:32; Act:2), //Reduce Rule; 
        (Tag:32; Q:32; Act:2), //Reduce Rule; 
        (Tag:34; Q:32; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseState60: packed array[0..10] of TParseEdge= (
        (Tag:0; Q:28; Act:2), //Reduce Rule; 
        (Tag:6; Q:28; Act:2), //Reduce Rule; 
        (Tag:11; Q:28; Act:2), //Reduce Rule; 
        (Tag:19; Q:28; Act:2), //Reduce Rule; 
        (Tag:20; Q:28; Act:2), //Reduce Rule; 
        (Tag:22; Q:28; Act:2), //Reduce Rule; 
        (Tag:24; Q:28; Act:2), //Reduce Rule; 
        (Tag:30; Q:28; Act:2), //Reduce Rule; 
        (Tag:32; Q:28; Act:2), //Reduce Rule; 
        (Tag:34; Q:28; Act:2), //Reduce Rule; 
        (Tag:Any; Q:  0; Act:  0) );
const ParseStateList: packed array[TState] of TEntry= (
        (EntryPtr:@ParseState0;	EdgeCnt:13),
        (EntryPtr:@ParseState1;	EdgeCnt:12),
        (EntryPtr:@ParseState2;	EdgeCnt:1),
        (EntryPtr:@ParseState3;	EdgeCnt:4),
        (EntryPtr:@ParseState4;	EdgeCnt:4),
        (EntryPtr:@ParseState5;	EdgeCnt:1),
        (EntryPtr:@ParseState6;	EdgeCnt:4),
        (EntryPtr:@ParseState7;	EdgeCnt:4),
        (EntryPtr:@ParseState8;	EdgeCnt:4),
        (EntryPtr:@ParseState9;	EdgeCnt:1),
        (EntryPtr:@ParseState10;	EdgeCnt:4),
        (EntryPtr:@ParseState11;	EdgeCnt:4),
        (EntryPtr:@ParseState12;	EdgeCnt:1),
        (EntryPtr:@ParseState13;	EdgeCnt:11),
        (EntryPtr:@ParseState14;	EdgeCnt:11),
        (EntryPtr:@ParseState15;	EdgeCnt:6),
        (EntryPtr:@ParseState16;	EdgeCnt:1),
        (EntryPtr:@ParseState17;	EdgeCnt:4),
        (EntryPtr:@ParseState18;	EdgeCnt:11),
        (EntryPtr:@ParseState19;	EdgeCnt:4),
        (EntryPtr:@ParseState20;	EdgeCnt:4),
        (EntryPtr:@ParseState21;	EdgeCnt:4),
        (EntryPtr:@ParseState22;	EdgeCnt:11),
        (EntryPtr:@ParseState23;	EdgeCnt:4),
        (EntryPtr:@ParseState24;	EdgeCnt:4),
        (EntryPtr:@ParseState25;	EdgeCnt:11),
        (EntryPtr:@ParseState26;	EdgeCnt:1),
        (EntryPtr:@ParseState27;	EdgeCnt:1),
        (EntryPtr:@ParseState28;	EdgeCnt:1),
        (EntryPtr:@ParseState29;	EdgeCnt:3),
        (EntryPtr:@ParseState30;	EdgeCnt:7),
        (EntryPtr:@ParseState31;	EdgeCnt:1),
        (EntryPtr:@ParseState32;	EdgeCnt:21),
        (EntryPtr:@ParseState33;	EdgeCnt:21),
        (EntryPtr:@ParseState34;	EdgeCnt:14),
        (EntryPtr:@ParseState35;	EdgeCnt:15),
        (EntryPtr:@ParseState36;	EdgeCnt:15),
        (EntryPtr:@ParseState37;	EdgeCnt:15),
        (EntryPtr:@ParseState38;	EdgeCnt:15),
        (EntryPtr:@ParseState39;	EdgeCnt:15),
        (EntryPtr:@ParseState40;	EdgeCnt:15),
        (EntryPtr:@ParseState41;	EdgeCnt:13),
        (EntryPtr:@ParseState42;	EdgeCnt:13),
        (EntryPtr:@ParseState43;	EdgeCnt:6),
        (EntryPtr:@ParseState44;	EdgeCnt:5),
        (EntryPtr:@ParseState45;	EdgeCnt:2),
        (EntryPtr:@ParseState46;	EdgeCnt:3),
        (EntryPtr:@ParseState47;	EdgeCnt:14),
        (EntryPtr:@ParseState48;	EdgeCnt:3),
        (EntryPtr:@ParseState49;	EdgeCnt:3),
        (EntryPtr:@ParseState50;	EdgeCnt:10),
        (EntryPtr:@ParseState51;	EdgeCnt:10),
        (EntryPtr:@ParseState52;	EdgeCnt:12),
        (EntryPtr:@ParseState53;	EdgeCnt:10),
        (EntryPtr:@ParseState54;	EdgeCnt:12),
        (EntryPtr:@ParseState55;	EdgeCnt:3),
        (EntryPtr:@ParseState56;	EdgeCnt:5),
        (EntryPtr:@ParseState57;	EdgeCnt:14),
        (EntryPtr:@ParseState58;	EdgeCnt:10),
        (EntryPtr:@ParseState59;	EdgeCnt:10),
        (EntryPtr:@ParseState60;	EdgeCnt:10),
        (EntryPtr:Nil; EdgeCnt:0 ));  
const ReduceTable: packed array [0..39] of record Cnt:Byte; Tag:TTokenTag; end = (
    { 0} (Cnt:4; Tag:49),	//YACCGRAMMAR_PERCENTPERCENT,
    { 1} (Cnt:2; Tag:47),	//TOKENS,
    { 2} (Cnt:0; Tag:47),	//TOKENS2,
    { 3} (Cnt:2; Tag:46),	//TOKEN_PERCENTSTART_IDENTIFIER,
    { 4} (Cnt:2; Tag:46),	//TOKEN_PERCENTUNION_ACTION,
    { 5} (Cnt:2; Tag:46),	//TOKEN_PERCENTEXPECT_NUMBER,
    { 6} (Cnt:3; Tag:46),	//TOKEN_PERCENTTOKEN,
    { 7} (Cnt:3; Tag:46),	//TOKEN_PERCENTLEFT,
    { 8} (Cnt:3; Tag:46),	//TOKEN_PERCENTRIGHT,
    { 9} (Cnt:3; Tag:46),	//TOKEN_PERCENTBINARY,
    {10} (Cnt:3; Tag:46),	//TOKEN_PERCENTNONASSOC,
    {11} (Cnt:3; Tag:46),	//TOKEN_PERCENTTYPE,
    {12} (Cnt:1; Tag:46),	//TOKEN_DECLARATIONCODE,
    {13} (Cnt:1; Tag:36),	//ENDMARKEROPT_PERCENTPERCENT,
    {14} (Cnt:0; Tag:36),	//ENDMARKEROPT,
    {15} (Cnt:3; Tag:48),	//UNIONNAMEOPT_LT_IDENTIFIER_GT,
    {16} (Cnt:0; Tag:48),	//UNIONNAMEOPT,
    {17} (Cnt:2; Tag:43),	//RULES,
    {18} (Cnt:0; Tag:43),	//RULES2,
    {19} (Cnt:3; Tag:39),	//RULE_SEMI,
    {20} (Cnt:2; Tag:39),	//RULE,
    {21} (Cnt:2; Tag:41),	//RULEHEAD_RULENAME_COLON,
    {22} (Cnt:3; Tag:41),	//RULEHEAD_RULENAME_COLON2,
    {23} (Cnt:2; Tag:40),	//RULEBODY,
    {24} (Cnt:1; Tag:40),	//RULEBODY2,
    {25} (Cnt:0; Tag:40),	//RULEBODY3,
    {26} (Cnt:2; Tag:42),	//RULEOPT_PIPE,
    {27} (Cnt:1; Tag:42),	//RULEOPT_PIPE2,
    {28} (Cnt:2; Tag:38),	//ITEMLIST,
    {29} (Cnt:1; Tag:38),	//ITEMLIST2,
    {30} (Cnt:1; Tag:37),	//ITEM,
    {31} (Cnt:2; Tag:37),	//ITEM_PERCENTPREC,
    {32} (Cnt:2; Tag:37),	//ITEM_EQ,
    {33} (Cnt:1; Tag:37),	//ITEM_ACTION,
    {34} (Cnt:2; Tag:45),	//SYMBOLS,
    {35} (Cnt:3; Tag:45),	//SYMBOLS_COMMA,
    {36} (Cnt:1; Tag:45),	//SYMBOLS2,
    {37} (Cnt:1; Tag:44),	//SYMBOL_IDENTIFIER,
    {38} (Cnt:1; Tag:44),	//SYMBOL_LITERAL,
    {39} (Cnt:0; Tag:ActError)
  );
  {}
  {}   
  {...........................................................................}
  procedure DebugStacks;
  {...........................................................................}
  var S:PState; T:PToken; N0,N1,k:Integer;
  begin
    S:=StateStack; N1:=1;
    while S<>StateStackTop do begin inc(S); inc(N1); end;
    if N1>12 then N0:=N1-12 else N0:=1;
    S:=StateStack; for k:=2 to N0 do inc(S);
    T:=TokenStack; for k:=2 to N0 do inc(T);
    write(Fo^,'  StateStack[',N0:1,'..',N1:1,']=[',S^:3);
    for k:=N0+1 to N1 do begin inc(S); write(Fo^,',',S^:3); end;
    writeln(Fo^,']');
    write(Fo^,'  TokenStack[',N0:1,'..',N1:1,']=[',T^.Tag:3);
    for k:=N0+1 to N1 do begin inc(T); write(Fo^,',',T^.Tag:3); end;
    writeln(Fo^,']');
  end;
  {} 
  {...........................................................................}
  function GetParseEdge(Tag:TTokenTag):PParseEdge;
  {...........................................................................}
  // returns the transition to a next state, or last tarnsition of an EdgeList
  var EdgePtr:PParseEdge; k:Integer;
  begin
    EdgePtr :=ParseStateList[StateStackTop^].EntryPtr;
    for k:=1 to ParseStateList[StateStackTop^].EdgeCnt do begin
      if (EdgePtr^.Tag=Tag) then break;
      inc(EdgePtr);
    end;  
    GetParseEdge:=EdgePtr;
  end;
  {}
  {...........................................................................}
  function GetExpect:TTokenTag;
  {...........................................................................}
  //inquire the parse tables, to identify what token was expected
  var EdgePtr:PParseEdge; Expect:TTokenTag; k,OK:Integer;
  begin
    OK:=0; Expect:=TagAny;
    EdgePtr :=ParseStateList[StateStackTop^].EntryPtr;
    for k:=1 to ParseStateList[StateStackTop^].EdgeCnt do begin
      if (EdgePtr^.Tag<>Tag_SynError) then begin
        //to do: give priority of ActReduce over ActShift/ActGoto
        inc(OK); Expect:=EdgePtr^.Tag;
      end;  
      inc(EdgePtr);
    end;
    if OK<>1 then Expect:=Token.Tag;
    GetExpect:=Expect;
  end;
  {}
  {...........................................................................}
  function HandleError:Boolean;
  {...........................................................................}
  var  EdgePtr:PParseEdge;  Invalidated:Integer;  NewError:Boolean;
  begin
    //[Step 1] check if previous repair has failed
    //NewError:=(HasShifted or (ErrorStatePtr<>StateStackTop) or (ErrorState<>StateStackTop^)); //??
    NewError:=HasShifted;
    Invalidated  := 0;
    HasShifted   := False;
    ErrorStatePtr:= StateStackTop;
    ErrorState   := StateStackTop^;    
    //[Step 2] report the error, if it is a new one
    if NewError then begin
      inc(ErrorCnt);
      if (ErrorCnt<=ErrorMax) then begin
        TokenStackTop^.Tag:=GetExpect;
        DoError(-StateStackTop^,TokenStackTop);
        TokenStackTop^.Tag:=Token.Tag;
      end else begin
        DoError(Err_Overflow, TokenStackTop);
        HandleError:=False;
        Exit;
      end;
    end;
    //[Step 3] remove processed tokens, until an error-token is found with a shift action
    repeat
      if (TokenStackTop=TokenStack) then begin
         DoError(Err_Halted,TokenStackTop);
         HandleError:=False;
         exit; //error unsolveable due to lack of adequate error production
      end;
      if NewError or (Invalidated>1) then begin
        EdgePtr:=GetParseEdge(Tag_SynError);
        if  (EdgePtr^.Tag<>TagAny) and (EdgePtr^.Act=ActShift) then break;
      end;
      DoCleanup(TokenStackTop);
      dec(TokenStackTop);
      dec(StateStackTop);
      inc(Invalidated);
    until false;
    //[Step 4] push error on the stack, with position info on the error
    TokenStackTop^.Tag:=Tag_SynError;
    //[Step 5] skip tokens, and push the first valid one on the stack
    inc(StateStackTop); StateStackTop^:=EdgePtr^.Q;
    inc(TokenStackTop); TokenStackTop^:=Token;
    while GetParseEdge(Token.Tag)^.Tag=TagAny do begin
      if Token.Tag=Tag_EOF then break;
      GetToken; HasShifted:=True;
      TokenStackTop^:=Token;
      inc(Invalidated);
    end;
    {$IFDEF Debug_ERRORS} if (Invalidated>0) then DoError(Err_Skipped,TokenStackTop); {$ENDIF}
    HandleError:=(Token.Tag<>Tag_EOF);
  end;
  {}
label ParseNext, ParseDone, ParseOverflow;
var   Cnt,RuleNr:Integer;
      EdgePtr:PParseEdge;
      TopToken:TToken;
begin
  GetToken; HasShifted:=True;
  ErrorState:=StartState;
  ErrorStatePtr:=Nil;
  GetMem(TokenStack, StackSize*sizeof(TokenStackTop^));
  GetMem(StateStack, StackSize*sizeof(StateStackTop^));
  TokenStackTop :=TokenStack;
  TokenStackTop^:=Token;
  StateStackTop :=StateStack;
  StateStackEnd :=StateStack; inc(StateStackEnd,StackSize-1);
  StateStackTop^:=StartState;
ParseNext: //Repeat
  if (StateStackTop=StateStackEnd) then goto ParseOverflow;
  {$IFDEF Debug_PARSER}
    DebugStacks;
    write (Fo^,'      (State=', StateStackTop^:2,', Tag=',TokenStackTop^.Tag:2,' ==> ');
  {$ENDIF}
  EdgePtr:=GetParseEdge(TokenStackTop^.Tag);
  case EdgePtr^.Act of
    ActError:
       begin {invalidate several tokens, in an attempt to recover from this error}
         {$IFDEF Debug_PARSER} writeln(Fo^,'Error)'); {$ENDIF}
         //first reduce to the highest rule, before handling the error
         EdgePtr:=GetParseEdge(Tag_SynError);
         if (EdgePtr^.Tag<>TagAny) and (EdgePtr^.Act<>1) then begin
           TokenStackTop^.Tag:=Tag_SynError;
           goto ParseNext;
         end;
         if HandleError then goto ParseNext else goto ParseDone;
       end;
    ActShift:
       begin {read and push another token on the stack, and analyze again }
         {$IFDEF Debug_PARSER} writeln(Fo^,'Q=', EdgePtr^.Q:2,', Shift)'); {$ENDIF}
         GetToken; HasShifted:=True;
         inc(StateStackTop); StateStackTop^:=EdgePtr^.Q;
         inc(TokenStackTop); TokenStackTop^:=Token;
         goto ParseNext;
       end;
    ActReduce: 
       begin {replace several tokens, by a single one, representing a rule}
         {$IFDEF Debug_PARSER} write (Fo^,'Q=', EdgePtr^.Q:2,', Reduce'); {$ENDIF}
         RuleNr:=EdgePtr^.Q;
         Cnt:=ReduceTable[RuleNr].Cnt;
         dec(TokenStackTop,Cnt);
         dec(StateStackTop,Cnt);
         {$IFDEF  Debug_PARSER} WriteLn(Fo^,'By ',Cnt,')'); {$ENDIF}
         DoAction(PTokenList(TokenStackTop), RuleNr, Cnt);
         TokenStackTop^.Tag:=ReduceTable[RuleNr].Tag;
         TokenStackTop^.Kind:=0; //flag this token as a "non-terminal" token
         goto ParseNext;
       end;
    ActNext: 
       begin {analyze again, but now from another state}
         {$IFDEF Debug_PARSER} writeln(Fo^,'Q=', EdgePtr^.Q:2,', Next)'); {$ENDIF}
         inc(StateStackTop); StateStackTop^:=EdgePtr^.Q;
         inc(TokenStackTop); TokenStackTop^:=Token;
         goto ParseNext;
       end;
    ActAccept:
         begin {startsymbol found, all parsing can be finished}
         {$IFDEF Debug_PARSER} writeln(Fo^,'Q=', EdgePtr^.Q:2,', Accept)'); {$ENDIF}
         dec(TokenStackTop);
         dec(StateStackTop);
         goto ParseDone;
       end;
  end {case};
ParseOverflow:
  DoError(Err_StackOverflow,Nil);
  inc(ErrorCnt);
ParseDone:
  while (TokenStackTop<>TokenStack) do begin //clean up
    DoCleanup(TokenStackTop);
    dec(TokenStackTop);
  end;
  TopToken:=TokenStackTop^;
  FreeMem(TokenStack, StackSize*sizeof(TokenStackTop^));
  FreeMem(StateStack, StackSize*sizeof(StateStackTop^));
  if (ErrorCnt=0) then DoAccept(@TopToken);
  {$IFDEF Debug_HEAPMEM} ShowMem('MemUsage, at Parse accept'); {$ENDIF}
  DoCleanup(@TopToken);
  {$IFDEF Debug_HEAPMEM} ShowMem('MemUsage, at Parse finish'); {$ENDIF}
  DoParse:=ErrorCnt;
end; {TParser.DoParse}


{-----------------------------------------------------------------------------}
Function TParser.TreeBuild(T:PTokenList; RuleNr,Cnt:Integer):PTokenTree;
{-----------------------------------------------------------------------------}
var k:Integer; Size:Integer; Dummy:TTokenTree;
begin
  if Cnt=0 then begin
    Result:=Nil;
  end else
  if (Cnt=1) and (T^[1].Kind=0) then begin
    Result:=T^[1].Lnk; //keep
  end else begin
    Size:=sizeof(Integer)+sizeof(Byte)+Cnt*sizeof(Dummy.Tok[1]);
    getmem(Result, Size);
    Result^.Cnt:=Cnt;
    Result^.Rule:=RuleNr;
    for k:=1 to Cnt do Result^.Tok[k]:=T^[k];
  end;
end;


{-----------------------------------------------------------------------------}
Procedure TParser.TreeDone(Root:PTokenTree);
{-----------------------------------------------------------------------------}
var k:Integer; Size:Integer; Dummy:TTokenTree;
begin
  if Root=Nil then exit;
  for k:=Root^.Cnt downto 1 do DoCleanup(@Root^.Tok[k]);
  Size:=sizeof(Integer)+sizeof(Byte)+Root^.Cnt*sizeof(Dummy.Tok[1]);
  freemem(Root,Size);
end;  


{-----------------------------------------------------------------------------}
procedure TParser.TreeShow(Root:PToken);
{-----------------------------------------------------------------------------}
  {}
  procedure DoDumpNodes(Margin:Integer; Tok:PToken);
  var Node:PTokenTree; k,N:Integer;  s:String;
  begin
    if (Tok^.Kind=0) then begin
      Node:=Tok^.Lnk;
      if Node=Nil then exit;
      for k:=1 to Node^.Cnt do DoDumpNodes(Margin+1, @Node^.Tok[k]); //children
    end else begin
      case Tok^.Tag of
        TAG_RULENAME:       begin
                              writeln(Fo^);
                              writeln(Fo^);
                              s:=Tok^.Lex^;
                              //setlength(S,length(S)-1);
                              write(Fo^,'<',s,'>');  N:=length(S)+2;
                              for k:=N+1 to 14+8 do write(Fo^,' ');
                              if N<=14+8
                              then write(Fo^,'::= ')
                              else begin writeln(Fo^); write(Fo^,Tab,Tab,'      ::= '); end;
                            end;
        TAG_PIPE:           begin
                              writeln(Fo^);
                              write(Fo^,Tab,Tab,Tab,'| ');
                            end;
        TAG_IDENTIFIER:     write(Fo^,'<',Tok^.Lex^,'> ');
        TAG_LITERAL,
        TAG_NUMBER:         write(Fo^,Tok^.Lex^, ' ');
  
        TAG_PERCENTSTART:   begin   // Kind=1 '%start'
                              writeln(Fo^);
                              write(Fo^,'"Start Symbol"  = ');
                            end;
        TAG_PERCENTBINARY,    // Kind=1 '%binary'
        TAG_PERCENTEXPECT,    // Kind=1 '%expect'
        TAG_PERCENTLEFT,      // Kind=1 '%left'
        TAG_PERCENTNONASSOC,  // Kind=1 '%nonassoc'
        TAG_PERCENTRIGHT,     // Kind=1 '%right'
        TAG_PERCENTTOKEN,     // Kind=1 '%token'
        TAG_PERCENTTYPE,      // Kind=1 '%type'
        TAG_PERCENTUNION:     // Kind=1 '%union'
                            begin
                              writeln(Fo^);
                              write(Fo^,'! ',Tok^.Lex^,tab);
                             end;
        TAG_PERCENTPREC:    {nothing};  // Kind=1 '%prec'
      end;
    end;
  end;  
begin
  DoDumpNodes(0,Root);
end;
  


{$ifndef Debug_TREE}
{-----------------------------------------------------------------------------}
procedure TParser.TreeDump(Root:PToken);
{-----------------------------------------------------------------------------}
begin
end;


{$else  Debug_TREE}
{-----------------------------------------------------------------------------}
Procedure TParser.TreeDump(Root:PToken);
{-----------------------------------------------------------------------------}
  {}
  function RuleName(RuleNr:Integer):String;
  begin
    case RuleNr of
       0: Result:='YACCGRAMMAR_PERCENTPERCENT   '; // <YACC Grammar> ::= <Tokens> %% <Rules> <End Marker Opt>
       1: Result:='TOKENS                       '; // <Tokens> ::= <Tokens> <Token>
       2: Result:='TOKENS2                      '; // <Tokens> ::= 
       3: Result:='TOKEN_PERCENTSTART_IDENTIFIER'; // <Token> ::= %start Identifier
       4: Result:='TOKEN_PERCENTUNION_ACTION    '; // <Token> ::= %union Action
       5: Result:='TOKEN_PERCENTEXPECT_NUMBER   '; // <Token> ::= %expect Number
       6: Result:='TOKEN_PERCENTTOKEN           '; // <Token> ::= %token <Union Name Opt> <Symbols>
       7: Result:='TOKEN_PERCENTLEFT            '; // <Token> ::= %left <Union Name Opt> <Symbols>
       8: Result:='TOKEN_PERCENTRIGHT           '; // <Token> ::= %right <Union Name Opt> <Symbols>
       9: Result:='TOKEN_PERCENTBINARY          '; // <Token> ::= %binary <Union Name Opt> <Symbols>
      10: Result:='TOKEN_PERCENTNONASSOC        '; // <Token> ::= %nonassoc <Union Name Opt> <Symbols>
      11: Result:='TOKEN_PERCENTTYPE            '; // <Token> ::= %type <Union Name Opt> <Symbols>
      12: Result:='TOKEN_DECLARATIONCODE        '; // <Token> ::= DeclarationCode
      13: Result:='ENDMARKEROPT_PERCENTPERCENT  '; // <End Marker Opt> ::= %%
      14: Result:='ENDMARKEROPT                 '; // <End Marker Opt> ::= 
      15: Result:='UNIONNAMEOPT_LT_IDENTIFIER_GT'; // <Union Name Opt> ::= < Identifier >
      16: Result:='UNIONNAMEOPT                 '; // <Union Name Opt> ::= 
      17: Result:='RULES                        '; // <Rules> ::= <Rules> <Rule>
      18: Result:='RULES2                       '; // <Rules> ::= 
      19: Result:='RULE_SEMI                    '; // <Rule> ::= <RuleHead> <RuleBody> ;
      20: Result:='RULE                         '; // <Rule> ::= <RuleHead> <RuleBody>
      21: Result:='RULEHEAD_RULENAME_COLON      '; // <RuleHead> ::= RuleName :
      22: Result:='RULEHEAD_RULENAME_COLON2     '; // <RuleHead> ::= RuleName : <ItemList>
      23: Result:='RULEBODY                     '; // <RuleBody> ::= <RuleBody> <RuleOpt>
      24: Result:='RULEBODY2                    '; // <RuleBody> ::= <RuleOpt>
      25: Result:='RULEBODY3                    '; // <RuleBody> ::= 
      26: Result:='RULEOPT_PIPE                 '; // <RuleOpt> ::= | <ItemList>
      27: Result:='RULEOPT_PIPE2                '; // <RuleOpt> ::= |
      28: Result:='ITEMLIST                     '; // <ItemList> ::= <ItemList> <Item>
      29: Result:='ITEMLIST2                    '; // <ItemList> ::= <Item>
      30: Result:='ITEM                         '; // <Item> ::= <Symbol>
      31: Result:='ITEM_PERCENTPREC             '; // <Item> ::= %prec <Symbol>
      32: Result:='ITEM_EQ                      '; // <Item> ::= = <Symbol>
      33: Result:='ITEM_ACTION                  '; // <Item> ::= Action
      34: Result:='SYMBOLS                      '; // <Symbols> ::= <Symbols> <Symbol>
      35: Result:='SYMBOLS_COMMA                '; // <Symbols> ::= <Symbols> , <Symbol>
      36: Result:='SYMBOLS2                     '; // <Symbols> ::= <Symbol>
      37: Result:='SYMBOL_IDENTIFIER            '; // <Symbol> ::= Identifier
      38: Result:='SYMBOL_LITERAL               '; // <Symbol> ::= Literal
      else Result:='?????';
    end;
  end;
  {}
  procedure DoShowNodes(Margin:Integer; Tok:PToken);
  var Node:PTokenTree; k:Integer;
  begin
  if margin>100 then exit;
    if (Tok^.Kind=0) then begin
      Node:=Tok^.Lnk;
      if Node=Nil then exit;
      for k:=1 to Margin do write(Fo^,'| ');
      writeln(Fo^,'<',Node^.Rule,'> = ',RuleName(Node^.Rule),'(',Node^.Cnt,')');
      DoShowNodes(Margin, @Node^.Tok[1]); //Parent
      for k:=2 to Node^.Cnt do DoShowNodes(Margin+1, @Node^.Tok[k]); //children
    end else begin
      for k:=1 to Margin do write(Fo^,'| ');
      write(Fo^,'#',Tok^.Tag,'-@(',Tok^.LinePos,':',Tok^.CharPos,')');
      writeln(Fo^,Tab,' = "',Tok^.Lex^,'"');
    end;
  end;
  {}
var Cnt,k,m:Integer;
begin
  DoShowToken(0,Root);
end;
{$endif Debug_TREE}






var Parser:TParser;
    ErrorCnt:Integer;
begin
  if ParamCount=0 then begin
    Writeln(' Usage:   yacc2gold Infile ');
    Writeln(' Usage:   yacc2gold Infile OutFile');
    Writeln(' Usage:   yacc2gold Infile OutFile ErrFile');
    exit;
  end else
  if ParamCount>=1 then begin
    Fo:=@OutPut; Fe:=@OutPut; Parser.Init(ParamStr(1)); 
    WriteLn('Parsing: "',ParamStr(1),'"');
  end;
  if ParamCount>=2 then begin
    new(Fo); assign(Fo^,ParamStr(2)); rewrite(Fo^);
  end;
  if ParamCount>=3 then begin
    New(Fe); assign(Fe^,ParamStr(3)); rewrite(Fe^);
  end;
  ErrorCnt:=Parser.DoParse(1000);
  Parser.Done;
  if ErrorCnt=0
  then write('done <SUCCES>, hit <return> :=')
  else write('done <FAILED> with ',ErrorCnt,' errors, hit <return> :=');
  {if ErrorCnt>0 then} readln;
  if ParamCount>=3 then begin close(Fe^); dispose(Fe); end;
  if ParamCount>=2 then begin close(Fo^); dispose(Fo); end;
end.
