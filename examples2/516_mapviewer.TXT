Program MAPViewer_Network_Code_Direct_OnProgress;

//#sign 7 PM max: MAXBOX8: 9/30/2014 7:55:20 PM  PM 
//#path:C:\maXbook\maxbox3\mX3999\maxbox3\examples\
//TODO: Save the NetworkGraph to webserver_file as PNG, #locs:304
//https://code.google.com/r/atvliska-lazarus/source/browse/example/Unit1.pas
                               
Const
   
   UrlGoogleQrCode='http://chart.apis.google.com/chart?chs=%dx%d&cht=qr&chld=%s&chl=%s';
   AFILENAME= 'mX3QRCode3.png';
   QDATA= 'this is maXland on a maXbox stream dream firebox - www.softwareschule.ch';
 

{The API requires 3 simple fields be posted to it:
cht=qr this tells Google to create a QR code;
chld=M the error correction level of the QR code (see here for more info);
chs=wxh the width and height of the image to return (eg chs=250x250);
chl=text the URL encoded text to be inserted into the barcode.}

type
  TQrImage_ErrCorrLevel=(L,M,Q,H);


var
  dbform: TForm;


procedure GetQrCodeInet(Width,Height: Word; C_Level,apath: string; const Data: string);
var
  encodedURL: string;
  pngStream: TMemoryStream;
begin
  encodedURL:= Format(UrlGoogleQrCode,[Width,Height, C_Level, HTTPEncode(Data)]);
  pngStream:= TMemoryStream.create;
  HttpGet(EncodedURL, pngStream);   //WinInet
  with TLinearBitmap.Create do try
    pngStream.Position:= 0;
    LoadFromStream2(pngStream,'PNG');
    SaveToFile(apath);
    OpenDoc(apath);
  finally
    Dispose;
    Free;
    pngStream.Free;
  end;
end;



function TMapViewer_GetLongLat(X, Y, Z: Integer): TRealArea;
var
n: Extended;
 zoom: integer;
begin
{
http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
== lon/lat to tile numbers ==
n = 2 ^ zoom
xtile = ((lon_deg + 180) / 360) * n
ytile = (1 - (log(tan(lat_rad) + sec(lat_rad)) / ?)) / 2 * n
== tile numbers to lon/lat ==
n = 2 ^ zoom
lon_deg = xtile / n * 360.0 - 180.0
lat_rad = arctan(sinh(? * (1 - 2 * ytile / n)))
lat_deg = lat_rad * 180.0 / ?
}
n:= IntPower(zoom,2);
  Result.left := x / n * 360.0 - 180.0;
  Result.right := Result.left + (360.0 / n);
  Result.top := radtodeg(arctan(sinh(PI * (1 - 2 * Y / n))));
  Result.bottom := radtodeg(arctan(sinh(PI * (1 - 2 * (Y+1) / n))));
end;



procedure CreateMapForm;
 //diaform:= CreateMessageDialog('my fast form perform',mtconfirmation, []);
var 
    //dbform: TForm;
    ard: TRadioGroup;
    //mimg: TImage;
begin
   dbform:= CreateMessageDialog('My Fast Form Template - FFP',mtwarning,
                                        [mball, mbyes, mbhelp, mbok]);
   with dbform do begin
     font.size:= 12;
     caption:= 'FFP XML Demo';
     setBounds(50,50,900,700)
     FormStyle:= fsStayontop;
     //Color:= 12234;  //clWebGold;//12234;
     autoScroll:= true;
   with TLabel.Create(self) do begin
     parent:= dbform;
     SetBounds(400,60,500,600)
     font.size:= 18;
     color:= clred;
     //dblist.Add('All Converted to...XML')
     caption:= 'Network Communication City Graph...';
   end;  
   with TRadioGroup.Create(self) do begin
     parent:= dbform;
     top:= 110;
     left:= 20;
     items.add('first entry of');
     items.add('second entry off');
     items.add('third entry off');
     ItemIndex:= 2; 
     componentindex;
     //onclick:= @radioclick;
     //caption
     //writeln(Items.Strings[ItemIndex]); 
   end;
  with TBitBtn.Create(self) do begin
    Parent:= dbform;
    setbounds(570, 490,190, 40);
    caption:= 'File to Barcode';
    font.size:= 12;
    glyph.LoadFromResourceName(getHINSTANCE,'TASBARCODE'); 
    //onclick:= @GetMediaData2;
  end;
  with TBitBtn.Create(self) do begin
    Parent:= dbform;
    setbounds(570, 320,190, 150);
    caption:= 'File to Barcode';
    font.size:= 12;
    glyph.LoadFromResourceName(getHINSTANCE,'JVGAMMAPANELCOLORS'); 
    //onclick:= @GetMediaData2;
  end;
  
  {lbdaten:= TListbox.create(self)
  with lbdaten do begin
    Parent:= dbform;
    setbounds(240, 120,260, 210);
    caption:= 'File to Network';
    font.size:= 10;
    color:= clyellow;
  end;}  
  
  
   Show;
   Canvas.Draw(550,120,getBitMap(Exepath+'\examples\citymax.bmp'));

    //Barcode1.DrawText(dbform.Canvas);  

  end; //dbform
   //SelectDirectory
end;


//type
  //TMath_func = PROCEDURE(VAR x: single);

 //Form Media Tester
 var ls: Tstringlist;
     TreeView: TTreeView;
     WinMediaPlayer: TMediaPlayer;
     Bttn_list: TButton;
     Bttn_play: TButton;
     Bttn_stop: TButton;
     
 
 procedure DoBeforeDownload(Url: string; str: TStream;
var CanHandle: Boolean);
var
x: string;
f: TFileStream;
begin
x := 'cache\'+MD5(Url);
if FileExists(x) then begin
   f := TFileStream.Create(x, fmOpenRead);
   try
   str.Position := 0;
   str.CopyFrom(f, f.Size);
   str.Position := 0;
   CanHandle := True;
   finally
   f.Free;
   end;
   end
   else
   CanHandle := False;
end;

procedure DoAfterDownload(Url: string; str: TStream);
var
x: string;
f: TFileStream;
begin
   if not DirectoryExists('cache') then
   ForceDirectories('cache');
   //x := 'cache\'+MDPrint(MD5String(Url));
   x := 'cache\'+(MD5(Url));

   if (not FileExists(x)) and (not (str.Size = 0)) then begin
     f := TFileStream.Create(x, fmCreate);
    try
    str.Position := 0;
     f.CopyFrom(str, str.Size);
    finally
    f.Free;
   end;
  end;
end;

  var tst: TStrings;
     a,b,x: integer;
     xt: float;
     intlist: TIntegerlist;
     vararr: TVariantArray;
     MVGLGeoNames1: TMVGLGeoNames;
     FDownloader: TMVDESynapse; {TMVDEWin32; }

//TODO:#1 Returns the QR Code direct of the last modification of the given File

begin
  //Writeln(datetimetostr(FileTimeGMT(exepath+'maxbox3.exe')));
     //TConnectKind
     //TOleServer
      //ShowHourGlass(@fct2);
      // TShadowWindow
      //TRegistryClass
      // TAutomation
     //TThemeServices
     //TValueListEditor
     //TValueListStrings
        
  //GetQrCodeTest(150,150,'Q', 'this is maXland on the maXbox');
  //call of the script
  //GetQrCodeInet(150,150,'Q',ExePath+'mX3QRCode_3.png','this is maXland on maXbox');
   //call of the Lib
  //GetQrCode2(150,150,'Q',QDATA, ExePath+AFILENAME);
  
  CreateMapForm;
  
  maxCalcF('SQRT(4296)');
  writeln(StrDec('123345'));
  
  tst:= TStringlist.create;
  GetSystemPaths(tst);
  for it:= 1 to tst.count-1 do 
   writeln(tst[it]);
  writeln('System Path 2 Test');
  tst:= TStringlist.create;
  
 { case CreateMessageDialog('Text the maXbox', mtWarning,[mbYes,mbNo,mbCancel]).ShowModal 
          of  mrYes: ShowMessage('Yes');
              mrNo: ShowMessage('No');
              mrCancel: ShowMessage('Cancel');
          end; }
          
          with TComboSet.create do begin
            writeln(inttostr(factorial(4)))
            selected
            Free;
          end;  
          
          MVGLGeoNames1:= TMVGLGeoNames.create(self);
          FDownloader:= TMVDESynapse.Create(Self);
          FDownloader.OnAfterDownload := @DoAfterDownload;
          FDownloader.OnBeforeDownload := @DoBeforeDownload;
          
      with TMapViewer.create(self) do begin
        setbounds(0,0,400,500)
        parent:= dbform;
         AutoZoom:= True
         Zoom:= 0
         Debug:= True
         UseThreads:= False
         DownloadEngine := FDownloader;
       
         DoubleBuffering:= False
         //Align:= alClient
         Source:= msOpenStreetMapOsmarender; //'OpenStreetMap - Osmarender';
         //OnMouseMove = FormMouseMove
         //OnDblClick = FormDblClick
         Show;
         Sleep(500)
         GeolocationEngine:= MVGLGeoNames1;
        
         BeginUpdate;
         // MVGLGeoNames1.LocationName := 'Trier Germany'; // Edit1.Text;
          MVGLGeoNames1.LocationName := 'Cologne'; // Edit1.Text;
           Zoom := 12;
         //TrackBar1.Position := mv.Zoom;
        Geolocate;
        EndUpdate;
 
     end;
         
  //procedure TForm1.Button2Click(Sender: TObject);
   //begin
      {mv.BeginUpdate;
      MVGLGeoNames1.LocationName := Edit1.Text;
      mv.Zoom := 12;
      TrackBar1.Position := mv.Zoom;
      mv.Geolocate;
      mv.EndUpdate;}
   //end;
          
      //MVGLGeoNames1.Free;
      //FDownloader.Free;
    
End.  


The C# guys love to brag about their cool using (uses) feature. It’s sort of like a combination of Delphi’s with and try...finally statements. It defines a particular scope which, when left, will automatically dispose of the object in question. Delphi doesn’t have this specifi clanguage construct, but by combining anonymous methods and generics, you can provide the same functionality:
Obj = class class procedure Using<T: class>(O: T; Proc: TProc<T>); static; end;
class procedure Obj.Using<T>(O: T; Proc: TProc<T>); begin try Proc(O); finally O.Free; end; end;


This is basically a (sorry) generic way of wrapping up try...finally blocks just like we did with the cursor above. You can use it like so:

http://theroadtodelphi.wordpress.com/2010/12/06/generating-qr-codes-with-delphi/

Using the Google Chart Tools / Image Charts (aka Chart API) you can easily generate QR codes, this kind of images are a special type of two-dimensional barcodes. They are also known as hardlinks or physical world hyperlinks.

The QR Codes store up to 4,296 alphanumeric characters of arbitrary text. QR codes can be read by an optical device with the appropriate software. Such devices range from dedicated QR code readers to mobile phones.


Using Delphi there are several ways you can generate QR codes - to encode any text (URL, phone number, simple message). QR Codes store up to 4,296 alphanumeric characters of arbitrary text.

The 2D Barcode VCL components is a set of components designed for generating and printing barcode symbols in your Delphi or C++ Builder applications. Use the components set like any other VCL components.

J4L Components includes the QR-code implementation featuring: auto, byte, alpha, numeric and kanji encoding.

The Google Chart Tools (Chart API) also let you generate QR-code images using an HTTP POST or 

All do you need to generate a QrCode is make a get request to this URI

http://chart.apis.google.com/chart?chs=200x200&cht=qr&chld=M&chl=Go+Delphi+Go

uses
 PngImage,
 HTTPApp,
 WinInet;
 
type
TQrImage_ErrCorrLevel=(L,M,Q,H);
 
const
UrlGoogleQrCode='http://chart.apis.google.com/chart?chs=%dx%d&cht=qr&chld=%s&chl=%s';
QrImgCorrStr   : array [TQrImage_ErrCorrLevel] of string=('L','M','Q','H');
 
procedure WinInet_HttpGet(const Url: string;Stream:TStream);
const
BuffSize = 1024*1024;
var
  hInter   : HINTERNET;
  UrlHandle: HINTERNET;
  BytesRead: DWORD;
  Buffer   : Pointer;
begin
  hInter := InternetOpen('', INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0);
  if Assigned(hInter) then
  begin
    Stream.Seek(0,0);
    GetMem(Buffer,BuffSize);
    try
     UrlHandle := InternetOpenUrl(hInter, PChar(Url), nil, 0, INTERNET_FLAG_RELOAD, 0);
        if Assigned(UrlHandle) then
        begin
          repeat
            InternetReadFile(UrlHandle, Buffer, BuffSize, BytesRead);
            if BytesRead>0 then
             Stream.WriteBuffer(Buffer^,BytesRead);
          until BytesRead = 0;
          InternetCloseHandle(UrlHandle);
        end;
    finally
      FreeMem(Buffer);
    end;
    InternetCloseHandle(hInter);
  end
end;
 
//this function return a Stream (PngImage inside) with a Qr code.
procedure GetQrCode(Width,Height:Word;Correction_Level:TQrImage_ErrCorrLevel;const Data:string;StreamImage : TMemoryStream);
Var
 EncodedURL  : string;
begin
  EncodedURL:=Format(UrlGoogleQrCode,[Width,Height,QrImgCorrStr[Correction_Level],HTTPEncode(Data)]);
  WinInet_HttpGet(EncodedURL,StreamImage);
end;


http://www.delphi-central.com/callback.aspx

TTarArchive Usage
-----------------
- Choose a constructor
- Make an instance of TTarArchive                  TA := TTarArchive.Create (Filename);
- Scan through the archive                         TA.Reset;
                                                   WHILE TA.FindNext (DirRec) DO BEGIN
- Evaluate the DirRec for each file                  ListBox.Items.Add (DirRec.Name);
- Read out the current file                          TA.ReadFile (DestFilename);
  (You can ommit this if you want to
  read in the directory only)                        END;
- You're done                                      TA.Free;


TTarWriter Usage
----------------
- Choose a constructor
- Make an instance of TTarWriter                   TW := TTarWriter.Create ('my.tar');
- Add a file to the tar archive                    TW.AddFile ('foobar.txt');
- Add a string as a file                           TW.AddString (SL.Text, 'joe.txt', Now);
- Destroy TarWriter instance                       TW.Free;
- Now your tar file is ready.



The last slash might be optional. Right?

How about something like this:

$url =~ m|([^/]+)/?$|;
my $end_of_url = $1;

The $ on the end anchors the regular expression to the end of the string. The [^/] means anything that's not a slash and the + after means I want one or more things that are not slashes. Notice that this is in a capture group which are marked with parentheses.
I end the regular expression with /? which means that there may or may not be a slash on the very end of the string. I've put my regular expression between m| and |, so I can use forward slashes without having to constantly escape them.

The last part of the URL is now in $1 and I can set my own scalar variable to save this Result.
share|improve this answer

  
procedure GetQrCodeImage(Width,Height: Word; Correct_Level: string;
           const Data:string; aimage: TImage; apath: string);
var
  encodedURL: string;
  idhttp: TIdHttp;// THTTPSend;
  pngStream: TMemoryStream;
begin
  encodedURL:= Format(UrlGoogleQrCode,[Width,Height, Correct_Level, HTTPEncode(Data)]);
  //WinInet_HttpGet(EncodedURL,StreamImage);
  idHTTP:= TIdHTTP.Create(NIL)
  pngStream:= TMemoryStream.create;
  with TLinearBitmap.Create do try
    idHTTP.Get1(EncodedURL, pngStream)
    pngStream.Position:= 0;
    LoadFromStream2(pngStream,'PNG');
    aImage.Picture:= NIL;
    AssignTo(aimage.picture.bitmap);
    SaveToFile(apath);
    //OpenDoc(apath);
  finally
    Dispose;
    Free;
    idHTTP.Free
    pngStream.Free;
  end;
end;

procedure GetQrCode3(Width,Height: Word; Correct_Level: string;
           const Data:string; apath: string);
var
  encodedURL: string;
  idhttp: TIdHttp;// THTTPSend;
  png: TLinearBitmap;//TPNGObject;
  pngStream: TMemoryStream;
begin
  encodedURL:= Format(UrlGoogleQrCode,[Width,Height, Correct_Level, HTTPEncode(Data)]);
  //WinInet_HttpGet(EncodedURL,StreamImage);
  idHTTP:= TIdHTTP.Create(NIL)
  pngStream:= TMemoryStream.create;
  with TLinearBitmap.Create do try
    idHTTP.Get1(EncodedURL, pngStream)
    pngStream.Position:= 0;
    LoadFromStream2(pngStream,'PNG');
    //aImage.Picture:= NIL;
    //AssignTo(aimage.picture.bitmap);
    SaveToFile(apath);
    OpenDoc(apath);
  finally
    Dispose;
    Free;
    idHTTP.Free
    pngStream.Free;
  end;
end;

unit GeoUnit1;

interface

uses
Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
Dialogs, ExtCtrls, StdCtrls, ComCtrls, kcMapViewer, kcMapViewerGLGeoNames
{$IFDEF WIN32}, kcMapViewerDEWin32{$ELSE}, kcMapViewerDESynapse{$ENDIF WIN32};

type

{ TForm1 }

TForm1 = class(TForm)
Button2: TButton;
CheckBox1: TCheckBox;
CheckBox2: TCheckBox;
CheckBox3: TCheckBox;
ComboBox1: TComboBox;
Edit1: TEdit;
GroupBox1: TGroupBox;
GroupBox2: TGroupBox;
GroupBox3: TGroupBox;
Label1: TLabel;
Label2: TLabel;
Label3: TLabel;
Label4: TLabel;
Label5: TLabel;
Label6: TLabel;
Label7: TLabel;
mv: TMapViewer;
MVGLGeoNames1: TMVGLGeoNames;
Panel1: TPanel;
TrackBar1: TTrackBar;
procedure Button2Click(Sender: TObject);
procedure CheckBox1Change(Sender: TObject);
procedure CheckBox2Change(Sender: TObject);
procedure CheckBox3Change(Sender: TObject);
procedure ComboBox1Change(Sender: TObject);
procedure FormCreate(Sender: TObject);
procedure FormDestroy(Sender: TObject);
procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
procedure FormDblClick(Sender: TObject);
procedure TrackBar1Change(Sender: TObject);
private
FDownloader: TCustomDownloadEngine;
procedure DoBeforeDownload(Url: string; str: TStream; var CanHandle: Boolean);
procedure DoAfterDownload(Url: string; str: TStream);
end;

var
Form1: TForm1;

implementation

//{$R *.lfm}

uses
md5;

procedure TForm1.FormMouseMove(Sender: TObject; Shift: TShiftState; X,
Y: Integer);
var
p: TIntPoint;
r: TRealPoint;
begin
p := mv.GetMouseMapPixel(X, Y);
Label2.Caption := Format('Pixel: %d:%d', [p.X, p.Y]);
p := mv.GetMouseMapTile(X, Y);
Label3.Caption := Format('Tile: %d:%d', [p.X, p.Y]);
r := mv.GetMouseMapLongLat(X, Y);
Label4.Caption := Format('Long: %g', [r.X]);
Label5.Caption := Format('Lat: %g', [r.Y]);

r := mv.CenterLongLat;
Label6.Caption := Format('Long: %g', [r.X]);
Label7.Caption := Format('Lat: %g', [r.Y]);
end;

procedure TForm1.FormDblClick(Sender: TObject);
begin
TrackBar1.Position := mv.Zoom;
end;

procedure TForm1.TrackBar1Change(Sender: TObject);
begin
if Sender = TrackBar1 then
mv.Zoom := TrackBar1.Position;
end;

procedure TForm1.DoBeforeDownload(Url: string; str: TStream;
var CanHandle: Boolean);
var
x: string;
f: TFileStream;
begin
x := 'cache\'+MDPrint(MD5String(Url));
if FileExists(x) then
begin
f := TFileStream.Create(x, fmOpenRead);
try
str.Position := 0;
str.CopyFrom(f, f.Size);
str.Position := 0;
CanHandle := True;
finally
f.Free;
end;
end
else
CanHandle := False;
end;

procedure TForm1.DoAfterDownload(Url: string; str: TStream);
var
x: string;
f: TFileStream;
begin
if not DirectoryExists('cache') then
ForceDirectories('cache');
x := 'cache\'+MDPrint(MD5String(Url));
if (not FileExists(x)) and (not (str.Size = 0)) then
begin
f := TFileStream.Create(x, fmCreate);
try
str.Position := 0;
f.CopyFrom(str, str.Size);
finally
f.Free;
end;
end;
end;

procedure TForm1.ComboBox1Change(Sender: TObject);
begin
mv.Source := TMapSource(ComboBox1.ItemIndex);
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
{$IFDEF WIN32}
FDownloader := TMVDEWin32.Create(Self);
{$ELSE}
FDownloader := TMVDESynapse.Create(Self);
{$ENDIF WIN32}

FDownloader.OnAfterDownload := @DoAfterDownload;
FDownloader.OnBeforeDownload := @DoBeforeDownload;
mv.DownloadEngine := FDownloader;
end;

procedure TForm1.FormDestroy(Sender: TObject);
begin
FDownloader.Free
end;

procedure TForm1.CheckBox1Change(Sender: TObject);
begin
mv.Debug := CheckBox1.Checked;
end;

procedure TForm1.Button2Click(Sender: TObject);
begin
mv.BeginUpdate;
MVGLGeoNames1.LocationName := Edit1.Text;
mv.Zoom := 12;
TrackBar1.Position := mv.Zoom;
mv.Geolocate;
mv.EndUpdate;
end;

procedure TForm1.CheckBox2Change(Sender: TObject);
begin
mv.UseThreads := CheckBox2.Checked;
end;

procedure TForm1.CheckBox3Change(Sender: TObject);
begin
mv.DoubleBuffering:=CheckBox3.Checked;
end;

 TLocOleCtrl = Class (TOleControl);
  
----app_template_loaded_code----