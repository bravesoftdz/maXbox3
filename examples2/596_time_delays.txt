PROGRAM SomeTimeDelayRoutinesCard;

//////////////////////////////////////////////////////////////////////
//  #sign:Administrator: PC08: 13/03/2015 09:46:53 PM 
//  Purpose: shows several time delays                              //
//  #path>ples\E:\maxbox3\mXGit39991\maxbox3\examples\les\          //
//  Lines of Code #locs:272
//////////////////////////////////////////////////////////////////////

Const TEXTOUT = 'Hi world of time delay coverage';

//############################################################################
// Archimedes Spiral Function Fun CODEsign
//############################################################################
//TODO: Combine this two functions in one call

//http://www.swissdelphicenter.ch/en/showcode.php?id=55

Function IntToBase32X(Numb: Longint): String;
begin
  Result:= '';
  for It:= 0 to 4 do begin
    Insert(NUMBLETTS[(Numb And 31)+1], Result, 1);
    Numb:= Numb Shr 5;
  end;
end;

function CountPos(const subtxt: string; Text: string): Integer;
begin
  if (Length(subtxt)= 0) Or (Length(Text)= 0) Or (Pos(subtxt,Text)= 0) then
    result:= 0
  else
    result:= (Length(Text)- Length(StringReplace(Text,subtxt,'',
      [rfReplaceAll]))) div Length(subtxt);
end;


const
  UNINST_PATH = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall';

procedure GetAllSoftwareInstalled(Sender: TObject);
var
  Reg: TRegistry;
  SubKeys: TStringList;
  ListItem: TlistItem;
  i: integer;
  ListView1: TListView;
  sDisplayName, sUninstallString: string;
begin

  ListView1.ViewStyle := vsReport;
  ListView1.Columns.add;
  ListView1.Columns.add;
  ListView1.Columns[0].caption := 'DisplayName';
  ListView1.Columns[1].caption := 'UninstallString';
  ListView1.Columns[0].Width := 300;
  ListView1.Columns[1].Width := 300;

  Reg := TRegistry.Create;
  with Reg do
    try
      with ListView1.Items do
        try
          BeginUpdate;
          Clear;
          RootKey := HKEY_LOCAL_MACHINE;
          if OpenKeyReadOnly(UNINST_PATH) then
          begin
            SubKeys := TStringList.Create;
            try
              GetKeyNames(SubKeys);
              CloseKey;
              for i := 0 to subKeys.Count - 1 do
                if OpenKeyReadOnly(Format('%s\%s', [UNINST_PATH, SubKeys[i]])) then
                  try
                    sDisplayName     := ReadString('DisplayName');
                    sUninstallString := ReadString('UninstallString');
                    if sDisplayName <> '' then
                    begin
                      ListItem         := Add;
                      ListItem.Caption := sDisplayName;
                      ListItem.subitems.Add(sUninstallString);
                    end;
                  finally
                    CloseKey;
                  end;
            finally
              SubKeys.Free;
            end;
          end;
        finally
          ListView1.AlphaSort;
          EndUpdate;
        end;
    finally
      CloseKey;
      Free;
    end;
end;


procedure LoadfromResName(Sender: TObject);
var
 BitMap1 : TBitMap;
 aform: TForm;
begin
  aform:= TForm.create(self);
  BitMap1 := TBitMap.Create;
  aform.SetBounds(0,0,300,250)
  try
    aform.Show;
    BitMap1.LoadFromResourceName(HInstance,'Live');
    aform.Canvas.Draw(12,12,BitMap1);
    BitMap1.LoadFromResourceName(HInstance,'Dead');
    aform.Canvas.Draw(12,102,BitMap1);
    //aform.Show;
  finally
    BitMap1.Free;
  end;
end;


// 1. Delay

procedure Delay(dwMilliseconds: Longint);
var
  iStart, iStop: DWORD;
begin
  iStart := GetTickCount;
  repeat
    iStop := GetTickCount;
    Application.ProcessMessages;
    Sleep(1); // addition from Christian Scheffler to avoid high CPU last
  until (iStop - iStart) >= dwMilliseconds;
end;

// 2. Delay: with API

procedure Delay2(msecs: Longint);
var
  targettime: Longint;
  Msg: TMsg;
begin
  targettime := GetTickCount + msecs;
  while targettime > GetTickCount do
    if PeekMessage(Msg, 0, 0, 0, PM_REMOVE) then
    begin
      if Msg.message = WM_QUIT then begin
        PostQuitMessage(Msg.wParam);
        Break;
      end;
      TranslateMessage(Msg);
      DispatchMessage(Msg);
    end;
end;

{
  Note:
  The elapsed time is stored as a DWORD value.
  Therefore, the time will wrap around to zero if the system is
  run continuously for 49.7 days.
}

// 3. Sleep
{
  The Sleep function suspends the execution of the current
  thread for a specified interval.
}

//Sleep(dwMilliseconds: Word);


// 4. Combined Delay

{
  Including the Sleep in the loop prevents the app from hogging
  100% of the CPU for doing practically nothing but running around the loop.
}

procedure PauseFunc4(delay: DWORD);
var
  lTicks: DWORD;
begin
  lTicks := GetTickCount + delay;
  repeat
    //Sleep(100);
    Sleep(1);
    Application.ProcessMessages;
  until (lTicks <= GetTickCount) or Application.Terminated;
end;

// 5. more resource sparing:

//  QS_ALLINPUT = (QS_INPUT or QS_POSTMESSAGE or QS_TIMER or QS_PAINT
  //  or QS_HOTKEY or QS_SENDMESSAGE);
    //const QS_ALLINPUT = QS_INPUT;
   //or QS_POSTMESSAGE or QS_TIMER or QS_PAINT
    //or QS_HOTKEY or QS_SENDMESSAGE;
   
//   CL.AddDelphiFunction('Function MsgWaitForMultipleObjects( nCount : DWORD; var pHandles, fWaitAll : BOOL; dwMilliseconds, dwWakeMask : DWORD) : DWORD');

//var QS_ALLINPUT: integer;

procedure Delay5(Milliseconds: Integer);
  {by Hagen Reddmann}
var
  Tick: DWORD;
  Event: THandle;
  event1: bool;
begin
   // QS_ALLINPUT = (QS_INPUT or QS_POSTMESSAGE or QS_TIMER or QS_PAINT
  //  or QS_HOTKEY or QS_SENDMESSAGE);
  //Event := CreateEvent(0, False, False, 'nil');
  try
    Tick:= GetTickCount + DWORD(Milliseconds);
    while (Milliseconds > 0) and
      (MsgWaitForMultipleObjects(1, event, true, Milliseconds,
      QS_ALLINPUT) <> WAIT_TIMEOUT) do 
    begin
      Application.ProcessMessages;
      Milliseconds:= Tick - GetTickCount;
    end;
  finally
    CloseHandle(Event);
  end;
end;



Begin  //main
 writeln('IntToBase32 of 1000: '+IntToBase32X(1000))
 writeln('CountPos: '+itoa(CountPos('max','this is max of maXbox a max numbermax')))
 PrintF('CountPos: %d',[CountPos('max','this is max of maXbox a max numbermax')])
  {case CheckCreditCard('2405485000721119') of
    0: writeln('Card is invalid or unknown');
    1: writeln('Card is a valid AmEx');
    2: writeln('Card is a valid Visa');
    3: writeln('Card is a valid MasterCard');
  end;}
  
  //get_form_resource(self)
  //writeln(getFormRes('TMaxForm1'))
    
    with TInterval.create do begin
      start
        delay2(500)
      stop
      writeln(toString)
      free
    end;  
    
    with TInterval.create do begin
      start
        PauseFunc4(500)
      stop
      writeln(toString)
      free
    end;  
    
    with TInterval.create do begin
      start
        Delay5(500)
      stop
      writeln(toString)
      free
    end;  
   
  //LoadfromResName(self)
  //Delay5(100)
 
  // Example: RoundTime('07.08.02 10:41', '15', True) -- > 07.08.02 10:45
End. 


Ref: http://www.swissdelphicenter.ch/en/showcode.php?id=1365

procedure TForm1.Button1Click(Sender: TObject);
begin
  case CheckCC(Edit1.Text) of
    0: Label1.Caption := 'Card is invalid or unknown';
    1: Label1.Caption := 'Card is a valid AmEx';
    2: Label1.Caption := 'Card is a valid Visa';
    3: Label1.Caption := 'Card is a valid MasterCard';
  end;
end;

http://www.swissdelphicenter.ch/en/showcode.php?id=1089

//############################################################################
// Archimedes Spiral App
//############################################################################

unit ArchSpiralMain;

interface

uses
  w3system, w3components, w3ctrls, w3application, w3game, w3gameapp,
  w3polygons, w3inet, w3graphics;

type
  TApplication = class(TW3CustomGameApplication)
  private
    FValueA: Float;
    FValueB: Float;
    FWait: Boolean;
    procedure HandleClick(Sender:TObject);
  protected
    procedure ApplicationStarting; override;
    procedure ApplicationClosing; override;
    procedure PaintView(Canvas: TW3Canvas); override;
  end;

implementation

//############################################################################
// TApplication
//############################################################################

procedure TApplication.ApplicationStarting;
begin
  inherited;

  FValueA := 3.0;
  FValueB := 1.4;

  GameView.OnClick := Self.HandleClick;

  // Initialize refresh interval, set this to 1 for optimal speed
  GameView.Delay := 10;
 
  // Start the redraw-cycle with framecounter active
  // Note: the framecounter impacts rendering speed. Disable
  // the framerate for maximum speed (false)
  GameView.StartSession(true);
end;

procedure TApplication.ApplicationClosing;
begin
  GameView.EndSession;
  inherited;
end;

procedure TApplication.HandleClick(Sender: TObject);
begin
  FWait := not FWait;
end;

// Note: In a real live game you would try to cache as much
// info as you can. Typical tricks are: 
//   1: Only get the width/height when resized
//   2: Pre-calculate strings, especially RGB/RGBA values
//   3: Only redraw what has changed, avoid a full repaint
// The code below is just to get you started

procedure TApplication.PaintView(Canvas: TW3Canvas);
var
  cx, cy: Integer;
  i: Integer;
  angle: Float;
  x, y: Float;
begin
  if FWait then
    exit;

  FValueB := FValueB + 0.001;

  // Clear background
  Canvas.FillStyle := 'rgba(0,0,99,0.08)';
  Canvas.FillRectF(0, 0, GameView.Width, GameView.Height);

  // Draw our framerate on the screen
//  Canvas.font := '10pt verdana';
//  Canvas.FillStyle := 'rgb(255,255,255)';
//  Canvas.FillTextF('FPS:' + IntToStr(GameView.FrameRate) + ' / ' + floatToStr(FbValue) ,10,20,MAX_INT);

  cx := GameView.width div 2;
  cy := GameView.Height div 2;
  Canvas.BeginPath;

  for i := 42 downto 0 do
  begin
    angle := FValueB * i;
    x := cx + (FValueA + FValueB * angle) * cos(angle);
    y := cy + (FValueA + FValueB * angle) * sin(angle);
    if i = 42 then Canvas.MoveToF(x, y) else Canvas.LineToF(x,y);
  end;

  Canvas.StrokeStyle := '#FFF';
  Canvas.Stroke;
end;

end.

  RegisterMethod('Constructor Create(AOwner: TComponent)');
  RegisterConstructor(@TJvMail.Create, 'Create');
   RegisterMethod('Procedure Free');
   RegisterMethod(@TJvMail.Destroy, 'Free');
   
----app_template_loaded_code----