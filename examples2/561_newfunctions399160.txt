PROGRAM newFunctions_myTurtle123_seqDEMO;
// task: design each number from 0..10
// process: download --> include --> loop
// #sign:Administrator: PC08: 22/01/2015 11:16:27 PM 

var cfrm: TForm;
     Ini: TBigIniFile;
    Frequency:  Int64;
     Start1, Stop1    :  Int64;    // D4-D5
 

//function DownloadFile(SourceFile, DestFile: string): Boolean;

procedure downloadnumbers;
begin
  if DownloadFile('http://192.168.1.43:9000/Nr9_Damian.inc',
        Exepath+'\examples\ibznumbers\Nr9_Damian.inc') then
      writeln('Download succesful!') else 
       writeln('Download NOT succesful!');
  UrlDownloadToFile(Nil,'http://192.168.1.43:9000/Nr9_Damian.inc',
     Exepath+'\examples\ibznumbers\Nr9_Damian.inc',0,Nil);
                   
  writeln(inttostr(UrlDownloadToFile(Nil,'http://192.168.1.43:9000/Nr9_Damian.inc',Exepath+'\examples\ibznumbers\Nr9_Damian.inc',0,Nil)));
     
end;      

    

procedure LoadForm;
begin
  cFrm:= TForm.create(self);
  try
    with cFrm do begin
      caption:= '((((TARTARUGA))))';  
      height:= 600;
      width:= 600;
      color:= clblack;
      Position:= poScreenCenter;
      show;
    end;
  except
    Exit;
  end  
end;

procedure TurtleEasy1;
begin
  with TJVTurtle.create(self) do begin
    canvas:= cFrm.canvas;
    canvas.Pen.Color:= clred;
    penDown:= true;
    penWidth:= 30;
    setpos(150,250)
    turn(45)
    moveforward(100)
    right(135)
    moveforward(200)
    Free;
  end;
end;    

procedure TurtleEasy2;
var myturtle: TJVTurtle;
begin
  myturtle:= TJVTurtle.create(self);
  with myTurtle do begin
    //canvas.assign(cFrm)
    canvas:= cFrm.canvas;
    canvas.Pen.Color:= clgreen;
    penDown:= true;
    //penup
    penWidth:= 30;
    setpos(280,250);
    //turn(45)
    moveforward(100)
    right(90)    //180
    moveforward(100)
    right(90)    //180
    moveforward(100)
    left(90)    //180
    moveforward(100)
    left(90)    //180
    moveforward(100)
    //movebackward(100)
   end;
   myturtle.Free;
end;    

procedure TurtleEasy3;
begin
  with TJVTurtle.create(self) do begin
    canvas:= cFrm.canvas;
    canvas.Pen.Color:= clblue;
    penDown:= true;
    penWidth:= 30;
    setpos(430,300);
    moveforward(100)
    right(90)    
    moveforward(100)
    right(90)    
    moveforward(100)
    turn(180)    //or movebackward()
    moveforward(100)
    right(90)   
    moveforward(100)
    right(90)  //180
    moveforward(100)
    Free;
   end;
end;  

procedure looprepaint;
begin  
   sleep(500) 
   //cfrm.repaint;           
end;

function ShellCompare(Item1, Item2: ___Pointer): Integer;
begin
  {Result := Smallint(
      TShellFolder(Item1).ParentShellFolder.CompareIDs(
      SortColumn,
      TShellFolder(Item1).RelativeID,
      TShellFolder(Item2).RelativeID) ); }
end;
     
procedure TForm1_ShellListView1ColumnClick(Sender: TObject;
 Column: TListColumn);
var
  SortColumn: Integer;
  ShellListView1: TShellListView;
begin
  SortColumn := Column.Index;
  //ShellListView1.FolderList.Sort(ShellCompare);
  ShellListView1.Invalidate;
end;

procedure TForm1_Button2Click(Sender: TObject);
var
  Dir: string;
begin
  Dir:= 'C:\maXbook';
  if SelectDirectory(Dir, [sdAllowCreate, sdPerformCreate, sdPrompt], 0) then
    ShowMessage('You selected ' + Dir)
  else
    ShowMessage('You did not select a folder');
end;

procedure RemoveFromRunKey(ApTitle: string);
var
  Reg: TRegistry;
  TheKey: string;
  ListOfEntries: TStringList;
  i: integer;
begin
  Reg:= TRegistry.Create;
  Reg.RootKey := HKEY_LOCAL_MACHINE;
  TheKey:= 'Software\Microsoft\Windows\CurrentVersion\Run';
  // Check if key exist...
  // ...if yes, try to delete the entry for ApTitle
  if not Reg.OpenKey(TheKey, False) then
    ShowMessage('Key not found')
  else begin
    if Reg.DeleteValue(ApTitle) then
      ShowMessage('Removed: ' + ApTitle)
    else
      ShowMessage('Not found: ' + ApTitle);
  end;
  Reg.CloseKey;
  Reg.Free;
end;

//http://www.festra.com/eng/mtut07.htm
procedure RunOnWinStart(ApTitle, ApPathFile: string; RunOnce: Boolean);
var
  Reg: TRegistry;
  TheKey: string;
begin
  Reg:= TRegistry.Create;
  Reg.RootKey:= HKEY_LOCAL_MACHINE;
  TheKey:= 'Software\Microsoft\Windows\CurrentVersion\Run';
  if RunOnce then TheKey:= TheKey + 'Once';
  // Open key, or create it if it doesn't exist
  Reg.OpenKey(TheKey, True);
  Reg.WriteString(ApTitle, ApPathFile);
  Reg.CloseKey;
  Reg.Free;
end;

procedure StrtoIntDefDemo;
var
  Row, N1, N2: integer;
  StringGrid1: TStringGrid;
begin
  for Row:= 0 to StringGrid1.RowCount - 1 do begin
    N1:= StrToIntDef(StringGrid1.Cells[0, Row], -1);
    N2:= StrToIntDef(StringGrid1.Cells[1, Row], -1);
    if (N1 < 0) or (N2 < 0) then 
      StringGrid1.Cells[3, Row]:= IntToStr(N1 + N2)
    else
      StringGrid1.Cells[3, Row]:= 'Invalid';
  end; 
end;

function StripHTML(S: string): string;
var
  TagBegin, TagEnd, TagLength: integer;
begin
  TagBegin:= Pos( '<', S);      // search position of first < 
  while (TagBegin > 0) do begin  // while there is a < in S
    TagEnd:= Pos('>', S);              // find the matching > 
    TagLength:= TagEnd - TagBegin + 1;
    Delete(S, TagBegin, TagLength);     // delete the tag 
    TagBegin:= Pos( '<', S);            // search for next <
  end;
  Result:= S;                   // give the result
end;

procedure STEXpressionPattern;
begin
    with TStExpression.create(self) do begin
      AddConstant('MPI',3.14159);
      srlist:= TStringlist.create;
      GetIdentList(srlist);
      for it:= 0 to srlist.count-1 do 
        writeln(srlist.strings[it]);
      srlist.Free;  
      Expression:= '2^10 * ln(8 +MPI)';
      writeln(floattoStr(AnalyzeExpression))
      free;
    end;  
end;    

function MediaToString(Media: DWORD): string;
//const
var MediaNames: array[0..7] of string; { =
('GlobalMem', 'File', 'IStream', 'IStorage', 'GDI', 'MetaFile', 'EnhMetaFile', 'Unknown');                                    }
var
Medium: DWORD;
MediumNum: integer;
begin
Result := '';
MediumNum := 0;
Medium := $0001;
while (Media >= Medium) and (MediumNum <= High(MediaNames)) do begin
   if (Media and Medium <> 0) then begin
     if (Result <> '') then
       Result:= Result+', ';
     Result:= Result+MediaNames[MediumNum];
   end;
   inc(MediumNum);
   Medium:= Medium shl 1;
end;
end;

const
  MAX_DATA = 32768; // Max bytes to render in preview

function TFormMain_DataToHexDump(const Data: AnsiString): string;
var
i: integer;
Offset: integer;
Hex: string; ASCII: string;
LineLength: integer;
Size: integer;
begin
   Result := '';
   LineLength := 0;
   Hex := '';
   ASCII := '';
   Offset := 0;
   Size := Length(Data);
   if (Size > MAX_DATA) then
   Size := MAX_DATA;
   for i := 0 to Size-1 do begin
   //if hex > 'a' then
   Hex := Hex+IntToHex(ord(Data[i+1]), 2)+' ';
   //if (Data[i+1] in [' '..#$7F]) then
   if (Data[i+1] > ' ') And (Data[i+1] < #$7F) then
     ASCII:= ASCII+Data[i+1]
   else
   ASCII:= ASCII+'.';
   inc(LineLength);
   if (LineLength = 16) or (i = Length(Data)-1) then begin
   Result:= Result+Format('%.8x %-48.48s %-16.16s'+#13+#10,[Offset,Hex, ASCII]);
   inc1(Offset, LineLength);
   LineLength:= 0;
   Hex:= '';
   ASCII:= '';
   end;
   end;
end;

function  DateTimeToFileName(const DT: TDateTime; UseMSecs: Boolean): string;
begin
  case UseMSecs of
    False : Result := FormatDateTime('yyyy-mm-dd_hh_nn_ss', DT);
    True  : Result := FormatDateTime('yyyy-mm-dd_hh_nn_ss_zzz', DT);
  end;
end;

procedure TfrmSettings_btnOutPutDirClick(Sender: TObject);
var
  dir : String;
  edtOutPutDir: TEdit;
begin
  Dir:= edtOutPutDir.Text;
  if SelectDirectory(Dir, [sdAllowCreate, sdPerformCreate, sdPrompt], 0) then
                     edtOutPutDir.Text:= Dir;
end;


function SearchToSynsearch(SO: TFindOptions): TSynSearchOptions;
begin
  Result := [];
  if frMatchCase in SO then Result:= result + [ssoMatchCase];
  if frWholeWord in SO then Result:= result + [ssoWholeWord];
  if frReplace	 in SO then Result:= result + [ssoReplace];
  {if not (frDown in SO) then Include(Result, ssoBackwards);
  if frReplaceAll in SO then Include(Result, ssoReplaceAll);
  if frMatchCase in SO then Include(Result, ssoMatchCase);
  if frFindNext in SO then Include(Result, ssoMatchCase);}
end;

// Some method declaratinos may be very long.
// Delphi can't compile these, so we need to spit them manually.
const
  cSplitPosition = 200;

function SplitIntoLines(AString: string): string;
begin
  Result:= '';
  while (Length(AString) > cSplitPosition) do begin
    Result:= Result + LeftStr(AString, cSplitPosition) +
      ''' +' + #13 + #10  + '      ''';
    Delete(AString, 1, cSplitPosition);
  end;
  Result:= Result + AString;
end;

{ type
 TPasToken = record
    ID: TPSPasToken;
    Data: string;
    Org : String;
    row, col: integer;
  end; }
  
  //const
    //MaxSearchCount = 100;
  
  function FindProperty: Boolean;
    var
      e, ReadString: string;
      SearchCount: integer;
       aClassParent: string;
       TokenRow, tokenCol: integer;
        PropertyName: string;
        ParamTypes: TStringList;
        read, write: boolean;
     begin
      ReadString := aClassParent;
      Result := False;
      SearchCount:= MaxSearchCount;
      while True do
      begin
        if SearchCount = 0 then RaiseError('While searching for property in property list, the maxium number of searchs allowed was reached', TokenRow, TokenCol);
        dec(SearchCount);
        e:= Ini.ReadString(ReadString, PropertyName, '~');
        if e = '~' then
        begin
          ReadString:= Ini.ReadString(ReadString, 'PARENT-CLASS', '');
      // check in the parent for the property
          if ReadString = '' then exit;
        end
        else begin
          if e = '' then
          begin PropertyName := '';
            Result := True;
            exit;
          end;
          if pos(' ', e) = 0 then exit;
          ReadString := copy(e, 1, pos(' ', e) - 1);
          Delete(e, 1, length(ReadString) + 1);
          ParamTypes.Text := Stringreplace(e, ' ', #13#10, [rfReplaceAll]);
          if ReadString = 'READ' then
            Read := True
          else if ReadString = 'WRITE' then
            Write := True
          else if ReadString = 'READWRITE' then begin
            Read := True;
            Write := True;
          end
          else exit;
          Result := True;
          exit;
        end;
      end;
    end; {FindProperty}

    

procedure TUnitBigIni(const IniFilename: string; aTokenHistoryLength: Integer);
var fParser: TPSPascalParser;
    token: {TUnitParser} TPasToken;
    LastTokens: array[0..0] of string; //Z/TPasToken;
    FTail, FHead, TokenHistoryCount, TokenHistoryLength: integer;
    
begin
  Ini:= TBigIniFile.Create(IniFilename);
  Ini.FlagDropApostrophes := True;
  ini.FlagDropCommentLines := True;
  Ini.FlagTrimRight := True;
  Ini.FlagFilterOutInvalid := True;
  ini.Free;

  fParser := TPSPascalParser.create;
  TokenHistoryLength := aTokenHistoryLength;
  if TokenHistoryLength > 0 then
    Setlength(LastTokens, TokenHistoryLength);

  //FOutUnitList := TStringList.Create;
  //FSingleUnit := True;
end; {Create}




//https://www.dropbox.com/s/w0bfri6sm3dy5bn/Nr9_Damian.INC?dl=0

 //{$I ..\maxbox3\examples\Nr9_damian.inc}
  

BEGIN  //Main

 //includeoff;

 //downloadnumbers;

 loadform;
 //repeat 
   TurtleEasy1;
    looprepaint  
   TurtleEasy2;
    looprepaint
   TurtleEasy3;
    looprepaint
   //{$I ..\SWS2014\damiannr9.txt}
  // turtleEasy9(cfrm);
 //until iskeypressed;
 
 //TForm1_Button2Click(Self)
    {@run as admin}
  //RunOnWinStart('maXbox3', 'C:\maXbook\maxbox3\mX3999\maxbox\maxbox3.exe', True);
  //RunOnWinStart('Calculator', 'calc.exe', False);
  //RemoveFromRunKey('Calculator');
  
  STEXpressionPattern;
 
   writeln('MakeHash of: '+inttostr(MakeHash('to do const s : TbtString')));
  
   writeln('calc back as string: '+maXcalcS('ln(e)^10')+maXcalcS('ln(e)^10+1')+'3')
 
   maXform1.UnitConverter1Click(self);
   
     srlist:= TStringlist.create;
      //ConsoleCapture('C:\', 'cmd.exe', '/c dir *.* /s',srlist);
      ConsoleCapture('C:\', 'cmd.exe', '/c dir *.*',srlist);
      writeln(srlist.text)
     srlist.Free;
     
   //function TFormMain_DataToHexDump(const Data: AnsiString): string;
   writeln('HEX_TEX: '+TFormMain_DataToHexDump(memo2.text));
   
   GLQueryPerformanceFrequency(Frequency);
   GLQueryPerformanceCounter(Start1);
     PerformanceDelayMS(500);  
   QueryPerformanceCounter(Stop1);
   Writeln( IntToStr(Stop1-Start1) + ' Freq: ' +
                IntToStr(Frequency) +  ' ' +
                Format( '%.6f', [ (Stop1-Start1)/Frequency ]) + ' micro seconds!')

 
END. 

Doc:
C:\maxbook\maxbox3\mx39\maxbox3\maxbox3\docs\utils\Herleitung_4.jpg

----app_template_loaded_code----
----File #file:0.txt561_newfunctions399160.txtl.txt
----Date #sign:Administrator: PC08: 22/01/2015 11:16:27 PM 

http://www.bern.ch/online/aus_und_org/informatikkurse/kurse/it-sicherheit-fuer-neueintretende-mitarbeitende