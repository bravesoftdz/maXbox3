//shows a recursion of fibonacci, faculty numbers _30, #locs:284
//procedure stackout is just an educational help
//teaches the simularity of recursion & iterations, TASK: test with int64

program fibonacci_recursion_compare;
//{$S+}

var i: byte;

procedure stackOut;
begin
  i:= i + 1
  //writeln('stack return call of: ' +intToStr(i));
end;

function fibo(n: byte): integer;
begin
 //process steps
  if n < 2 then 
    result:= 1 else
    result:= fibo(n-2) + fibo(n-1);
  //test return of stack
  stackOut
end;

function faculty(n: integer): integer;
begin
 //process steps of fac!
  if n < 2 then 
    result:= 1 else
    result:= n * faculty(n-1);
  //test return of stack
  stackOut
end;

 function rectestWord(ac: string; n: byte): bool;
 begin
   if n < length(ac) then
     rectestWord(ac,n+1);
   write(ac[n]);   //rec back
   result:= true;
 end;  
 

function facultytest(n: integer): integer;
begin
 if n < 2 then 
   result:= 1 else
   result:= n * faculty(n-1);
 end;
 
 procedure ExtractDuplicates1(List1, List2: TStringList; Dupes: TStrings);
   var
     Both: TStringList;
     I: Integer;
   begin
     Both := TStringList.Create;
     try
       Both.Sorted := True;
       Both.Duplicates := dupAccept;
       Both.AddStrings(List1);
       Both.AddStrings(List2);
       for I := 0 to Both.Count - 2 do
         if (Both[I] = Both[I + 1]) then
           if (Dupes.Count = 0) or (Dupes[Dupes.Count - 1] <> Both[I]) then
             Dupes.Add(Both[I]);
     finally
       Both.Free;
     end;
   end;


 function TestDuplicates(const dataStrList: TStringList): integer;
 begin 
   with TStringlist.create do begin
     {Duplicates:= dupIgnore;}
     for it:= 0 to DataStrList.count-1 do begin
       if IndexOf(DataStrList[it])< 0 then
         Add(DataStrList[it])
       else 
         inc(result)
     end;
     Free;
   end;
 end;

 function FindDuplicates(const datastringlist: TStringList): integer;
 var TestStringList: TStringlist;
 begin
   TestStringList:= TStringList.Create;
   TestStringList.Sorted:= True;
   TestStringList.Duplicates:= dupIgnore;
   TestStringList.AddStrings(DataStringList);
   result:= DataStringList.Count - TestStringList.Count;
   //result:= (Format('%d duplicates discarded',
     //                 [DataStringList.Count - TestStringList.Count]));
   TestStringList.Free;
 end;             
 
 procedure RemoveDuplicates(const stringList: TStringList);
 var
   buffer: TStringList;
   cnt: Integer;
 begin
   stringList.Sort;
   buffer:= TStringList.Create;
   try
     buffer.Sorted:= True;
     buffer.Duplicates:= dupIgnore;
     buffer.BeginUpdate;
     {stringlist.Duplicates:= dupIgnore;
     stringlist.beginupdate;
     for cnt:= 0 to stringList.Count - 1 do
       writeln(stringlist[cnt]);}
     for cnt:= 0 to stringList.Count - 1 do
       buffer.Add(stringList[cnt]) ;
     buffer.EndUpdate;
     stringList.Assign(buffer);
   finally
     buffer.Free;
     buffer:= NIL;
     //FreeandNil(buffer);
   end;
 end;
 
procedure listdistinct;
var i: integer;
begin  
  with TStringList.Create do begin
    try
      Sorted:= true;
      Duplicates:= dupIgnore;
      Add('Eintrag 1');
      Add('Eintrag 1');
      Add('Eintrag 2');
      Add('Eintrag 1');
      Add('Eintrag 2');
      for i:= 0 to Count-1 do showmessage(Strings[i]);
    finally
      Free;
    end; 
  end;  
end; 

function BoolToStrDash(bool:boolean;Dashed:boolean):string;
begin
  if bool = Dashed
    then result:= '-'
    else
      if bool
        then result:= 'TRUE '
        else result:= 'FALSE';
end; 


procedure duplicateRandomTester(sample, oftot: integer);
 var sl : TStringList;
     cnt, q1,q2: integer;
begin
   sl:= TStringList.Create;
   try
   for cnt:= 1 to sample do
       sl.Add(IntToStr(Random(oftot))) ;
     {sl.sort; for cnt:= 1 to 1000 do 
     //stringlist.beginupdate;
        writeln((sl[cnt-1]));}
       q1:= TestDuplicates(sl); 
       Writeln('Test Duplicates: '+inttostr(q1)+' duplicate items found');
       q2:= FindDuplicates(sl);
       Writeln('With Duplicates: '+inttostr(q2)+' duplicates discarded'); 
       writeln('');
       for cnt:= 0 to sl.count-1 do write(sl[cnt]+' '); 
       PrintF('Dupl Quote: %f %%',[q2 / sample *100]); 
     
       //ShowMessage('With duplicates: ' + #13#10 + IntToStr(sl.Count));
       RemoveDuplicates(sl) ;
       Writeln('Without Duplicates: '+IntToStr(sl.Count)+' items found');
     finally
       writeln('');
       for cnt:= 0 to sl.count-1 do write(sl[cnt]+' '); 
       sl.Free;
    end;
end;

function duplicateRandomTester2(sample, oftot: integer): integer;
 var sl : TStringList;
     cnt, q1,q2: integer;
begin
   sl:= TStringList.Create;
   try
   for cnt:= 1 to sample do
       sl.Add(IntToStr(Random(oftot))) ;
     {sl.sort; for cnt:= 1 to 1000 do 
     //stringlist.beginupdate;
        writeln((sl[cnt-1]));}
       q1:= TestDuplicates(sl); 
       Writeln('Test Duplicates: '+inttostr(q1)+' duplicate items found');
       q2:= FindDuplicates(sl);
       result:= q2;
       Writeln('With Duplicates: '+inttostr(q2)+' duplicates discarded'); 
       //writeln('');
       //for cnt:= 0 to sl.count-1 do write(sl[cnt]+' '); 
       PrintF('Dupl Quote: %f %%',[q2 / sample *100]); 
     
       //ShowMessage('With duplicates: ' + #13#10 + IntToStr(sl.Count));
       RemoveDuplicates(sl) ;
       Writeln('Without Duplicates: '+IntToStr(sl.Count)+' items found');
     finally
       writeln('');
       //for cnt:= 0 to sl.count-1 do write(sl[cnt]+' '); 
       sl.Free;
    end;
end;

 var duplicate, distsum, tcnt: integer;

begin
  //clrscr;
  i:= 0;
  writeln('fibo is: ' + inttoStr(fibo(21)))
  writeln('fibo compare is: ' + floattoStr(fibo(21)))
  writeln('fibo compare is: ' + floattoStr(fibonacci(22)))
  writeln('faculty straigth is: ' + inttoStr(faculty(12)))
  writeln('faculty compare is: ' + floattoStr(fact(12)))
  writeln('palindrom> '+botostr(rectestWord('NEBEL',1)));
  
   {Randomize;
   duplicateRandomTester(40,60);
   maXcalcF('(((60!)/(20!))/(60^40))*100')
   duplicateRandomTester(40,100);
   maXcalcF('(((100!)/(60!))/(100^40))*100')
   duplicateRandomTester(40,200);
   maXcalcF('(((200!)/(160!))/(200^40))*100')   }
  
   //6^4 (four dice)
   //Randomize;
   //duplicateRandomTester(4,6);
     //if duplicate = 0 then distinct!
     
   Randomize;
   duplicate:= duplicateRandomTester2(4,6);
   writeln('duplicate values '+inttostr(duplicate));
   
   Randomize;
   distsum:= 0;
   for tcnt:= 1 to 100 do
     if duplicateRandomTester2(4,6) = 0 then
      inc(distsum);
   writeln('distinct overall % times: '+inttostr(distsum));
   
    maXcalcF('(6!)/(2!)')
    maXcalcF('(6!/2)/(6^4)*100')
    writeln('probability of rolling distinct values in 4 dice: '
               +FloattoStr(maXcalc('(6!/2)/(6^4)*100')));
  
    //More than 55% of the time you will see three unique values (one pair).
    
    writeln('probability of rolling 3 unique values in 4 dice (one pair): '
               +FloattoStr(maXcalc('(6!)/(3!)/(6^3)*100')));
      maXcalcF('(6!)/(3!)/(6^3)*100')
       
   (*sl:= TStringList.Create;
   try
     //sl.sorted:= true;
     //sl.Duplicates:= dupIgnore;
       //sl.beginupdate; 
     for cnt:= 1 to 1000 do
       sl.Add(IntToStr(Random(4000))) ;
     {sl.sort; for cnt:= 1 to 1000 do 
     //stringlist.beginupdate;
        writeln((sl[cnt-1]));}
        
       Writeln('Test Duplicates: '+inttostr(TestDuplicates(sl))+
                                  ' duplicate items found');
       Writeln('With Duplicates: '+FindDuplicates(sl)) 
       //ShowMessage('With duplicates: ' + #13#10 + IntToStr(sl.Count));
       RemoveDuplicates(sl) ;
       Writeln('Without Duplicates: '+IntToStr(sl.Count)+' items found');
     finally
       sl.Free;
    end;*)
    
    //ListDistinct;
End.

Ref:
 http://www.statsblogs.com/2013/07/01/duplicate-values-in-random-numbers-tossing-dice-and-sharing-birthdays/
 
 http://www.codeforge.com/ref/981039
 
 Doc:
  Those guesses are about twice as high as reality. Most rolls will contain duplicates. In order to get distinct values (no duplicates), the first die can show any of six faces, the second die can show any of five faces, and so on. The total number of possible rolls for four dice is 64. Consequently, the probability of rolling distinct values with four dice is (6*5*4*3) / 64 = 0.277 or about 28%.

Equivalently, 72% of the tosses result in one or more duplicate values. If you feel more comfortable with simulation than with combinatorics, the following statements simulate one million rolls of four dice. I count the number of unique values for each roll and tabulate the results:


Genetic Algorithm Maximum Power Point Tracking Solar PV Panel connected to Infinite Network
http://www.codeforge.com/article/240960