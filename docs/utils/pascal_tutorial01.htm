<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
<SCRIPT LANGUAGE="JavaScript">

<!--

function popUp(pPage) {
 var fullURL = document.location;
 var textURL = fullURL.toString();
 var URLlen = textURL.length;
 var lenMinusPage = textURL.lastIndexOf("/");
 lenMinusPage += 1;
 var fullPath = textURL.substring(0,lenMinusPage);
 popUpWin = window.open('','popWin','resizable=yes,scrollbars=no,width=525,height=394');
 figDoc= popUpWin.document;
 zhtm= '<HTML><HEAD><TITLE>' + pPage + '</TITLE>';
 zhtm += '<link rel="stylesheet" href="ebooks.css"></head>';
 zhtm += '<BODY bgcolor="#FFFFFF">';
 zhtm += '<IMG SRC="' + fullPath + pPage + '">';
 zhtm += '<P><B>' + pPage + '</B>';
 zhtm += '</BODY></HTML>';
 window.popUpWin.document.write(zhtm);
 window.popUpWin.document.close();
 // Johnny Jackson 4/28/98
 }

//-->
                                                                
</SCRIPT>
<link rel="stylesheet" href="ebooks.css">

 <META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
 <TITLE>Teach Yourself Borland Delphi 4 in 21 Days -- Ch 1 -- T</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1><IMG SRC="button/sams.gif" WIDTH="171" HEIGHT="66" ALIGN="BOTTOM" BORDER="0"></H1>

<H1><BR>
Teach Yourself Borland Delphi 4 in 21 Days</H1>
</CENTER>
<CENTER>
<P><A HREF="fm.htm"><IMG SRC="button/previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" ALT="Previous chapter" BORDER="0"></A><A HREF="ch02.htm"><IMG
SRC="button/next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" ALT="Next chapter"
BORDER="0"></A><A HREF="index.htm"><IMG SRC="button/contents.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" ALT="Contents" BORDER="0"></A> 
<HR>

</CENTER>
<CENTER>
<H1>- 1 -</H1>
</CENTER>
<CENTER>
<H1>Getting Started with Delphi</H1>
</CENTER>

<UL>
 <LI><A HREF="#Heading1">What Is Delphi?</A>
 <LI><A HREF="#Heading2">A Quick Look at the Delphi IDE</A>
 <UL>
  <LI><A HREF="#Heading3">The Object Inspector</A>
  <LI><A HREF=
"#Heading4">The Delphi Workspace</A>
	</UL>
	<LI><A HREF="#Heading5">Your First Program: Hello World</A>
	<UL>
		<LI><A HREF="#Heading6">Creating the Program</A>
		<LI><A HREF="#Heading7">Modifying the Program</A>
		<LI><A HREF="#Heading8">Closing the Program</A>
	</UL>
	<LI><A HREF="#Heading9">Your Second Program: Hello World, Part II</A>
	<UL>
		<LI><A HREF="#Heading10">Creating the Hello World II Program</A>
		<LI><A HREF="#Heading11">Modifying the Hello World II Program</A>
	</UL>
	<LI><A HREF="#Heading12">Object Pascal Language Overview</A>
	<LI><A HREF="#Heading13">In the Beginning...</A>
	<UL>
		<LI><A HREF="#Heading14">Pascal Units</A>
		<LI><A HREF="#Heading15">Comments in Code</A>
		<LI><A HREF="#Heading16">Variables</A>
		<LI><A HREF="#Heading17">Object Pascal Data Types</A>
		<LI><A HREF="#Heading18">Object Pascal Operators</A>
		<LI><A HREF="#Heading19">Constants</A>
		<LI><A HREF="#Heading20">Arrays</A>
		<LI><A HREF="#Heading21">Strings</A>
		<LI><A HREF="#Heading22">String Basics</A>
	</UL>
	<LI><A HREF="#Heading23">Summary</A>
	<LI><A HREF="#Heading24">Workshop</A>
	<UL>
		<LI><A HREF="#Heading25">Q&amp;A</A>
		<LI><A HREF="#Heading26">Quiz</A>
		<LI><A HREF="#Heading27">Exercises</A>
	</UL>
</UL>

<P>
<HR SIZE="4">

<CENTER>
<H1></H1>
</CENTER>
<P>Congratulations--you've chosen one of today's hottest programming tools! Before
you get started using all that Delphi has to offer, though, you first need to learn
a little about the Delphi IDE and about Object Pascal. In this chapter you will find</P>

<UL>
	<LI>A quick tour of Delphi
	<P>
	<LI>An introduction to the Object Pascal language
	<P>
	<LI>Facts about Pascal units, variables, and data types
	<P>
	<LI>A discussion of arrays
	<P>
	<LI>Information about strings in Pascal
</UL>

<H2><A NAME="Heading1"></A>What Is Delphi?</H2>
<P>By now you know that Delphi is Borland's best-selling rapid application development
(RAD) product for writing Windows applications. With Delphi, you can write Windows
programs more quickly and more easily than was ever p



ossible before. You can create
Win32 console applications or Win32 graphical user interface (GUI) programs. When
creating Win32 GUI applications with Delphi, you have all the power of a true compiled
programming language (Object Pascal) wrapped up in a RAD environment. What this means
is that you can create the user interface to a program (the <I>user interface</I>
means the menus, dialog boxes, main window, and so on) using drag-and-drop techniques
for true rapid application development. You can also drop ActiveX controls on forms
to create specialized programs such as Web browsers in a matter of minutes. Delphi
gives you all this, and at virtually no cost: You don't sacrifice program execution
speed because Delphi generates fast compiled code.</P>
<P>I can hear you saying, &quot;This is going to be so cool!&quot; And guess what?
You're right! But before you get too excited, I need to point out that you still
have to go to work and learn about Pascal programming. I don't want you to think
that you can buy a program like Delphi and be a master Windows programmer overnight.
It takes a great deal of work to be a good Windows programmer. Delphi does a good
job of hiding some of the low-level details that make up the guts of a Windows program,
but it cannot write programs for you. In the end, you must still be a programmer,
and that means you have to learn programming. That can be a long, uphill journey
some days. The good news is that Delphi can make your trek fairly painless and even
fun. Yes, you can work and have fun doing it!</P>
<P>So roll up your sleeves and put on your hiking shoes. Delphi <I>is </I>a great
product, so have fun.</P>
<P>
<H2><A NAME="Heading2"></A>A Quick Look at the Delphi IDE</H2>
<P>This section contains a quick look at the Delphi integrated development environment
(IDE). I'll give the IDE a once-over now and examine it in more detail on Day 4,
&quot;The Delphi IDE Explored.&quot; Because you are tackling Windows programming,
I'll assume you are advanced enough to have figured out how to st



art Delphi. When
you first start the program, you are presented with both a blank form and the IDE,
as shown in Figure 1.1.</P>
<P><A HREF="javascript:popUp('28670101.gif')"><B>FIGURE 1.1.</B></A><B> </B><I>The
Delphi IDE and the initial blank form.</I></P>
<P>The Delphi IDE is divided into three parts. The top window can be considered the
main window. It contains the toolbars and the Component palette. The Delphi toolbars
give you one-click access to tasks such as opening, saving, and compiling projects.
The Component palette contains a wide array of components that you can drop onto
your forms. (Components are text labels, edit controls, list boxes, buttons, and
the like.) For convenience, the components are divided into groups. Did you notice
the tabs along the top of the Component palette? Go ahead and click on the tabs to
explore the different components available to you. To place a component on your form,
you simply click the component's button in the Component palette and then click on
your form where you want the component to appear. Don't worry about the fact that
you don't yet know how to use components. You'll get to that in due time. When you
are done exploring, click on the tab labeled Standard, because you'll need it in
a moment.</P>
<P><strong>New Term:</strong> A c<I>omponent</I> is a self-contained binary piece of software
that performs some specific predefined function, such as a text label, an edit control,
or a list box.</P>
<P>
<H3><A NAME="Heading3"></A>The Object Inspector</H3>
<P>Below the main window and on the left side of the screen is the Object Inspector.
It is through the Object Inspector that you modify a component's properties and events.
You will use the Object Inspector constantly as you work with Delphi. The Object
Inspector has two tabs: the Properties tab and the Events tab. A component's <I>properties</I>
control how the component operates. For example, changing the Color property of a
component changes the background color of that component. The list of properties
available
varies from component to component, although components usually have several
common elements (Width and Height properties, for instance).</P>
<P><strong>New Term:</strong> A <I>property</I> determines the operation of a component.</P>
<P>The Events tab contains a list of events for a component. Events occur as the
user interacts with a component. For example, when a component is clicked, an event
is generated that tells you that the component was clicked. You can write code that
responds to these events, performing specific actions when an event occurs. As with
properties, the events that you can respond to vary from component to component.</P>
<P><strong>New Term:</strong> An <I>event</I> is something that occurs as a result of a
component's interaction with the user or with Windows.</P>
<P><strong>New Term:</strong> An <I>event handler</I> is a section of code that is invoked
in your application in response to an event.</P>
<P>
<H3><A NAME="Heading4"></A>The Delphi Workspace</H3>
<P>The main part of the Delphi IDE is the workspace. The workspace initially displays
the Form Designer. It should come as no surprise that the Form Designer enables you
to create forms. In Delphi, a <I>form</I> represents a window in your program. The
form might be the program's main window, a dialog box, or any other type of window.
You use the Form Designer to place, move, and size components as part of the form
creation process.</P>
<P>Hiding behind the Form Designer is the Code Editor. The Code Editor is where you
type code when writing your programs. The Object Inspector, Form Designer, Code Editor,
and Component palette work interactively as you build applications.</P>
<P>Now that you've had a look at what makes up the Delphi IDE, let's actually do
something.</P>
<P>
<H2><A NAME="Heading5"></A>Your First Program: Hello World</H2>
<P>It's tradition. Almost all programming books start you off by having you create
a program that displays Hello World on the screen. I'm tempted to do something else,
but tradition is not a force to be



 reckoned with, so Hello World it is. You've got
some work ahead of you in the next few chapters, so I thought I'd give you a taste
of Delphi's goodies before putting you to work learning the seemingly less glamorous
basics of the Pascal language. You'll have a little fun first. Delphi (and its cousin,
C++Builder) gives you possibly the quickest route to Hello World of any Windows programming
environment to date.</P>
<P>
<H3><A NAME="Heading6"></A>Creating the Program</H3>
<P>Right now you should have Delphi running, and you should be looking at a blank
form. By default, the form is named Form1<I>.</I> (The form name is significant in
Delphi, but I'll address that a little later.) To the left of the form, the Object
Inspector shows the properties for the form. Click on the title bar of the Object
Inspector. The Caption property is highlighted, and the cursor is sitting there waiting
for you to do something. (If the Caption property is not in view, you might have
to scroll the Object Inspector window to locate it. Properties are listed in alphabetical
order.) Type Hello World! to change the form's caption.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> As you modify properties, Delphi immediately displays the results
	of the property change when appropriate. As you type the new caption, notice that
	the window caption of the form is changing to reflect the text you are typing. 
<HR>


</BLOCKQUOTE>

<P>Now click the Run button on the toolbar (the one with the green arrow). (You can
also press F9 or choose Run | Run from the main menu.) Before you even know what
has happened, Delphi has built the program. The form is displayed, and the caption
shows Hello World!. In this case, the running program looks almost identical to the
blank form. You might scarcely have noticed when the program was displayed because
it is displayed in the exact location of the form in the Form Designer. (There is
a difference in appearance, though, because the Form Designer displays an alignment
grid and the running program does not.)
Congratulations--you've just written your
first Windows program with Delphi. Wow, that was easy!</P>
<P>&quot;But what is it?&quot; you ask. It's not a lot, I agree, but it is a true
Windows program. Try it out and see. The program's main window can be moved by dragging
the title bar, it can be sized, it can be minimized, it can be maximized, and it
can be closed by clicking the Close button. You can even locate the program in Windows
Explorer (it will probably be in your \Delphi40\Bin directory as Project1.exe) and
double-click on it to run it.</P>
<P>
<H3><A NAME="Heading7"></A>Modifying the Program</H3>
<P>Okay, so maybe displaying Hello World! in the caption was cheating a little. Let's
spruce it up a bit. If you still have the Hello World program running, close it by
clicking the Close button in the upper-right corner of the window. The Form Designer
is displayed again, and you are ready to modify the form (and, as a result, the program).</P>
<P>To make the program more viable, you're going to add text to the center of the
window itself. To do this, you'll add a text label to the form:</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>First, click on the Standard tab of the Component palette. The third
	component button on the palette has an <I>A</I> on it. If you put your mouse cursor
	over that button, the tooltip (a small pop-up window) will display Label.
	<P>
	<DT></DT>
	<DD><B>2. </B>Click the label button and then click anywhere on the form. A label
	component is placed on the form with a default caption of Label1.
	<P>
	<DT></DT>
	<DD><B>3. </B>Now turn your attention to the Object Inspector. It now displays the
	properties for Label1 (remember that previously it was showing the properties for
	Form1). Again the Caption property is highlighted.
	<P>
	<DT></DT>
	<DD><B>4. </B>Click on the title bar of the Object Inspector or on the Caption property
	and type Hello World!. Now the label on the form shows Hello World!.
	<P>
	<DT></DT>
	<DD><B>5. </B>As long as you're at it, you can change the size of the label's text




	as well. Double-click on the Font property. The property will expand to show the
	additional font attributes below it.
	<P>
	<DT></DT>
	<DD><B>6. </B>Locate the Size property under Font and change the font size to 24
	(it is currently set to 8). As soon as you press Enter or click on the form, the
	label instantly changes to the new size.
	<P>
</DL>

<P>Because the label is probably not centered on the form, you might want to move
it. To move a component, simply click on it and drag it to the position you want
it to occupy. When you have the label where you want it, you're ready to recompile
and run the program. Click the Run button again and, after a split second, the program
runs. Now you see Hello World! displayed in the center of the form as well as in
the caption. Figure 1.2 shows the Hello World! program running.</P>
<P><A HREF="javascript:popUp('28670102.gif')"><B>FIGURE 1.2.</B></A><B> </B><I>Your
</I>Hello World!<I> program running.</I>

<DL>
	<P>
</DL>

<P>
<H3><A NAME="Heading8"></A>Closing the Program</H3>
<P>With this little taste of Delphi, you can see that writing Windows programs with
Delphi is going to be a great deal more interesting than it was in the good ol' days.
To prepare for what you are going to do next, you need to close the current project
in the Delphi IDE. Choose File | Close All from the main menu. Click on No when prompted
to save changes to Project1, or save the project if you are fond of your new creation.</P>
<P>
<H2><A NAME="Heading9"></A>Your Second Program: Hello World, Part II</H2>
<P>Before you can move on to learning the Pascal language you need a little more
information about how Delphi works. You'll need this information to test the various
Pascal language features as you work through the next couple of days. This section
will contain just a glimpse into the power of Delphi. On Days 4, 5, and 6, you get
a more detailed look into how Delphi works.</P>
<P>
<H3><A NAME="Heading10"></A>Creating the Hello World II Program</H3>
<P>The goal of this exercise is to have the wor



ds Hello World, Part II appear on
the screen when a button is pressed. This exercise will also give you a pattern you
can follow when you test various code snippets as you work through the next couple
of days. Perform the following steps:</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>Choose File | New Application from the main menu to start a new application
	(click No if you're prompted to save the current project).
	<P>
	<DT></DT>
	<DD><B>2. </B>Click the Standard tab on the Component palette and click the icon
	that has an OK button on it (the Button component).
	<P>
	<DT></DT>
	<DD><B>3. </B>Place your cursor anywhere on the form and click. A button appears
	on the form.
	<P>
	<DT></DT>
	<DD><B>4. </B>Choose a Label component and place it near the center of the form.
	<P>
</DL>

<P>At this point your form should look similar to Figure 1.3. Notice that the label
component has a default caption of Label1 and the button has a default caption of
Button1.</P>
<P>
<H3><A NAME="Heading11"></A>Modifying the Hello World II Program</H3>
<P>In the first version of Hello World, you used the Object Inspector to change the
Caption property of a label. That change was applied at design time and as such was
seen as soon as the program ran. In this exercise, you are going to change the caption
of the label through code.</P>
<P><A HREF="javascript:popUp('286701x3.gif')"><B>FIGURE 1.3.</B></A><B> </B><I>The
new form after placing the button and label components.</I></P>


<BLOCKQUOTE>
	<P>
<HR>
<BR>
	<strong>NOTE:</strong> When you change a component's properties through the Object Inspector
	and Form Designer, you are said to make a <I>design-time</I> change. When you modify
	a property through code that executes when the program runs, you are said to make
	a <I>runtime</I> change. 
<HR>


</BLOCKQUOTE>

<P>To change the Caption property at runtime, follow these steps:</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>Double-click on the button on your form. As soon as you do, Delphi
	generates an event handler for the button's OnClick event. The gen



erated code looks
	like this:
</DL>



<BLOCKQUOTE>
	<PRE>procedure TForm1.Button1Click(Sender: TObject);
begin
end;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>2. </B>Right now you don't need to be concerned with everything you see here.
	You only need to understand that the OnClick event handler is a section of code that
	will be executed every time the button is clicked (as long as the program is running,
	that is). The editing cursor is placed between the begin and end statements and is
	waiting for you to type code. Enter this code at the cursor:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>Label1.Caption := `Hello World, Part II';</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD>I always indent two spaces (considered by many programmers to be proper coding
	practice) so my completed event handler now looks like this:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>procedure TForm1.Button1Click(Sender: TObject);
begin
  Label1.Caption := `Hello World, Part II';
end;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD>This code is pretty simple. It simply assigns the value Hello World, Part II
	to the Caption property of the label (the Caption property is used to set the text
	that the label displays).
	<P>
	<DT></DT>
	<DD><B>3. </B>Now click on the Run button on the toolbar to run the program. When
	you run the program, notice that the label still has the caption Label1. Click the
	form's button and the label's caption changes to Hello World, Part II. Hey, how about
	that! Magic? No, just Delphi at work!
	<P>
</DL>

<P>You'll be doing many such exercises in the next few days so you'll get plenty
of practice placing labels, buttons, and other components on the form. I realize
that I didn't fully explain what is going on behind the scenes here, but I don't
want to get ahead of myself so I'll save that explanation for a later time.</P>
<P>
<H2><A NAME="Heading12"></A>Object Pascal Language Overview</H2>
<P>Before you can learn about the RAD features of Delphi, you need to learn the basics
of the Object Pascal la



nguage. This part of the book will probably not be the most
exciting for you, but you need a basic understanding of Object Pascal before you
move on.</P>
<P>It would be nice if presenting the Object Pascal language could be handled sequentially.
That's not the case, though, because all the features you will learn about are intertwined.
I'll take the individual puzzle pieces one at a time and start fitting them together.</P>
<P>By the end of Day 3, you'll have a fairly complete picture of the Object Pascal
language. Don't be concerned if you don't instantly grasp every concept that is presented.
Some of what is required to fully understand Object Pascal can only come with real-world
experience.</P>
<P>During the next few days, you will see short code snippets that illustrate a particular
feature of the Object Pascal language. You will also do some exercises that enable
you to test your newfound knowledge. In the first few days, you will only see your
Delphi applications in small sections. I don't want to get ahead of myself and go
too far into the Delphi IDE or the Visual Component Library (VCL) at this early stage.
You will have to settle for bits and pieces until later in the book when you start
to get the complete picture. The code that you can download from the book's site
contains complete programs for some of the exercises that you will perform over the
next several days. (Go to http://www.mcp.com/info and type 0-672-31286-7.)</P>
<P>
<H2><A NAME="Heading13"></A>In the Beginning...</H2>
<P>Back in 1994 or so, Borland began working on a RAD tool that it code-named Delphi.
When it was decided that the component model architecture was the best way to implement
RAD, it was then necessary to settle on the programming language that would be the
heart of the system.</P>
<P>At that time, Borland was the only compiler vendor mass marketing a Pascal compiler.
Borland was known as the company that produced the best Pascal tools. If you were
a Pascal programmer, you probably used Borland's TurboPascal in one flavor or a



nother.
Borland more or less &quot;owned&quot; Pascal. Although Borland didn't own the Pascal
language in a legal sense, it no doubt felt that because of its position in the Pascal
world, it could take considerable liberties in implementing new language features
and enhancements. In addition, there was no Pascal standards committee, nor even
a written standard defining the Pascal language. So Borland created Delphi using
Pascal as the base language (the Borland internal code name stuck and became the
official product name).</P>
<P>Before Delphi came into being, Borland had already modified the Pascal language
in positive ways. For example, Borland had already extended Pascal by creating a
new language called Object Pascal. It can be said that Object Pascal is to Pascal
what C++ is to C. Object Pascal added classes to Pascal, thereby hurling Pascal into
the world of object-oriented programming (OOP) languages. As Delphi was being developed,
new language behavior and keywords were added to deal with the component model. Keywords
such as published and property were added, as were others. This enabled Borland to
fully implement the power of the component model. By modifying the Pascal language
to suit the component model, Borland was able to implement RAD the right way. In
essence, the Object Pascal language was modified as needed when design issues came
up during the development of the then-unknown product called Delphi. The result is
a language that works seamlessly with the component model.</P>
<P>Although modifying the Pascal language could be considered a bold step for Borland,
it was not without precedent. Previously, Microsoft had taken the BASIC language
and modified it to produce a new language called Visual Basic. This new language
was nearly unrecognizable when compared to the original BASIC language that served
as its base.</P>
<P>Borland took a risk in modifying Pascal. After all, it had a loyal base of customers
that might not take kindly to enhancements to the language they had come to know
and love. S



till, Borland was in a solid position in the Pascal market and went ahead
with its plans. The result was a smash hit, of course.</P>
<P>Make no mistake about it, Object Pascal is a powerful programming language, and
I don't make that statement lightly. I have a C/C++ background and, like other C/C++
programmers, I viewed Delphi with a bit of skepticism at first. I found out quickly,
though, that the Object Pascal language is very capable. In fact, in the hands of
the average programmer there is almost no difference in the two languages in terms
of power. Object Pascal is unique in that it is both powerful <I>and</I> relatively
easy to learn. I don't in any way want to leave the impression that Object Pascal
is a not a full-featured programming language. Pascal has often been knocked as a
less-than-serious programming language. That has never been true, and is even less
true with today's Object Pascal.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> Several different terms have been adopted by Delphi programmers to
	describe what they do. The base language of Delphi is, of course, Object Pascal,
	and some folks call it exactly that. Others might say, &quot;I program in Pascal,&quot;
	or even just, &quot;I'm a Delphi programmer.&quot; In the end it's up to you to decide
	what terminology you will use. I'll use the terms Object Pascal and Pascal interchangeably
	throughout this book and will typically reserve use of the word Delphi to refer to
	the Delphi IDE or its tools. 
<HR>


</BLOCKQUOTE>

<P>Object Pascal enables you to take advantage of object-oriented programming to
its fullest. OOP is not just a buzzword. It has real benefits because it enables
you to create objects that can be used in your current program and reused in future
programs.</P>
<P><strong>New Term:</strong> An <I>object</I>, like components described earlier, is a
binary piece of software that performs a specific programming task. (Components are
objects, but not all objects are components. I'll explain that later.)</P>
<P>An object reveal



s to the user (the programmer using the object) only as much of
itself as needed; therefore, using the object is simplified. All internal mechanisms
that the user doesn't need to know about are hidden from sight. All this is included
in the concept of object-oriented programming. OOP enables you to take a modular
approach to programming, thus keeping you from constantly re-inventing the wheel.
Delphi programs are very OOP-centric because of Delphi's heavy use of components.
After a component is created (either one of your own or one of the built-in components),
it can be reused in any Delphi program. A component can also be extended by inheritance
to create a new component with additional features. Best of all, components hide
their internal details and let the programmer concentrate on getting the most out
of the component. Objects and classes are discussed in detail on Day 3, &quot;Classes
and Object-Oriented Programming.&quot;</P>
<P>
<H3><A NAME="Heading14"></A>Pascal Units</H3>
<P>Programming is more than just typing code. Ultimately, it is the combination of
conceptualizing a programming task and then typing code to carry out that task. The
code you type simply goes into a text file. The compiler takes that text file and
compiles it into machine code that the computer can understand. The text file that
Delphi compiles into machine code is called a unit.</P>
<P><strong>New Term:</strong> A <I>unit </I>is a text file that can be compiled into a module
of code.</P>
<P>
<H4>Types of Units</H4>
<P>A Delphi GUI application will contain at least two units. The project source unit
contains the project source code. Project source code units have an extension of
DPR. You can view the project source unit by choosing Project | View Source from
the main menu. It is not normally necessary to modify the project source unit. In
fact, you shouldn't modify the project source unit unless you know exactly what you
are doing. If you accidentally modify the project source unit in undesirable ways,
you might find that your applic



ation won't compile anymore. (Certain advanced programming
techniques require modification of the project source code, but that's not something
you need to be concerned with at this time.)</P>
<P>The second type of unit that a Delphi GUI application always has is the main form's
unit. A form unit, as its name implies, is a source code unit with an associated
form. This type of unit has a filename extension of PAS. This is the type of unit
you will use most often in your Delphi programs. A Delphi GUI application will always
have one form unit (for the main form), but it can have one or more additional form
units as well. For example, an application that displays an About box will have the
main form unit and a unit for the About box.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> You might have noticed that I keep saying &quot;Delphi GUI application.&quot;
	This is because I want to distinguish a GUI application from a console mode application.
	A console mode application is a 32-bit Windows application that runs in a console
	window (DOS box). A console application has no main form and may or may not contain
	other forms. A console application does, however, have one or more units. 
<HR>


</BLOCKQUOTE>

<P>There is a third type of unit you can use in Delphi applications. This type of
unit is a unit that contains only source code. A code-only unit contains code that
is called from other units in the project. I won't go into any more detail than that
right now, but you'll learn more about this type of unit in later chapters.</P>
<P>
<H4>Anatomy of a Delphi Unit</H4>
<P>Delphi units must follow a predefined format. This shouldn't come as a surprise
to you. The unit has to be in a predefined format so that the compiler can read the
unit and compile the unit's code.</P>
<P>A Delphi project unit contains the program keyword followed by the name of the
unit and a code block marked by the begin and end keywords. You can see how a basic
unit looks by choosing View | Project Source from the Delphi main menu. The proje



ct
source unit for a default Delphi project looks like Listing 1.1.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> The line numbers in Listing 1.1 are not part of the unit itself.
	I have put them there for reference only. Some of the listings you see in this book
	will have line numbers for reference and others will not. In either case, be sure
	to understand that the Pascal language does not use line numbers as some other languages
	do (most notably, BASIC). 
<HR>


</BLOCKQUOTE>

<P>
<H4>LISTING 1.1. THE PROJECT SOURCE FOR A DEFAULT DELPHI PROJECT.</H4>
<PRE>01: program Project1;
02: 
03: uses
04:   Forms,
05:   Unit1 in `Unit1.pas' {Form1};
06:
07: {$R *.RES}
08:
09: begin
10:   Application.Initialize;
11:   Application.CreateForm(TForm1, Form1);
12:   Application.Run;
13: end.
</PRE>
<P>On line 1, the program keyword identifies this unit as a program's main source
unit. You can see that the unit name, Project1, follows the program keyword (Delphi
gives the project a default name until you save the project with a more meaningful
name). Beginning on line 3, you see a section identified by the uses keyword. Any
unit names following the uses keyword, up to the semicolon, are other units that
this unit requires in order to compile. The uses keyword is described in more detail
a little later in the section, &quot;The uses List.&quot;</P>
<P>On line 7 you see a compiler directive that tells Delphi to include this project's
resource file. Resource files are discussed in more detail on Day 8, &quot;Creating
Applications in Delphi.&quot;</P>
<P>Line 9 contains the begin keyword, and line 13 contains the end keyword. Notice
that the final end keyword in the unit is followed by a period. (A unit can have
many code blocks marked with begin and end, but only one final end statement.) The
code on lines 10, 11, and 12 is code that initializes the application, creates the
application's main form, and starts the application running. You don't need to be
concerned about the details of this code to write Delphi programs.</



P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> The begin and end keywords mark a code block. A code block can contain
	just a few lines of code, or it can contain several hundred lines of code (or even
	thousands of lines). You will see the begin and end keywords used throughout the
	book. As you work through the book, you will get a better handle on how and when
	the begin and end keywords are used. 
<HR>


</BLOCKQUOTE>

<P>Let's take a look at another basic Pascal unit. Choose File | New from the main
menu. When the New Items dialog comes up, locate the icon labeled Unit and double-click
it. Delphi will create a new unit and display it in the Code Editor. Listing 1.2
shows the code generated for this unit.</P>
<P>
<H4>LISTING 1.2. A BLANK PASCAL UNIT.</H4>
<PRE>01: unit Unit2;
02:
03: interface
04:
05: implementation
06:
07: end.
</PRE>
<PRE>There isn't much here, is there? This unit has two things in common with the unit shown in Listing 1.1. First, the unit starts with the unit keyword followed by the unit name Unit2 (again, a default name created by Delphi). I realize the code in 
Listing 1.1 starts with the program keyword and this code starts with the unit keyword, but there are a few common elements: A Pascal unit starts with one of these two keywords followed by the unit name, and the end keyword appears at the end of both 
listings. Here again, the end keyword is followed by a period to mark the end of the unit.
</PRE>
<P>The code in Listing 1.2 differs from that of Listing 1.1 in that it has sections
marked interface and implementation. A unit that is not the program's main source
unit must contain an interface section and an implementation section. These two keywords
will be described in more detail in the sections entitled, &quot;The interface Section&quot;
and &quot;The implementation Section,&quot; respectively. Listing 1.2 also differs
from Listing 1.1 in that there is no begin statement. A program's main unit must
have both begin and end statements, but a source unit only has to contain a fi



nal
end statement.</P>
<P>The following sections describe keywords that are used within a Pascal unit.</P>
<P>
<H4>The uses List</H4>
<P><strong>New Term:</strong> The <I>uses list</I> is a list of external units that this
unit references.</P>
<P>Refer to Listing 1.1. Notice the uses keyword on line 3. The uses keyword designates
the start of a section that will contain a list of other units that this unit is
dependent on. For example, line 11 of Listing 1.1 looks like this:</P>
<P>
<PRE>Application.CreateForm(TForm1, Form1);
</PRE>
<P>This line of code contains information that is located in other units and cannot
be found in this unit. The procedure identified by Application.CreateForm is located
in a Delphi unit called Forms.pas, and the identifiers TForm1 and Form1 are located
in the project's main form unit, which is called Unit1.pas. Do you see the connection?
The uses list tells Delphi where to look for additional information that it will
need to compile this unit. Here's another look at the uses list:</P>
<P>
<PRE>uses
  Forms,
  Unit1 in `Unit1.pas' {Form1};
</PRE>
<P>Notice that the uses list contains two unit names, Forms and Unit1. In some ways
this is not a good example of a uses list because the second unit listed contains
additional text not usually found in a uses list (Unit1 in `Unit1.pas' {Form1}).</P>
<P>This text is used to specify a form that is contained in a unit and is only used
by the project's main source unit. (The text between the curly braces is a comment
used for reference and has no bearing on the rest of the code. Comments are discussed
later in the section &quot;Comments in Code.&quot;)</P>
<P>There are two rules you need to be aware of when constructing the uses list:</P>

<UL>
	<LI>First, each unit in the list must be separated from the following unit by a comma.
	<P>
	<LI>Second, a semicolon must follow the last unit listed. The semicolon marks the
	end of the uses list.
</UL>

<P>Naturally the list must contain valid unit names. The uses list, then, is designated
by the uses k



eyword and ends with a semicolon. Other than that, it doesn't matter
how the uses list is organized. For example, the following two uses lists are identical
as far as the compiler is concerned:</P>
<P>
<PRE>uses
  Windows, Messages, SysUtils, Classes, Graphics, 
  Controls, Forms, Dialogs, StdCtrls;
uses
  Windows, 
  Messages, 
  SysUtils, 
  Classes, 
  Graphics, 
  Controls, 
  Forms, 
  Dialogs,
  StdCtrls;
</PRE>
<P>A unit can have any number of uses lists. It is not required that all units needed
by this unit be in a single uses list.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> In some cases, Delphi will add units to your uses list for you. This
	is done via the File | Use Unit menu item. This feature will be discussed in more
	detail on Day 4. 
<HR>


</BLOCKQUOTE>

<H4><BR>
The interface Section</H4>
<P>Take another look at Listing 1.2. Notice that this listing has a section marked
by the interface keyword. This keyword marks the start of the interface section for
the unit.</P>
<P>The <I>interface section</I> is the section of a unit in which identifiers exported
from this unit are declared. An <I>exported </I>identifier is one that can be accessed
by other units in the project.</P>
<P>Most units will contain code that other units use. The code might be implemented
as a class, a procedure, a function, or a data variable. Any objects that are available
to other units from this unit must be declared in the interface section. You could
say that the interface section contains a list of items in this unit that other units
can use. The interface section starts with the interface keyword and ends at the
implementation keyword.</P>
<P>
<H4>The implementation Section</H4>
<P><strong>New Term:</strong> The <I>implementation section</I> of a unit is the section
that contains the actual code for the unit.</P>
<P>The implementation section starts with the implementation keyword and ends with
the next unit keyword. The next unit keyword is usually the unit's final end keyword,
but could be the initialization ke



yword in units that have an initialization section.
It's difficult to say more than that right now, because there are other aspects of
Pascal that I need to discuss before tying all of this together. However, let me
give you an example that will illustrate the use of the interface and implementation
sections.</P>
<P>Let's say that you create a unit that has a procedure called DoSomething. Let's
further say you want DoSomething to be available to other units in your project.
In that case, you would declare the DoSomething procedure in the interface section
and then define the procedure in the implementation section. The entire unit would
look like Listing 1.3.</P>
<P>
<H4>LISTING 1.3. A UNIT WITH A PUBLIC FUNCTION.</H4>
<PRE>unit Unit2;
interface
  procedure DoSomething;
implementation
  procedure DoSomething;
  begin
</PRE>
<PRE>    { Code for DoSomething goes here. }
</PRE>
<PRE>  end;
end.
</PRE>
<P>Notice that the DoSomething procedure is declared in the interface section and
defined later in the implementation section. I realize I'm getting a little ahead
of myself here. Functions and procedures will be discussed more tomorrow, and I'll
go over declarations and definitions in detail at that time.</P>
<P>
<H4>The initialization and finalization Sections</H4>
<P>The initialization and finalization sections can be used to perform any startup
and cleanup code that a unit requires. Any code in the initialization section will
be executed when the unit is loaded into memory. Conversely, any code in the finalization
section will be executed just before the unit is unloaded from memory. You can have
just an initialization section, but you cannot have a finalization section without
an initialization section. The initialization and finalization sections are optional.</P>
<P>
<H4>Additional Keywords Used in Units</H4>
<P>A Pascal unit can contain other, optional keywords that mark sections set aside
for a particular purpose. Some of these keywords have multiple uses. The following
sections describe those keywords only as



 they pertain to units.</P>
<P><B>The const Keyword</B></P>
<P>A unit can optionally have one or more const sections. The const section is designated
with the const keyword. The const section describes a list of variables that are
known as constants.</P>
<P>A <I>constant</I> is an identifier that cannot change. For example, let's say
you have certain values that your program uses over and over. You can set up constant
variables for those values. To illustrate, let's add a const section to the program
in Listing 1.3. You'll add one const section for constants that are public (available
to other units) and another const section for constants that are available only to
this unit. Listing 1.4 shows the unit with the two const sections added.</P>
<P>
<H4>LISTING 1.4. THE UNIT WITH const SECTIONS ADDED.</H4>
<PRE>unit Unit2;
interface
const
  AppCaption = `My Cool Program 1.0';
  procedure DoSomething;
implementation
const
  BaseX = 20;
  BaseY = 200;
  procedure DoSomething;
  begin
    { Code for DoSomething goes here. }
  end;
end.
</PRE>
<P>Because the AppCaption constant is declared in the interface section, it can be
used anywhere in the unit <I>and</I> in any unit that has this unit in its uses list.
The BaseX and BaseY constants, however, are only available within this unit because
they are declared in the implementation section.</P>
<P>The const keyword has other uses besides the one described here. I'll discuss
one of those uses tomorrow in the section, &quot;Value, Constant, and Variable Parameters.&quot;</P>
<P><B>The type Keyword</B></P>
<P><strong>New Term:</strong> The <I>type</I> keyword is used to declare new types that
your program will use.</P>
<P>Declaring a new type is an esoteric programming technique that is difficult to
explain at this stage of the game, so perhaps an example will help. Let's say that
your application needs an <I>array</I> (a collection of values) of 20 bytes and that
this type of array will be used over and over again. You can declare a new type as
follows:</P>
<P>
<PRE>type

TMyArray = array [0..19] of Byte;
</PRE>
<P>Now you can use the identifier TMyArray instead of typing out array [0..19] of
Byte every time you want an array of 20 bytes. I'll have to leave it at that for
now, but you'll see more examples of declaring types later in the book.</P>
<P><B>The var Keyword</B></P>
<P><strong>New Term:</strong> The <I>var</I> keyword is used to declare a section of code
in which variables are declared.</P>
<P>You use the var keyword to declare variables (variables are discussed in detail
in the section entitled &quot;Variables&quot;). There are several places you can
declare a var section. You can have a var section at the unit level, you can have
a var section for a procedure or function, or both. You can even have multiple var
sections in a unit. Listing 1.5 shows the sample unit with type and var sections
added.</P>
<P>
<H4>LISTING 1.5. THE UNIT WITH type AND var SECTIONS ADDED.</H4>
<PRE>unit Unit2;
interface
type
</PRE>
<PRE>  TMyArray = array [0..19] of Byte;
</PRE>
<PRE>const
  AppCaption = `My Cool Program 1.0';
var
  X : Integer;
  MyArray : TMyArray;
  procedure DoSomething;
implementation
const
  BaseX = 20;
  BaseY = 200;
  procedure DoSomething;
  begin
    { Code for DoSomething goes here. }
  end;
end.
</PRE>
<P>As with the const keyword, the var keyword has more than one use. It is also used
to declare function and procedure parameters as variable parameters. Rather than
go into that now, I'll save that discussion for tomorrow when you read about functions
and procedures.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> The sections described by the var, const, and type keywords begin
	at the keyword and end at the next keyword in the unit. 
<HR>


</BLOCKQUOTE>

<P>
<H3><A NAME="Heading15"></A>Comments in Code</H3>
<P>Before getting into the Pascal language in detail, let me talk briefly about commenting
code. <I>Comments</I> are lines of text in your source code that are there for documentation
purposes. Comments can be used to describe what the code does, to supply



 copyright
information, or simply to make a note to yourself or other programmers.</P>
<P>Comments can be designated in as many as three different ways. The following are
all valid comments lines:</P>
<P>
<PRE>{ Don't forget to free this memory! }
{
 ADTAPI.PAS 2.50
 Copyright (c) TurboPower Software 1996-98
}
(* Mason needs to fix this section of code *)
// This is really good code!
{ This code needs to be reworked later }
</PRE>
<P>Probably the most common type of comment used in Delphi programs uses curly braces
as illustrated in the first two cases above. The opening brace is used to start a
comment, and the closing brace is used to end a comment. Another type of comment
uses (* to start the comment, and *) to end the comment. There is one difference
between comments designated this way as opposed to using curly braces: The (*/*)
comment pair can be used to block out large sections of code containing other comment
lines. These two comment types can be used to comment single lines of code or multiple
lines.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> Curly braces have another use in Pascal. When used in conjunction
	with a dollar sign, the braces signify a compiler directive. To tell the compiler
	not to generate compiler hints, you can put a line like this in your source code:</P>
	<PRE>{$HINTS OFF}</PRE>

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<P>When the compiler sees this line, it stops generating hints in this unit until
	a corresponding {$HINTS ON} directive is encountered. I'll talk about individual
	compiler directives at different points in the book as the need arises. 
<HR>


</BLOCKQUOTE>

<P>The third type of comment is designated by the double slash. This is often called
the C-style comment because it is used by C and C++. This type of comment can only
be used on single lines of code. You should also be aware that this type of comment
is not valid in all versions of Delphi. If you are writing code that might be used
in Delphi 1 as well as later versions, you should be sure not to use t



his style of
comment.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> I use the curly brace style of comment for production code (code
	that others will see). I use the double slash type of comment for quickly commenting
	out a line or two for testing purposes, but only as a temporary measure. I rarely
	use the (*/*) style of comment. 
<HR>


</BLOCKQUOTE>

<P>Any commented text is ignored by the compiler. If you are using the default Delphi
IDE settings, all comment lines will show up in italicized, blue text. This makes
it easy to quickly identify comment lines.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> If you work in a team programming environment, you might have to
	read your coworkers' code and vice versa. Concise comments in the code can save hours
	of time for any programmer who has to read and maintain another programmer's code.
	Even if you work in a single-programmer environment, commenting your code is a good
	idea. You'd be surprised how quickly you forget what code you wrote is supposed to
	do. Good code commenting can save you and your coworkers hours of time, so don't
	forget to comment your code! 
<HR>


</BLOCKQUOTE>

<H3></H3>
<H3><A NAME="Heading16"></A>Variables</H3>
<P>Variables have to be declared before they can be used. You declare a variable
in a special section of code designated with the var keyword, as described earlier--for
example,</P>
<P>
<PRE>var
  X : Integer;  { variable X declared as an integer variable }
  Y : Integer;  { variable Y declared as an integer variable }
</PRE>
<PRE>Earlier, I talked about the var keyword in terms of a Pascal unit. In that section, I said that variables used in the unit are declared in the unit's var section. That's true, but you can also have a var section in a function or procedure. This 
enables you to declare variables in functions and procedures as well as in units. Here's an example of a var section in a procedure:
</PRE>
<PRE>procedure TForm1.Test;
var
  S : string;
begin
  S := `Hello World!';
  Label1.Caption := S;
end;
</PRE>




<P>After you declare a variable, you can then use it to manipulate data in memory.
That probably doesn't make much sense to you, so let me give you a few examples.
The following code snippet uses the variables called X and Y declared earlier. At
the end of each line of code is a comment that describes what is happening when that
line executes:</P>
<P>
<PRE>X := 100;       { `X' now contains the value 100 }
X := X + 50;    { `X' now contains the value 150 }
Y := 150;       { `Y' now contains the value 150 }
X := X + Y;     { `X' now contains the value 300 }
Inc(X);         { Increment. `X' now contains the value 301 }
</PRE>
<P>A <I>variable</I> is a location set aside in computer memory to contain some value.</P>
<P>I want you to notice several things about this code. First, notice that the value
of X changes as the variable is manipulated. (A little later I'll discuss the Object
Pascal operators, functions, and procedures used to manipulate variables.) You can
see that the variables are assigned values, added together, incremented, and so on.</P>
<P>Notice also that each statement in this code segment ends in a semicolon. The
semicolon</P>
<P>is used at the end of every statement in a Pascal program.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> Very early in the process of learning the Pascal language, the budding
	programmer must learn the difference between an expression and a statement. The official
	definition of a <I>statement</I> is an expression that is followed by a semicolon.
	An <I>expression</I> is a unit of code that evaluates to some quantity. Confused?
	Consider the following statement:</P>
	<PRE>c := a + b;</PRE>

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<P>In this example, the portion to the right of the assignment operator, a + b, is
	an expression. The entire line is a statement. You could say that an expression is
	a subset of a statement. A single statement can be made up of several expressions.
	I know this might be a bit confusing at the moment, but it will become clearer as
	you
go along. For now just remember that a statement is followed by a semicolon.
	(There are some cases in which a semicolon is not used at the end of each line, but
	this does not violate the rule that a semicolon is placed at the end of each statement.
	I'll go over those exceptions later in the book as we encounter them.) 
<HR>


</BLOCKQUOTE>

<P>Variable names follow the rules described for <I>identifiers</I>. In addition
to variables, identifiers are used for function names, procedure names, fields in
records, unit names, and more. Identifiers can mix uppercase and lowercase letters
and can include numbers and the underscore (_), but they cannot contain spaces or
other special characters. The identifier must start with a character or the underscore.
There is no maximum allowable length for identifiers, but anything over 255 characters
is ignored. In reality, anything more than about 20 characters is too long to be
useful anyway. The following are examples of valid variable names:</P>
<P>
<PRE>aVeryLongVariableName : Integer; { a long variable name }
my_variable : Integer; { a variable with an underscore }
x : Integer; { single digit variable name }
X : Integer; { same as above }
Label2 : string;  { a variable name containing a number }
</PRE>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> The Pascal language is not case sensitive. The following statements
	are all valid:</P>
	<PRE>var
  XPos : Integer;
{ ...later }
XPos := 20;
XPOS := 200;
xpos := 110;
XpoS := 40;</PRE>

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<P>If you are coming from a language where case counts (C or C++, for instance),
	the case-insensitive nature of Object Pascal might seem a bit odd at first, but you'll
	get used to it quickly enough. 
<HR>
</P>
	<P>
<HR>
<strong>NOTE:</strong> Even though Pascal is case insensitive, you should strive to use
	consistent capitalization in your programs. Using proper capitalization makes a program
	easier to read and will save more than a few headaches if you ever need to port your
	application to other



 programming languages later on (porting a Delphi program to
	C++Builder, for example). 
<HR>


</BLOCKQUOTE>

<H3></H3>
<H3><A NAME="Heading17"></A>Object Pascal Data Types</H3>
<P><strong>New Term:</strong> In Object Pascal, a <I>data type</I> defines the way the compiler
stores information in memory.</P>
<P>In some programming languages, you can get by with assigning any type of value
to a variable. For example, look at the following examples of BASIC code:</P>
<P>
<PRE>X = -1;
X = 1000;
X = 3.14;
</PRE>
<PRE>In BASIC, the interpreter takes care of allocating enough storage to fit any size or type of number.
</PRE>
<H4>Declaring a Variable</H4>
<P>In Object Pascal, you must declare a variable's type before you can use the variable:</P>
<P>
<PRE>var 
  X1 : Integer;
  X  : Integer;
  Y  : Double;
  Z  : Byte;
{ ...later }
X1 := -1;
X  := 1000;
Y  := 3.14;
Z  := 27;
</PRE>
<P>This enables the compiler to do type-checking and to make sure that things are
kept straight when the program runs. Improper use of a data type will result in a
compiler error or warning that can be analyzed and corrected so that you can head
off a problem before it starts.</P>
<P>Some data types are signed and some are unsigned. A <I>signed</I> data type can
contain both negative and positive numbers, whereas an <I>unsigned</I> data type
can contain only positive numbers. Table 1.1 shows the basic data types in Object
Pascal, the amount of memory each requires, and the range of values possible for
each data type. This table does not include the string types. Those are discussed
later in the section, &quot;Strings.&quot;</P>
<P>
<H4>TABLE 1.1. DATA TYPES USED IN OBJECT PASCAL (32-BIT PROGRAMS).</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>Data Type</I></TD>
		<TD ALIGN="LEFT"><I>Size in Bytes</I></TD>
		<TD ALIGN="LEFT"><I>Possible Range of Values</I></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">ShortInt</TD>
		<TD ALIGN="LEFT">1</TD>
		<TD ALIGN="LEFT">-128 to 127</TD>
	</TR>
	<TR ALIG



N="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Byte</TD>
		<TD ALIGN="LEFT">1</TD>
		<TD ALIGN="LEFT">0 to 255</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Char</TD>
		<TD ALIGN="LEFT">1</TD>
		<TD ALIGN="LEFT">0 to 255 (same as Byte)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">WideChar</TD>
		<TD ALIGN="LEFT">2</TD>
		<TD ALIGN="LEFT">0 to 65,535 (same as Word)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">SmallInt</TD>
		<TD ALIGN="LEFT">2</TD>
		<TD ALIGN="LEFT">-32,768 to 32,767</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Word</TD>
		<TD ALIGN="LEFT">2</TD>
		<TD ALIGN="LEFT">0 to 65,535</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">LongInt</TD>
		<TD ALIGN="LEFT">4</TD>
		<TD ALIGN="LEFT">-2,147,483,648 to 2,147,483,647</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Int64</TD>
		<TD ALIGN="LEFT">8</TD>
		<TD ALIGN="LEFT">-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Integer</TD>
		<TD ALIGN="LEFT">4</TD>
		<TD ALIGN="LEFT">Same as LongInt</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Cardinal</TD>
		<TD ALIGN="LEFT">4</TD>
		<TD ALIGN="LEFT">0 to 2,147,483,647</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Single</TD>
		<TD ALIGN="LEFT">4</TD>
		<TD ALIGN="LEFT">1.5 &#165; 10<SUP>-45</SUP> to 3.4 &#165; 10<SUP>38</SUP></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Double</TD>
		<TD ALIGN="LEFT">8</TD>
		<TD ALIGN="LEFT">5.0 &#165; 10<SUP>-324</SUP> to 1.7 &#165; 10<SUP>308</SUP></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Real</TD>
		<TD ALIGN="LEFT">8</TD>
		<TD ALIGN="LEFT">5.0 &#165; 10<SUP>-324</SUP> to 1.7 &#165; 10<SUP>308</SUP> (same as Double)</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Extended</TD>
		<TD ALIGN="LEFT">10</TD>
		<TD ALIGN="LEFT">3.4 &#165; 10<SUP>-4932</SUP> to 1.1 &#165; 10<SUP>4932</SUP></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN=



"TOP">
		<TD ALIGN="LEFT">Comp</TD>
		<TD ALIGN="LEFT">8</TD>
		<TD ALIGN="LEFT">-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Currency</TD>
		<TD ALIGN="LEFT">8</TD>
		<TD ALIGN="LEFT">-922,337,203,685,477.5808 to 922,337,203,685,477.5807</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Boolean</TD>
		<TD ALIGN="LEFT">1</TD>
		<TD ALIGN="LEFT">True or False</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Variant</TD>
		<TD ALIGN="LEFT">16</TD>
		<TD ALIGN="LEFT">Varies</TD>
	</TR>
</TABLE>
</P>
<P>Examining Table 1.1, you might notice that an Integer is the same as a LongInt.
So why does Object Pascal have two different data types that are exactly the same?
Essentially, it's a holdover from days gone by. In a 16-bit programming environment,
an Integer requires 2 bytes of storage and a LongInt requires 4 bytes of storage.</P>
<P>In a 32-bit programming environment, however, both require 4 bytes of storage
and have the same range of values. Delphi 4 produces only 32-bit programs, so an
Integer and a LongInt are identical. Most programmers use Integer rather than LongInt.</P>
<P>You might also notice that the Int64 and Comp (computational) types have an identical
range of values. The difference between these two types is in the way they are treated
internally by the compiler. The Int64 type is an integer type, whereas the Comp type
is a real type. Probably you will have very little reason to use the Comp type in
your programs.</P>
<P>Notice also that the Real and Double data types are identical. In previous versions
of Delphi, the Real type was a 6-byte variable. Now it is an 8-byte variable. This
change was made to make the Real data type compatible with today's processors. The
Real type is considered obsolete and you should use Double rather than Real in your
Delphi applications.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> The Int64 data type is new to Delphi 4. There are many reasons for
	an integer type



 of this size. One of the most compelling is the need for an integer
	value that can hold the huge values required by today's larger hard drives. For example,
	Windows contains a function called GetDiskFreeSpaceEx, which can return values much
	larger than 2,147,483,647 (the maximum value of an Integer). A 64-bit integer data
	type was needed for reasons like this. 
<HR>
<BR>
	
<HR>
<strong>NOTE:</strong> The Single, Double, Extended, and Currency data types use floating-point
	numbers (numbers with decimal places). The other data types deal only with integer
	values. You cannot assign a value containing a decimal fraction to an integer data
	type. For example, the following code will generate a compiler error:</P>
	<PRE>var
  X : Integer;
{ Later... }
X := 3.75;</PRE>

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<P>You don't really have to worry about this too much, because the compiler is very
	good at telling you what you can and cannot do. By the way, you'd be surprised how
	few times you need floating-point numbers in most Windows programs. 
<HR>


</BLOCKQUOTE>

<H3></H3>
<H4>Converting Between Data Types</H4>
<P>Object Pascal performs conversion between different data types when possible.
Take the following code snippet for an example:</P>
<P>
<PRE>var
  Res : SmallInt;
  Num1 : Integer;
  Num2 : Integer;
{ Later... }
  Num1 := 200;
  Num2 := 200;
  Res  := Num1 * Num2;
</PRE>
<P>In this case I am trying to assign the result of multiplying two Integers to a
SmallInt. Even though this formula mixes two data types, Object Pascal is able to
perform a conversion. Would you like to take a guess at the result of this calculation?
You might be surprised to find out that the result is -25,536. What!? If you look
at Table 1.1, you'll see that a SmallInt can have a maximum value of 32,767. What
happens if you take a SmallInt with a value of 32,767 and add 1 to it? You will get
a value of -32,768. This is essentially the same as the odometer on a car turning
over from 99,999 to 00,000 when you drive that last mile. To



 illustrate, perform
the following steps:</P>

<DL>
	<DT></DT>
	<DD><B>1. </B>Start with a new application and place a label and button on the form.
	<P>
	<DT></DT>
	<DD><B>2. </B>Double-click the button to create an event handler for the button's
	OnClick event.
	<P>
	<DT></DT>
	<DD><B>3. </B>Modify the event handler so that it looks like this:
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>procedure TForm1.Button1Click(Sender: TObject);
var
  X : SmallInt;
begin
  X := 32767;
  X := X + 1;
  Label1.Caption := IntToStr(X);
end;	</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>4. </B>Run the program and click the button.
	<P>
</DL>

<P>You should see the caption of the label change to -32768 when you click the button
(in case you wondering, the IntToStr function translates an integer value to a string).
This exercise illustrates that 32767 plus 1 equals -32768! Okay, maybe not quite.</P>
<P>This example really illustrates what is known as <I>overflow</I> or <I>wrapping</I>.
You should be aware of the maximum possible values your variables can contain and
choose the data type that is large enough to guarantee that the variable will contain
the value without overflowing. For the most part, you won't go too far wrong if you
use the Integer data type as your data type of choice. You are unlikely to run into
the problem of wrapping because the Integer data type gives you an approximate range
of -2 billion to +2 billion.</P>
<P>Okay, where was I? Oh, yes, I was talking about automatic type conversion. In
some cases, Object Pascal cannot perform a conversion. If that is the case, you will
get a compiler error that says something along the lines of Incompatible types: `Integer'
and `Real'. This compiler error is telling you that you are trying to assign a value
that cannot be stored by this particular data type. Another compiler error you might
see has to do with what is called <I>range checking</I>. Take this code, for instance:</P>
<P>
<PRE>var
  X : Byte;
begin
  X := 1000;
end; 
</PRE>
<P>This code will generate a compi



ler error that states Constant expression violates
subrange bounds. The compiler is telling you that you can't assign a value of 1000
to the variable X because X is declared as a Byte and a Byte can only hold values
from 0 to 255.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>TIP:</strong> Learn to treat compiler hints and warnings as errors. The compiler
	is trying to tell you that something is not quite right in your code, and you need
	to respect that warning. Ultimately, you should strive for warning-free compiles.
	In rare cases, a warning cannot be avoided, but be sure to examine all warnings closely.
	Do your best to understand the reason for the warning and correct it if possible.
	
<HR>


</BLOCKQUOTE>

<H3></H3>
<H3><A NAME="Heading18"></A>Object Pascal Operators</H3>
<P><I>Operators</I> are used to manipulate data. Operators perform calculations,
check for equality, make assignments, manipulate variables, and perform other, more
esoteric duties that most programmers never do. There are a lot of operators in Object
Pascal. Rather than present them all here, I will list only the most commonly used
ones. Table 1.2 contains a list of those operators.</P>
<P>
<H4>TABLE 1.2. COMMONLY USED OBJECT PASCAL OPERATORS.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>Operator</I></TD>
		<TD ALIGN="LEFT"><I>Description</I></TD>
		<TD ALIGN="LEFT"><I>Example</I></TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER" COLSPAN="3">
			<P ALIGN="CENTER"><B>Mathematical Operators</B>
		</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">+</TD>
		<TD ALIGN="LEFT">Addition</TD>
		<TD ALIGN="LEFT">x := y + z;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">-</TD>
		<TD ALIGN="LEFT">Subtraction</TD>
		<TD ALIGN="LEFT">x := y - z;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">*</TD>
		<TD ALIGN="LEFT">Multiplication</TD>
		<TD ALIGN="LEFT">x := y * z;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">/</TD>
		<TD ALIGN="LEFT">Real num



ber division</TD>
		<TD ALIGN="LEFT">x := y / 3.14;</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">div</TD>
		<TD ALIGN="LEFT">Integer division</TD>
		<TD ALIGN="LEFT">x := y div 10;</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER" COLSPAN="3">
			<P ALIGN="CENTER"><B>Assignment Operators</B>
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<H4 ALIGN="CENTER">:=
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Assignment
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">x := 10;
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER" COLSPAN="3">
			<P ALIGN="CENTER"><B>Logical Operators</B>
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">and
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Logical AND
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if (x = 1) and (y = 2) then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">or
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Logical OR
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if (x = 1) or (y = 2) then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER" COLSPAN="3">
			<P ALIGN="CENTER"><B>Equality Operators</B>
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">=
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Equal to
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if (x = 10) then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">&lt;&gt;
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Not equal to
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if (x &lt;&gt; 10) then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">&lt;
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Less than
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if (x &lt; 10) then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIG



N="CENTER">
			<P ALIGN="CENTER">&gt;
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Greater than
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if (x &gt; 10) then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">&lt;=
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Less than or equal to
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if (x &lt;= 10) then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">&gt;=
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Greater than or equal to
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if (x &gt;= 10) then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER" COLSPAN="3">
			<P ALIGN="CENTER"><B>Unary Operators</B>
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">^
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Pointer operator
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">MyObject.Data^;
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">@
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Address of operator
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">ptr := @MyRecord;
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">and
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Bitwise AND
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">x := x and $02;
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">or
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Bitwise OR
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">x := x or $FF;
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">not
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Bitwise NOT
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">x := x and not $02;
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">not
		</TD>

	<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Logical NOT
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">if not Valid then ...
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER" COLSPAN="3">
			<P ALIGN="CENTER"><B>Miscellaneous Operators</B>
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">$
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Hex value operator
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">X := $FF;
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">[]
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Array subscript operator
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">X := MyArray[5];
		</TD>
	</TR>
	<TR ALIGN="CENTER" VALIGN="TOP">
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">.
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">Membership (dot) operator
		</TD>
		<TD ALIGN="CENTER">
			<P ALIGN="CENTER">X := Record.Data;
		</TD>
	</TR>
</TABLE>
</P>
<P>As you can see, the list of operators is a bit overwhelming. Don't worry about
trying to memorize each one. As you work with Object Pascal, you will gradually learn
how to use all the operators. Some operators you will rarely, if ever, use, and others
you will use all the time.</P>
<P>You will notice that the and, or, and not keywords are used in two contexts: logical
and bitwise. For example, the and keyword can be used to specify a logical AND operation
or a bitwise AND operation. Take a look at this code:</P>
<P>
<PRE>if (Started = True) and (X &gt; 20) then
  Z := X and Y;
</PRE>
<P>In this example, the and keyword is being used in two completely different contexts.
Without question, this can be confusing at first. Rest assured that the compiler
knows how the keyword is being used and will do the right thing. I'm getting a bit
too far ahead this early in the book, so don't worry if this isn't making much sense
right now. Later on it will almost certainly make more sense than it does right now.</P>
<P>You will see many examples of
these operators as you go through this book. Rather
than try to memorize the function of each operator, try instead to learn through
careful study of the sample programs and code snippets.</P>
<P>
<H3><A NAME="Heading19"></A>Constants</H3>
<P>As I said earlier, a constant is an identifier assigned to a value that does not
change. The terms &quot;variable&quot; and &quot;constant&quot; were not chosen at
random. A variable's value can be changed by the programmer; a constant's value cannot
be changed. Constants are declared using the const keyword. To declare a constant,
simply list the constant's name and its value--for example,</P>
<P>
<PRE>const
  DefaultWidth  = 400;
  DefaultHeight = 200;
  Description   = `Something really cool.';
</PRE>
<P>Notice that when declaring a constant, the equal sign is used and not the assignment
operator (:=). Notice also that no data type is specified. The compiler determines
the data type of the constant based on the value being assigned. The constants can
then be used in your code where you would normally have used a literal value.</P>
<P>Judicious use of constants makes the behavior of a program easy to change at a
later date if change becomes necessary. To change the behavior of the program, it
is only necessary to change the value of one or more constants at the top of the
unit, rather than hunting through the unit for every occurrence of 100 and changing
it to 120.</P>
<P>
<H3><A NAME="Heading20"></A>Arrays</H3>
<P>You can place any of the intrinsic Object Pascal data types into an array. An
<I>array</I> is simply a collection of values. For example, let's say you want to
keep an array of Integers that holds five integer values. You would declare the array
as follows:</P>
<P>
<PRE>var
</PRE>
<PRE>  MyArray : array[0..4] of Integer;
</PRE>
<P>In this case, the compiler allocates memory for the array, as illustrated in Figure
1.4. Because each integer requires 4 bytes of storage, the entire array will take
up 20 bytes in memory.</P>
<P><A HREF="javascript:popUp('28670104.gif



')"><B>FIGURE 1.4.</B></A><B> </B><I>Memory
allocation for an array of five integers.</I></P>
<P>Now that you have the array declared, you can fill it with values using the <I>subscript
operator</I> ([]) as follows:</P>
<P>
<PRE>MyArray[0] := -200;
MyArray[1] := -100;
MyArray[2] := 0;
MyArray[3] := 100;
MyArray[4] := 200;
</PRE>
<P>Later in your program, you can access the individual elements of the array, again
by using the subscript operator:</P>
<P>
<PRE>X := MyArray[3] + MyArray[4];  { result will be 300 }
</PRE>
<H4>Multidimensional Arrays</H4>
<P>Arrays can be multidimensional. To create a two-dimensional array of integers,
you would use code like this:</P>
<P>
<PRE>var
  MdArray : array[0..2, 0..4] of Integer;
</PRE>
<P>This allocates storage for 15 Integers (a total of 60 bytes, if you're keeping
score). You access elements of the array like you do a simple array, with the obvious
difference that you must supply two subscript operators. There are two ways of doing
this. The following two lines have the same result:</P>
<P>
<PRE>X := MdArray[1][1] + MdArray[2][1];
X := MdArray[1, 1] + MdArray[2, 1];
</PRE>
<P>Figure 1.5 illustrates how a two-dimensional array might look in memory.</P>
<P><A HREF="javascript:popUp('28670105.gif')"><B>FIGURE 1.5.</B></A><B> </B><I>A
two-dimensional array in memory.</I></P>


<BLOCKQUOTE>
	<P>
<HR>
<STRONG>NOTE:</STRONG> Under normal circumstances, range checking will keep you from
	attempting to write beyond the end of an array. For example, the following code will
	result in a compiler error:</P>
	<PRE>var
  MyArray : array[0..4] of Integer;
  X : Integer;
begin
  X := MyArray[3] + MyArray[5]; { Oops! 5 outside of range. }
end;</PRE>

</BLOCKQUOTE>

<PRE></PRE>


<BLOCKQUOTE>
	<P>The error will state Constant expression violates subrange bounds because MyArray[5]
	is outside of the declared range for the array. 
<HR>


</BLOCKQUOTE>

<P>The array range is defined when you declare the array. For example, if you want
to create an array with a lower bound of 10 and an upper bo



und of 20, you declare
it like this:</P>
<P>
<PRE>var
  MyArray : array[10..20] of Integer;
</PRE>
<PRE>Now the only elements of the array that can be accessed are elements 10 (the first element in the array) through 20 (the last element in the array). Array constants must be declared and initialized all at one time. The syntax looks like this:
</PRE>
<PRE>const
  myArray : array[0..4] of Integer = ( -200, -100, 0, 100, 200 );
</PRE>
<H4>The Low and High Functions</H4>
<P>The Low and High functions are used frequently when dealing with arrays. As I
said earlier, an array can be declared with variable lower and upper bounds. The
Low function will return the lower bound of an array, and the High function will
return the upper bound of the array--for example,</P>
<P>
<PRE>var
  X, I, Lower, Upper : Integer;
  MyArray : array[10..20] of Integer;
begin
  { Code to initialize MyArray here. }
  Lower := Low(MyArray);  { Lower now contains 10 }
  Upper := High(MyArray); { Upper now contains 20 } 
  X := 0;
  for I := Lower to Upper do 
    X := X + MyArray[I];
  { Now do something with X. }
end;
</PRE>
<P>Using the Low and High functions ensures that you don't attempt to access an array
value outside of the array bounds.</P>
<P>
<H4>Dynamic Arrays</H4>
<P>Delphi 4 introduces the concept of dynamic arrays. A dynamic array is declared
without an initial size, and no storage is set aside for the array at the time of
declaration. Later the array can be created with a specified size using the SetLength
function. Here's how it would look:</P>
<P>
<PRE>var
  BigArray : array of Integer; { no size }
  X : Integer;
begin
  X := GetArraySize;      { function which returns the needed size }
  SetLength(BigArray, X); { dynamically allocate array }
  { Now fill in and use BigArray }
end;
</PRE>
<P><strong>New Term:</strong> A <I>dynamic array</I> is an array for which memory is allocated
at runtime. A dynamic array can be made larger or smaller depending on the needs
of the program.</P>
<P>The significance is that the array can be al



located based on exactly the number
of elements required. To illustrate, let's say that you need an array of integers.
Let's further say that in some cases you might only need to allocate enough memory
for 10 integers, but in other cases you might need to allocate as many as 1,000 integers.</P>
<P>Your program doesn't know at compile time how many elements will be needed--that
number will not be known until runtime. Before the advent of dynamic arrays, you
would have been forced to declare an array with a size of 1,000 integers, wasting
a lot of memory if your application really only needs 10, 20, or 30 integers. With
dynamic arrays you can allocate only as much storage as is required at a given time.</P>
<P>You can reallocate an array using the Copy function. For example, let's say you
initially created an array with a size of 100 elements, and you now need to reallocate
the array to a size of 200 elements. In that case, the code would look like this:</P>
<P>
<PRE>Copy(BigArray, 200);
</PRE>
<P>The contents of the array are retained and the array size is increased by 100
elements to a total of 200 elements.</P>
<P>Two-dimensional dynamic arrays are created in much the same way. To create a two-dimensional
array, you use code like the following:</P>
<P>
<PRE>var
  BigArray : array of array of Integer;
begin
  SetLength(BigArray, 20, 20);
  BigArray[0][0] := 200;
  { More code here. }
end;
</PRE>
<P>After a dynamic array is created, its elements are accessed just like a regular
array.</P>
<P>
<H3><A NAME="Heading21"></A>Strings</H3>
<P>Strings are used heavily in programming. Object Pascal has three distinct string
types: long string, short string, and wide string. In addition to these string types,
Pascal also uses null-terminated strings. I'll go over each of these types briefly,
and then I'll discuss some of the string-manipulation functions.</P>
<P>
<H4>Short String</H4>
<P>The short string type is a fixed-length string of characters with a maximum size
of 255 characters. You declare a short string in one of t



wo ways. One way is to use
the predefined type ShortString to declare a short string with a size of 255 bytes.
You can also use the string keyword with the subscript operator to specify a size
when you declare the string:</P>
<P>
<PRE>var
  S1 : ShortString; { 255 characters long }
  S2 : string[20];  { 20 characters long }
</PRE>
<P>String manipulation using short strings is fast because the size of the memory
allocated for the string doesn't change. Still, the short string is considered an
obsolete type and it is recommended that long strings be used instead. Short strings
are termed length-byte strings because the first element of the string contains the
length of the string (the number of characters in the string). You can read the value
of the first element of a short string to determine the string's length--for example,</P>
<P>
<PRE>var
</PRE>
<PRE>  S   : ShortString; { 255 characters long }
  Len : Integer;
begin
  S   := `Hello';
  Len := Ord(S[0]); { `L' now contains the length of S, or 5 }
end;
</PRE>
<P>This example reads the value of S[0] to determine the string's length. You can
also use the Length function to determine the length of a short string. I'll discuss
the Length function in just a bit.</P>


<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> You use the Ord function to convert the value of a Char type to an
	integer value (and ordinal value). The Ord function is also used with enumerations.
	
<HR>


</BLOCKQUOTE>

<P>If needed, you can write to the first element of a short string to specifically
set the length of the string. This is required in certain programming situations,
which I won't go into here. I should add that, in general, use of the 0 byte of a
short string is an advanced programming technique and is not recommended for beginning
programmers.</P>
<P>
<H4>Long String</H4>
<P>The long string data type is a dynamically allocated string object. The size of
a long string is limited only by available memory. Object Pascal allocates and de-allocates
memory for the string as needed. Long s



trings are very flexible but are sometimes
slower than short strings when a lot of string-manipulation is being done. This is
due to the overhead needed to dynamically allocate storage for the long string as
the string's contents change. Still, unless execution speed is critical, you should
generally stick to using long strings in your applications.</P>
<P>To declare a long string, simply use the string keyword without a size parameter:</P>
<P>
<PRE>var
  S : string;  { long string, dynamically allocated }
</PRE>
<P>Because the string is dynamically allocated, you can modify the string in any
way you want and never have to worry about what is going on behind the scenes. The
long string is very easy to use because you don't have to worry about running out
of space or about memory allocation for the string. It's all more or less automatic.</P>
<P>Long strings do not have a 0 element as short strings do. Attempting to access
the 0 element of a long string will result in a compiler error. Instead, you get
the length of a long string using the Length function and set the length using the
SetLength procedure. I'll discuss the string manipulation functions in the section
&quot;String Functions.&quot;</P>
<P>
<H4>Wide String</H4>
<P>The wide string type is used when dealing with Windows API functions that require
double-byte character strings (Unicode character strings). The wide string is like
the long string in that the size is limited only by available memory and memory for
the string is dynamically allocated. I won't go into any detail on wide string because
its use is limited primarily to dealing with OLE functions.</P>
<P>
<H4>Null-Terminated Strings: PChar and Array of Char</H4>
<P>Unlike Object Pascal, the C and C++ languages do not have true string data types.
In C and C++, strings are implemented as an array of characters terminated with a
terminating null (a 0 at the end of the string). Character arrays don't have a length
byte, so the terminating null is used to mark the end of the string of characters.
Becau



se Windows was written in C, many Windows functions require a character array
as a parameter. The Pascal string types are not character arrays, so a way of enabling
Pascal strings to work with Windows functions requiring a character array is needed.
The PChar type fills this need. A PChar can be used anywhere a character array is
needed. An example is the Windows MessageBox function. This function, which displays
a standard Windows message dialog, has the following declaration:</P>
<P>
<PRE>function MessageBox(hWnd: HWND; lpText, lpCaption: PChar; uType: UINT): Integer;
</PRE>
<P>The second and third parameters require a pointer to a character array (the second
for the message box text and the third for the message box caption). In order to
call this function from a Delphi program, you have to use the PChar type as follows:</P>
<P>
<PRE>var
  Text    : string;
  Caption : string;
begin
  Text := `This is a test.;
  Caption := `Test Message';
  MessageBox(0, PChar(Text), PChar(Caption), 0);
end;
</PRE>
<P>Here the PChar is used to cast the Pascal long string to a null-terminated string.
You can also use a PChar by itself. The following illustrates:</P>
<P>
<PRE>var
  Text : PChar;
begin
  Text := `This is a test.';
  MessageBox(0, Text, `Message', 0);
end;
</PRE>
<P>Because the strength of the Pascal string types is in string manipulation, you
probably won't use a PChar like this very often. You will typically use a PChar to
convert a long string to a null-terminated string as in the previous example. Note
that you can pass a string literal (a string of characters within single quotes)
to a Windows API function expecting a PChar.</P>
<P>Finally, you can use an array of the Char data type in place of a PChar. Once
again, the previous code snippet is modified to illustrate:</P>
<P>
<PRE>var
  Text : array [0..20] of Char;
begin
  Text := `This is a test.';
  MessageBox(0, Text, `Message', 0);
end;
</PRE>
<P>It really doesn't matter which of these methods you use. Just understand that
you cannot use a Pascal string d



ata type to call Windows API functions that require
a null-terminated string as a parameter. In those cases, you have to use PChar or
an array of Char.</P>
<P>
<H3><A NAME="Heading22"></A>String Basics</H3>
<P>The Pascal string types have several elements in common. The following sections
describe general string operations that apply to all string types.</P>
<P><B>String Concatenation Using the + Operator</B></P>
<P>A common programming task is that of concatenating (adding together) strings.
Strings can be concatenated using the + operator--for example,</P>
<P>
<PRE>var
  S1 : string;
  S2 : string;
begin
  S1 := `Mallory Kim';
  S2 := `Reisdorph';
  Label1.Caption := S1 + ` ` + S2;
end;
</PRE>
<P>This code concatenates three strings (the variable S1, a string literal containing
a space, and the variable S2) and assigns the result to a label's Caption property.
Any expression or function that evaluates to a string can be used in concatenation.
Here's another example:</P>
<P>
<PRE>var
  X :  Integer;
begin
  X := 199;
  Label1.Caption := `The result is: ` + IntToStr(X);
end;
</PRE>
<P>In this case, the IntToStr function returns a string so that you can use the result
from that function anywhere a string is required.</P>
<P><B>The Subscript Operator</B></P>
<P>Another common aspect of Pascal strings is the subscript operator ([]). You can
extract an individual character from a string using the subscript operator, as follows:</P>
<P>
<PRE>var
  S1 : string;
  S2 : Char;
begin
  S1 := `Hello World!';
  S2 := S1[1];
  Label1.Caption := S2;
end;
</PRE>
<P>The variable S2 in this example is a Char, but it could have been a long string,
a short string, or a wide string. Object Pascal makes the proper conversions behind
the scenes so you don't have to deal with the different string types at the application
level. The subscript operator is handy when you need to search through a string one
character at a time.</P>
<P>Strings are one-based: the first character in the string is at S[1]. Remember
that the 0 element of a shor



t string (S[0]) contains the length of the string and
not the first character in the string. You cannot access S[0] in long strings or
wide strings.</P>
<P><B>Control Characters in Strings</B></P>
<P>Object Pascal enables you to embed control characters in strings. This is useful
if you need to add non-printing characters to your strings. This could be as simple
as starting a new line in a character string, or it could be more complex, such as
embedding control characters in a string sent to a serial device.</P>
<P>You add control characters to a string using the # character. If, for example,
you want to embed an escape character (ASCII 27) in your string, you would do so
as follows:</P>
<P>
<PRE>S := `This is a test. Escape follows.'#27'Finished.';
</PRE>
<P>Notice that the embedded character, #27, is placed outside of any literal character
string, and that no spaces are between the embedded character and the preceding and
following strings. You must follow this structure when using embedded characters.
Of course, you don't have to use literal strings, you could use string variables
as well:</P>
<P>
<PRE>S1 := `This is a test. Escape follows.';
S2 := `Finished.';
S3 := S1 + #27 + S2;
</PRE>
<P>You can easily test this theory. Place a button and a label on a form. Double-click
the button and add this line to the button's OnClick event handler:</P>
<P>
<PRE>Label1.Caption := `Line 1' + #10 + `Line 2';
</PRE>
<P>Now run the program and click the button. The label will contain two lines of
text, as shown in Figure 1.6. This code simply embeds a carriage return character
(ASCII 10) in the string, thereby breaking the label into two lines.</P>
<P><A HREF="javascript:popUp('28670106.gif')"><B>FIGURE 1.6.</B></A><B> </B><I>A
label with two lines.</I></P>
<P>Extending Strings Across Multiple Code Lines</P>
<P>It is often necessary to break a literal string across two or more code lines
to increase readability and maintainability of your code. A long text message, for
example, might be well over 200 characters. You could
put all of those characters
on one line of code (the maximum line length of the Delphi Code Editor is 1,024 characters),
but that would make the code almost impossible to read. Instead you can split the
string across multiple lines. To do that you need to use the + operator--for example,</P>
<P>
<PRE>MessageBox(0, `This is a very, very long message ` + 
  `that seems to go on and on forever. In order ` +
  `to make the code more readable the message has ` +
  `been split across several lines of code.', `Message', 0);
</PRE>
<P>Remember earlier when I talked about semicolons at the end of each code statement?
Here's an example where a statement is spread across multiple lines. It's still a
single statement as far as the compiler is concerned, so the semicolon is at the
end of the <I>statement</I> and not at the end of each line.</P>
<P><B>String Comparison</B></P>
<P>Strings can be compared using the comparison operators. Table 1.3 lists the usual
operators and their descriptions.</P>
<P>
<H4>TABLE 1.3. STRING COMPARISON OPERATORS.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>Operator</I></TD>
		<TD ALIGN="LEFT"><I>Description</I></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">=</TD>
		<TD ALIGN="LEFT">Equal to</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&lt;&gt;</TD>
		<TD ALIGN="LEFT">Not equal to</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&lt;</TD>
		<TD ALIGN="LEFT">Less than</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&gt;</TD>
		<TD ALIGN="LEFT">Greater than</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&lt;=</TD>
		<TD ALIGN="LEFT">Less than or equal to</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">&gt;=</TD>
		<TD ALIGN="LEFT">Greater than or equal to</TD>
	</TR>
</TABLE>
</P>
<P>Note that these operators compare strings based on their ASCII values. Most of
the time you will use just the equality operators to see whether a string is equal
to a certain value or not



 equal to a certain value. If you are doing string sorting,
you will probably use the other string comparison operators as well. The following
example checks to see whether a string contains a certain value:</P>
<P>
<PRE>if FileName = `TEST.TXT' then
  OpenFile(FileName)
else
  ReportError;
</PRE>
<H4>String-Manipulation Functions</H4>
<P>Object Pascal includes many functions and procedures for string manipulation.
Table 1.4 lists a few of the most commonly used string functions and procedures;
this is by no means a complete list. Consult the Delphi online help for a list of
all string functions and procedures.</P>
<P>
<H4>TABLE 1.4. STRING MANIPULATION FUNCTIONS AND PROCEDURES.</H4>
<P>
<TABLE BORDER="1">
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT"><I>Name</I></TD>
		<TD ALIGN="LEFT"><I>Description</I></TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Copy</TD>
		<TD ALIGN="LEFT">Returns a sub-string within a string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Delete</TD>
		<TD ALIGN="LEFT">Deletes part of a string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Format</TD>
		<TD ALIGN="LEFT">Formats and returns a string based on the format string and arguments passed.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Insert</TD>
		<TD ALIGN="LEFT">Inserts text into a string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">IntToStr</TD>
		<TD ALIGN="LEFT">Converts an integer value to a string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Length</TD>
		<TD ALIGN="LEFT">Returns the length of a string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">LowerCase</TD>
		<TD ALIGN="LEFT">Converts a string to lowercase.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Pos</TD>
		<TD ALIGN="LEFT">Returns the position of a search string within a string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">StringOfChar</TD>
		<TD ALIGN="LEFT">Returns a string filled with the given numbe



r of a particular character.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">StrPas</TD>
		<TD ALIGN="LEFT">Converts a null-terminated string (PChar or array of Char) to a Pascal-style string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">StrPCopy</TD>
		<TD ALIGN="LEFT">Converts a Pascal-style string to a null-terminated string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">StrToInt</TD>
		<TD ALIGN="LEFT">Converts a string to an integer. If the string cannot be converted, an exception
			is thrown.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">StrToIntDef</TD>
		<TD ALIGN="LEFT">Converts a string to an integer and supplies a default value in case the string cannot
			be converted. No exception is thrown if the string cannot be converted.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">StrToXXX</TD>
		<TD ALIGN="LEFT">Additional conversion functions that convert a string to a floating point, Currency,
			Date, or Time value.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">Trim</TD>
		<TD ALIGN="LEFT">Trims leading and trailing blank space from a string.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">UpperCase</TD>
		<TD ALIGN="LEFT">Converts a string to uppercase.</TD>
	</TR>
	<TR ALIGN="LEFT" VALIGN="TOP">
		<TD ALIGN="LEFT">XXXToSTr</TD>
		<TD ALIGN="LEFT">Additional conversion functions that convert a floating point, Currency, Date, or
			Time value to a string.</TD>
	</TR>
</TABLE>



<BLOCKQUOTE>
	<P>
<HR>
<strong>NOTE:</strong> Object Pascal has an additional set of functions that operates on
	null- terminated strings. I won't list all of those here, because most of the time
	you will be working with Pascal strings and not null-terminated strings. Check the
	Delphi help for additional information on those functions. Most of the functions
	that operate on null-terminated strings begin with Str. 
<HR>


</BLOCKQUOTE>

<P>A few of the functions and procedures listed in Table 1.4 deserve special ment



ion.
The StrToInt function converts a string to an integer value. Let's say you have an
edit component on a form that will be used to retrieve an integer value from the
user. Because an edit component only holds text, you need to convert that text to
an integer. You can do it like this:</P>
<P>
<PRE>Value := StrToInt(Edit1.Text);
</PRE>
<PRE>The other StrToXXX functions (StrToFloat, StrToDate, and so on) work in exactly the same way. Note that these functions will throw an exception if the conversion cannot be made. If, for example, the user enters S123, an exception will be thrown 
because the letter <I>S</I> cannot be converted to an integer. I haven't talked about exceptions yet, so I won't go into detail on exceptions at this time.
</PRE>
<P>The Format function enables you to build a string by passing a format string and
additional arguments. The following is an example that adds two numbers and then
uses Format to build a string to report the result:</P>
<P>
<PRE>var
  S : string;
  X : Integer;
begin
  X := 10 * 20;
  S := Format(`The result is: %d', [X]);
  Label1.Caption := S;
end;
</PRE>
<P>When this section of code executes, the label contains this text:</P>
<P>
<PRE>The result is: 200
</PRE>
<P>In this example, the %d tells the Format function, &quot;An integer value will
go here.&quot; At the end of the format string, the variable X is inserted to tell
Format what value to put at that location in the string (the contents of the variable
X).</P>
<P>Format is a unique function in that it can take a variable number of arguments.
(That is why the variable X is in square brackets; the arguments passed are in the
form of an array of const.) You must supply the format string, but the number of
arguments that come after the format string is variable. Here is an example of Format
that uses three additional arguments:</P>
<P>
<PRE>var
  X : Integer;
  Y : Integer;
begin
  X := 20;
  Y := 5;
  Label1.Caption := Format(`%d + %d = %d', [X, Y, X + Y]);
end;
</PRE>
<P>When this piece of code executes, the result dis



played in the label will be:</P>
<P>
<PRE>20 + 5 = 25
</PRE>
<P>Notice that in this example I am assigning the return value from Format directly
to the Caption property of a label. In the previous example I assigned the return
value from Format to a variable, but that step was not strictly necessary.</P>
<P>Additional format specifiers are used to display a number as a floating point,
in scientific notation, in hexadecimal, or to display characters and strings. You
can specify the number of decimal places to use for floating-point numbers and the
number of digits to display for integer values. See the &quot;Format Strings&quot;
topic in the Delphi help for full details.</P>
<P>
<H2><A NAME="Heading23"></A>Summary</H2>
<P>You've covered a lot of ground today. First, you got to tinker with the Delphi
IDE by creating a Hello World! program. Following that, you got to do a little more
interesting programming when you created Hello World!, Part II. After the initial
playing around, you were put to work learning the basics of the Object Pascal language.
There is a lot of material to absorb in this chapter. Don't feel bad if you can't
remember it all. Go back and review if you are unclear about anything presented today.</P>
<P>
<H2><A NAME="Heading24"></A>Workshop</H2>
<P>The Workshop contains quiz questions to help you solidify your understanding of
the material covered and exercises to provide you with experience in using what you
have learned. You can find answers to the quiz questions in Appendix A, &quot;Answers
to the Quiz Questions.&quot;</P>
<P>
<H3><A NAME="Heading25"></A>Q&amp;A</H3>

<DL>
	<DT></DT>
	<DD><B>Q What's the difference between a Win32 GUI application and a Win32 console-mode
	application?</B>
	<P>
	<DT></DT>
	<DD><B>A</B> A GUI application is a traditional Windows program. It usually has a
	title bar, menu bar, and window area. A console-mode application is a 32-bit application
	that runs in an MS-DOS box in Windows. The console application looks like a DOS program.
	<P>
	<DT></DT>
	<DD><B>Q After



 I declare a constant, can I change its value in my program?</B>
	<P>
	<DT></DT>
	<DD><B>A</B> No. Constants are just that: constant. If you need to change values,
	you should use a variable not a constant.
	<P>
	<DT></DT>
	<DD><B>Q Are my units required to have an interface section?</B>
	<P>
	<DT></DT>
	<DD><B>A</B> Yes (all units except the project source, that is). The interface section
	might be empty, but it must be present.
	<P>
	<DT></DT>
	<DD><B>Q Should I use short strings or long strings in my Delphi applications?</B>
	<P>
	<DT></DT>
	<DD><B>A</B> For the most part you should use long strings. Long strings have virtually
	no size limit and all memory allocation and de-allocation is handled for you automatically.
	Short strings can be faster when you are doing a lot of heavy string manipulation,
	but most of the time the speed difference is not appreciable.
	<P>
	<DT></DT>
	<DD><B>Q Can I assign a number containing decimal places to an integer data type
	variable?</B>
	<P>
	<DT></DT>
	<DD><B>A</B> No. You cannot assign a floating point value to an integer variable.
	<P>
	<DT></DT>
	<DD><B>Q Will Object Pascal make sure I don't overwrite memory somewhere if I attempt
	to write past the end of an array?</B>
	<P>
	<DT></DT>
	<DD><B>A</B> For the most part, yes. Range checking at compile time will ensure that
	you don't attempt to write out of the bounds of an array.
	<P>
</DL>

<H3><A NAME="Heading26"></A>Quiz</H3>

<DL>
	<DT></DT>
	<DD><B>1. </B>What is the filename extension of a Pascal unit?
	<P>
	<DT></DT>
	<DD><B>2. </B>What is the name of the keyword that marks the section in which variables
	are declared?
	<P>
	<DT></DT>
	<DD><B>3. </B>What does the IntToStr function do?
	<P>
	<DT></DT>
	<DD><B>4. </B>What is the purpose of the uses list in a Pascal unit?
	<P>
	<DT></DT>
	<DD><B>5. </B>Are the following two declarations different? Why or why not?
	<P>
</DL>



<BLOCKQUOTE>
	<PRE>var
  top : Integer;
  Top : Integer;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
	<DT></DT>
	<DD><B>6. </B>How do you concaten



ate Pascal strings?
    <P>
    <DD><B>7. </B>How can you embed a control character in a string?
       <P><B>8. </B>What is the maximum length of a short string?</P>
 <P>
    <DT></DT>
      <DD><B>9. </B>Look at this line of code:
       <P>
</DL>



<BLOCKQUOTE>
 <PRE>MyArray : array [0..10] of Byte;</PRE>

</BLOCKQUOTE>

<PRE></PRE>

<DL>
 <DT></DT>
 <DD>How many bytes can this array hold?
 <P>
 <DT></DT>
 <DD><B>10. </B>What is the index number of the first element of an array, 0 or 1?
 <P>
</DL>

<H3><A NAME="Heading27"></A>Exercises</H3>

<DL>
 <DT></DT>
 <DD><B>1. </B>Write a Windows program that displays the words Welcome to Delphi!
 on the window when the program runs.
 <P>
 <DT></DT>
 <DD><B>2. </B>Rewrite the program you wrote in step 1 and change the displayed text
 to Hello There! (Hint: You have to change only the Caption property of the Label
 component.)
 <P>
 <DT></DT>
 <DD><B>3. </B>Write a program that declares two variables and assign values to those
 variables. Multiply the two numbers together and display the result on the screen.
 <P>
 <DT></DT>
 <DD><B>4. </B>Write a program that assigns the string, &quot;There are eggs in a
 dozen.&quot; to a variable and then inserts the string &quot;12 &quot; at the appropriate
 place in the string. Show the result in a label.
 <P>
 <DT></DT>
 <DD><B>5. </B>Write a program that creates the final result string in exercise 4,
 but formatted with the Format function.
</DL>

<H1></H1>
<CENTER>
<P>
<HR>
<A HREF="fm.htm"><IMG SRC="button/previous.gif" WIDTH="128" HEIGHT="28"
ALIGN="BOTTOM" ALT="Previous chapter" BORDER="0"></A><A HREF="ch02.htm"><IMG
SRC="button/next.gif" WIDTH="128" HEIGHT="28" ALIGN="BOTTOM" ALT="Next chapter"
BORDER="0"></A><A HREF="index.htm"><IMG SRC="button/contents.gif" WIDTH="128"
HEIGHT="28" ALIGN="BOTTOM" ALT="Contents" BORDER="0"></A></P>

<P>&#169; <A HREF="copy.htm">Copyright</A>, Macmillan Computer Publishing. All
rights reserved.
</CENTER>


</BODY>

</HTML>

